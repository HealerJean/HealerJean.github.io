

 <!DOCTYPE HTML>
<html lang="zh-CN">
<head>
  <meta name="baidu-site-verification" content="0r55fUD7QR" />
  <meta charset="UTF-8">
    
    
    
    
    <title>6、多线程的声明周期状态和volatile | HealeJean的梦想博客</title>


    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="HealerJean">
    

    
    <!--<%- open_graph({twitter_id: theme.author.twitter, google_plus: theme.author.google_plus}) %>-->

    <meta name="description" content="page.description">
    
    <meta property="og:type" content="article">
    
    <meta property="og:title" content="6、多线程的声明周期状态和volatile">
    <meta property="og:url" content="/thread/2018/05/03/6_%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%A3%B0%E6%98%8E%E5%91%A8%E6%9C%9F%E7%8A%B6%E6%80%81%E5%92%8CVolatile%E5%85%B3%E9%94%AE%E5%AD%97/">
    <meta property="og:site_name" content="HealeJean的梦想博客">
    <meta property="og:description" content="多线程的声明周期状态和volatile">
    <meta name="twitter:card" content="summary">
    <meta name="twitter:title" content="6、多线程的声明周期状态和volatile">
    <meta name="twitter:description" content="page.description">
    <meta name="twitter:creator" content="@mxzdhealer">
    <link rel="publisher" href="">

    
    <link rel="alternative" href="/atom.xml" title="HealeJean的梦想博客" type="application/atom+xml">
    
    
    <link rel="icon" href="/assets/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/assets/img/jacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/assets/img/jacman.jpg">
    

    <link rel="stylesheet" href="/assets/css/style.css" type="text/css">
    <link rel="stylesheet" href="/assets/css/highlight.css" type="text/css">
    
    
  <!-- 百度统计 -->
    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?19549885065170e0019f01e9975dfc1d";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>
    <!-- 百度联盟 -->
    <meta name="baidu_union_verify" content="c2f387067cf0849991ea870f73c055f2">
  
</head>

  <body>
    <header>
        <div>
		    
			<div id="imglogo">
				<a href="/"><img src="/assets/img/logo.png" alt="HealeJean的梦想博客" title="HealeJean的梦想博客"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="HealeJean的梦想博客">HealeJean的梦想博客</a></h1>
				<h2 class="blog-motto">一个高级软件开发工程师的成长之路</h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="menu">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">主页</a></li>
					
						<li><a href="/categories">技术</a></li>
					
						<li><a href="/archives">归档</a></li>
					
						<li><a href="/categories/#Job">生活日记</a></li>
					
						<li><a href="/about">留言板</a></li>
					
						<li><a href="/friends">友情链接</a></li>
					
					<li>
 					
					<form class="search" action="/search" method="get" accept-charset="utf-8">
						<input type="search" id="search" name="q" autocomplete="off" maxlength="20" placeholder="搜索" />
					</form>
					
					</li>
				</ul>
			</nav>
</div>

    </header>
    <div id="container">
      



<div id="main" class="post" itemscope itemprop="blogPost">
  
	<article itemprop="articleBody"> 
	<header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/thread/2018/05/03/6_%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%A3%B0%E6%98%8E%E5%91%A8%E6%9C%9F%E7%8A%B6%E6%80%81%E5%92%8CVolatile%E5%85%B3%E9%94%AE%E5%AD%97/" title="6、多线程的声明周期状态和volatile" itemprop="url">6、多线程的声明周期状态和volatile</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="HealerJean" target="_blank" itemprop="author">HealerJean</a>
		
  <p class="article-time">
    <time datetime="2018-05-03 00:33:00 +0800" itemprop="datePublished"> 发表于 2018-05-03</time>
    
  </p>
</header>
	<div class="article-content">
		
		<div id="toc" class="toc-article toc-content" style="display: none;">
		
			<!--<%- toc(item.content) %>-->
		
		</div>
		
		<!-- image url 
https://raw.githubusercontent.com/HealerJean/HealerJean.github.io/master/blogImages
　　首行缩进
<font color="red">  </font>
-->

<h2 id="前言">前言</h2>

<h2 id="1线程的几种状态">1、线程的几种状态</h2>

<p>之前我们说过线程的状态有新建、就绪、运行、阻塞、死亡。但是这是不全面的。一般概况就是 新建状态、运行状态、、阻塞、无限等待状态、、有限等待状态、死亡、</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
 * @Description
 * @Author HealerJean
 * @Date 2018/4/28  上午11:25.
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ThreadStatus</span> <span class="o">{</span>

    <span class="nd">@Test</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">threadStatus</span><span class="o">(){</span>

        <span class="k">for</span><span class="o">(</span><span class="n">Thread</span><span class="o">.</span><span class="na">State</span> <span class="nl">state:</span><span class="n">Thread</span><span class="o">.</span><span class="na">State</span><span class="o">.</span><span class="na">values</span><span class="o">()){</span>
            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">state</span><span class="o">.</span><span class="na">name</span><span class="o">());</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>


<span class="n">NEW</span> <span class="c1">//新建状态</span>
<span class="n">RUNNABLE</span> <span class="c1">//运行状态</span>
<span class="n">BLOCKED</span> <span class="c1">//阻塞状态</span>
<span class="n">WAITING</span> <span class="c1">//调用object.wait(),object.join() ，如果将它变成RUNNABLE状态调用Object.notify()</span>
<span class="n">TIMED_WAITING</span>  <span class="c1">//这个和wainting有点类似，但是这个是有时间限制的。如果超过了时间，自动变成RUNNABLE</span>
<span class="n">TERMINATED</span> <span class="c1">//terminated 当抛出异常或者是正常结束就会变成这个状态</span>

</code></pre></div></div>

<h2 id="2内存模型">2、内存模型</h2>

<p>计算机在执行程序时，每条指令都是在CPU中执行的，而执行指令过程中，势必涉及到数据的读取和写入。<font color="red"> 由于程序运行过程中的临时数据是存放在主存（物理内存）当中的，这时就存在一个问题，由于CPU执行速度很快，而从内存读取数据和向内存写入数据的过程跟CPU执行指令的速度比起来要慢的多，因此如果任何时候对数据的操作都要通过和内存的交互来进行，会大大降低指令执行的速度。因此在CPU里面就有了高速缓存。 </font>
　　也就是，当程序在运行过程中，会将运算需要的数据从主存复制一份到CPU的高速缓存当中，那么CPU进行计算时就可以直接从它的高速缓存读取数据和向其中写入数据，当运算结束之后，再将高速缓存中的数据刷新到主存当中。举个简单的例子，比如下面的这段代码：
算结束之后，再将高速缓存中的数据刷新到主存当中。举个简单的例子，比如下面的这段代码：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>i = i + 1;
</code></pre></div></div>

<p> 　　当线程执行这个语句时，会先从主存当中读取i的值，然后复制一份到高速缓存当中，然后CPU执行指令对i进行加1操作，然后将数据写入高速缓存，最后将高速缓存中i最新的值刷新到主存当中。
　　这个代码在单线程中运行是没有任何问题的，但是在多线程中运行就会有问题了。在多核CPU中，每条线程可能运行于不同的CPU中，因此每个线程运行时有自己的高速缓存（对单核CPU来说，其实也会出现这种问题，只不过是以线程调度的形式来分别执行的）。本文我们以多核CPU为例。</p>

<p>　　比如同时有2个线程执行这段代码，假如初始时i的值为0，那么我们希望两个线程执行完之后i的值变为2。但是事实会是这样吗？
　　可能存在下面一种情况：初始时，两个线程分别读取i的值存入各自所在的CPU的高速缓存当中，然后线程1进行加1操作，然后把i的最新值1写入到内存。此时线程2的高速缓存当中i的值还是0，进行加1操作之后，i的值为1，然后线程2把i的值写入内存。
　　最终结果i的值是1，而不是2。这就是著名的缓存一致性问题。通常称这种被多个线程访问的变量为共享变量。</p>

<h3 id="21并发编程中的三个概念">2.1、并发编程中的三个概念</h3>

<p>1.原子性
　　原子性：即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。
　　一个很经典的例子就是银行账户转账问题：
　　比如从账户A向账户B转1000元，那么必然包括2个操作：从账户A减去1000元，往账户B加上1000元。
　　试想一下，如果这2个操作不具备原子性，会造成什么样的后果。假如从账户A减去1000元之后，操作突然中止。然后又从B取出了500元，取出500元之后，再执行 往账户B加上1000元 的操作。这样就会导致账户A虽然减去了1000元，但是账户B没有收到这个转过来的1000元。
　　所以这2个操作必须要具备原子性才能保证不出现一些意外的问题。
　　
　　
2.可见性
　　可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。
　　举个简单的例子，看下面这段代码：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>//线程1执行的代码
int i = 0;
i = 10;
 
//线程2执行的代码
j = i;
</code></pre></div></div>

<p> 　　假若执行线程1的是CPU1，执行线程2的是CPU2。由上面的分析可知，当线程1执行 i =10这句时，会先把i的初始值加载到CPU1的高速缓存中，然后赋值为10，那么在CPU1的高速缓存当中i的值变为10了，却没有立即写入到主存当中。
　　此时线程2执行 j = i，它会先去主存读取i的值并加载到CPU2的缓存当中，注意此时内存当中i的值还是0，那么就会使得j的值为0，而不是10.
　　这就是可见性问题，线程1对变量i修改了之后，线程2没有立即看到线程1修改的值。</p>

<p>3.有序性
　　有序性：即程序执行的顺序按照代码的先后顺序执行。举个简单的例子，看下面这段代码：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int i = 0;              
boolean flag = false;
i = 1;                //语句1  
flag = true;          //语句2
</code></pre></div></div>

<p> 　　上面代码定义了一个int型变量，定义了一个boolean类型变量，然后分别对两个变量进行赋值操作。从代码顺序上看，语句1是在语句2前面的，那么JVM在真正执行这段代码的时候会保证语句1一定会在语句2前面执行吗？不一定，为什么呢？这里可能会发生指令重排序（Instruction Reorder）。
　　下面解释一下什么是指令重排序，一般来说，处理器为了提高程序运行效率，可能会对输入代码进行优化，它不保证程序中各个语句的执行先后顺序同代码中的顺序一致，但是它会保证程序最终执行结果和代码顺序执行的结果是一致的。
　　比如上面的代码中，语句1和语句2谁先执行对最终的程序结果并没有影响，那么就有可能在执行过程中，语句2先执行而语句1后执行。
　　但是要注意，虽然处理器会对指令进行重排序，但是它会保证程序最终结果会和代码顺序执行结果相同，那么它靠什么保证的呢？再看下面一个例子：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int a = 10;    //语句1
int r = 2;    //语句2
a = a + 3;    //语句3
r = a*a;     //语句4
</code></pre></div></div>

<p> 　　这段代码有4个语句，那么可能的一个执行顺序是：
　　
　　
　　那么可不可能是这个执行顺序呢： 语句2   语句1    语句4   语句3
　　<font color="red"> 不可能，因为处理器在进行重排序时是会考虑指令之间的数据依赖性，如果一个指令Instruction 2必须用到Instruction 1的结果，那么处理器会保证Instruction 1会在Instruction 2之前执行。 
　　虽然重排序不会影响单个线程内程序执行的结果， </font>但是多线程呢？下面看一个例子：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//线程1:</span>
<span class="n">context</span> <span class="o">=</span> <span class="n">loadContext</span><span class="o">();</span><span class="err">   </span><span class="c1">//语句1</span>
<span class="n">inited</span> <span class="o">=</span><span class="err"> </span><span class="kc">true</span><span class="o">;</span><span class="err">             </span><span class="c1">//语句2</span>
<span class="err"> </span>
<span class="c1">//线程2:</span>
<span class="k">while</span><span class="o">(!</span><span class="n">inited</span> <span class="o">){</span>
<span class="err">  </span><span class="n">sleep</span><span class="o">()</span>
<span class="o">}</span>
<span class="n">doSomethingwithconfig</span><span class="o">(</span><span class="n">context</span><span class="o">);</span>

</code></pre></div></div>

<p> 　　上面代码中，由于语句1和语句2没有数据依赖性，因此可能会被重排序。假如发生了重排序，在线程1执行过程中先执行语句2，而此是线程2会以为初始化工作已经完成，那么就会跳出while循环，去执行doSomethingwithconfig(context)方法，而此时context并没有被初始化，就会导致程序出错。
 　　从上面可以看出，指令重排序不会影响单个线程的执行，但是会影响到线程并发执行的正确性。
　　<font color="red">也就是说，要想并发程序正确地执行，必须要保证原子性、可见性以及有序性。只要有一个没有被保证，就有可能会导致程序运行不正确。</font></p>

<h2 id="22java内存模型">2.2、Java内存模型</h2>

<p>　Java内存模型规定所有的变量都是存在主存当中（类似于前面说的物理内存），每个线程都有自己的工作内存（类似于前面的高速缓存）。　　<font color="red">线程对变量的所有操作都必须在工作内存中进行，而不能直接对主存进行操作。并且每个线程不能访问其他线程的工作内存。</font></p>

<h3 id="221原子性">2.2.1、原子性</h3>

<p>在Java中，对基本数据类型的变量的读取和赋值操作是原子性操作，即这些操作是不可被中断的，要么执行，要么不执行。
　　上面一句话虽然看起来简单，但是理解起来并不是那么容易。看下面一个例子i：
　　请分析以下哪些操作是原子性操作：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">x</span> <span class="o">=</span><span class="err"> </span><span class="mi">10</span><span class="o">;</span><span class="err">         </span><span class="c1">//语句1</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="o">;</span><span class="err">         </span><span class="c1">//语句2</span>
<span class="n">x</span><span class="o">++;</span><span class="err">           </span><span class="c1">//语句3</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span><span class="err"> </span><span class="mi">1</span><span class="o">;</span><span class="err">     </span><span class="c1">//语句4</span>
</code></pre></div></div>

<p> 　　咋一看，有些朋友可能会说上面的4个语句中的操作都是原子性操作。其实只有语句1是原子性操作，其他三个语句都不是原子性操作。
　　语句1是直接将数值10赋值给x，也就是说线程执行这个语句的会直接将数值10写入到工作内存中。
　　语句2实际上包含2个操作，它先要去读取x的值，再将x的值写入工作内存，虽然读取x的值以及 将x的值写入工作内存 这2个操作都是原子性操作，但是合起来就不是原子性操作了。
　　同样的，x++和 x = x+1包括3个操作：读取x的值，进行加1操作，写入新的值。
 　　所以上面4个语句只有语句1的操作具备原子性。
　　也就是说，只有简单的读取、赋值（而且必须是将数字赋值给某个变量，变量之间的相互赋值不是原子操作）才是原子操作。</p>

<p>　　从上面可以看出，Java内存模型只保证了基本读取和赋值是原子性操作，如果要实现更大范围操作的原子性，可以通过synchronized和Lock来实现。由于synchronized和Lock(三者都可以)能够保证任一时刻只有一个线程执行该代码块，那么自然就不存在原子性问题了，从而保证了原子性。</p>

<h3 id="222可见性">2.2.2、可见性</h3>

<p>　　对于可见性，Java提供了volatile关键字来保证可见性。
　<font color="red">
　当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。</font>
　　而普通的共享变量不能保证可见性，因为普通共享变量被修改之后，什么时候被写入主存是不确定的，当其他线程去读取时，此时内存中可能还是原来的旧值，因此无法保证可见性。
　　另外，通过synchronized和Lock也能够保证可见性，synchronized和Lock能保证同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将对变量的修改刷新到主存当中。因此可以保证可见性。</p>

<h3 id="223有序性">2.2.3、有序性</h3>
<p>　　在Java内存模型中，允许编译器和处理器对指令进行重排序，但是重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。
　　在Java里面，可以通过volatile关键字来保证一定的“有序性”（具体原理在下一节讲述）。另外可以通过synchronized和Lock来保证有序性，很显然，synchronized和Lock保证每个时刻是有一个线程执行同步代码，相当于是让线程顺序执行同步代码，自然就保证了有序性。
　　另外，Java内存模型具备一些先天的“有序性”，即不需要通过任何手段就能够得到保证的有序性，这个通常也称为 happens-before 原则。如果两个操作的执行次序无法从happens-before原则推导出来，那么它们就不能保证它们的有序性，虚拟机可以随意地对它们进行重排序。</p>

<h2 id="3深入剖析volatile关键字">3、深入剖析volatile关键字</h2>

<h3 id="31volatile关键字的两层语义">3.1、volatile关键字的两层语义</h3>

<p>　　一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，那么就具备了两层语义：
　　1）保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。
　　2）禁止进行指令重排序。
　　先看一段代码，假如线程1先执行，线程2后执行：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//线程1</span>
<span class="kt">boolean</span><span class="err"> </span><span class="n">stop</span> <span class="o">=</span><span class="err"> </span><span class="kc">false</span><span class="o">;</span>
<span class="k">while</span><span class="o">(!</span><span class="n">stop</span><span class="o">){</span>
<span class="err">    </span><span class="n">doSomething</span><span class="o">();</span>
<span class="o">}</span>
<span class="err"> </span>
<span class="c1">//线程2</span>
<span class="n">stop</span> <span class="o">=</span><span class="err"> </span><span class="kc">true</span><span class="o">;</span>

</code></pre></div></div>

<p>这段代码是很典型的一段代码，很多人在中断线程时可能都会采用这种标记办法。但是事实上，这段代码会完全运行正确么？即一定会将线程中断么？不一定，也许在大多数时候，这个代码能够把线程中断，但是也有可能会导致无法中断线程（虽然这个可能性很小，但是只要一旦发生这种情况就会造成死循环了）。
　　下面解释一下这段代码为何有可能导致无法中断线程。在前面已经解释过，每个线程在运行过程中都有自己的工作内存，那么线程1在运行的时候，会将stop变量的值拷贝一份放在自己的工作内存当中。
　　那么当线程2更改了stop变量的值之后，但是还没来得及写入主存当中，线程2转去做其他事情了，那么线程1由于不知道线程2对stop变量的更改，因此还会一直循环下去。
　　但是用volatile修饰之后就变得不一样了：　<font color="red">
　　第一：使用volatile关键字会强制将修改的值立即写入主存；
　　第二：使用volatile关键字的话，当线程2进行修改时，会导致线程1的工作内存中缓存变量stop的缓存行无效（反映到硬件层的话，就是CPU的L1或者L2缓存中对应的缓存行无效）；
　　第三：由于线程1的工作内存中缓存变量stop的缓存行无效，所以线程1再次读取变量stop的值时会去主存读取。</font>
　　那么在线程2修改stop值时（当然这里包括2个操作，修改线程2工作内存中的值，然后将修改后的值写入内存），会使得线程1的工作内存中缓存变量stop的缓存行无效，然后线程1读取时，发现自己的缓存行无效，它会等待缓存行对应的主存地址被更新之后，然后去对应的主存读取最新的值。
　　那么线程1读取到的就是最新的正确的值。</p>

<h3 id="32volatile保证原子性吗不能">3.2、volatile保证原子性吗？不能！！！</h3>
<p>　　从上面知道volatile关键字保证了操作的可见性，但是volatile能保证对变量的操作是原子性吗？
　　下面看一个例子：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span><span class="err"> </span><span class="kd">class</span><span class="err"> </span><span class="nc">Test</span> <span class="o">{</span>
<span class="err">    </span><span class="kd">public</span><span class="err"> </span><span class="kd">volatile</span><span class="err"> </span><span class="kt">int</span><span class="err"> </span><span class="n">inc</span> <span class="o">=</span><span class="err"> </span><span class="mi">0</span><span class="o">;</span>
<span class="err">     </span>
<span class="err">    </span><span class="kd">public</span><span class="err"> </span><span class="kt">void</span><span class="err"> </span><span class="n">increase</span><span class="o">()</span> <span class="o">{</span>
<span class="err">        </span><span class="n">inc</span><span class="o">++;</span>
<span class="err">    </span><span class="o">}</span>
<span class="err">     </span>
<span class="err">    </span><span class="kd">public</span><span class="err"> </span><span class="kd">static</span><span class="err"> </span><span class="kt">void</span><span class="err"> </span><span class="n">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
<span class="err">        </span><span class="kd">final</span><span class="err"> </span><span class="n">Test</span> <span class="n">test</span> <span class="o">=</span><span class="err"> </span><span class="k">new</span><span class="err"> </span><span class="n">Test</span><span class="o">();</span>
<span class="err">        </span><span class="k">for</span><span class="o">(</span><span class="kt">int</span><span class="err"> </span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">10</span><span class="o">;</span><span class="n">i</span><span class="o">++){</span>
<span class="err">            </span><span class="k">new</span><span class="err"> </span><span class="n">Thread</span><span class="o">(){</span>
<span class="err">                </span><span class="kd">public</span><span class="err"> </span><span class="kt">void</span><span class="err"> </span><span class="n">run</span><span class="o">()</span> <span class="o">{</span>
<span class="err">                    </span><span class="k">for</span><span class="o">(</span><span class="kt">int</span><span class="err"> </span><span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span><span class="n">j</span><span class="o">&lt;</span><span class="mi">1000</span><span class="o">;</span><span class="n">j</span><span class="o">++)</span>
<span class="err">                        </span><span class="n">test</span><span class="o">.</span><span class="na">increase</span><span class="o">();</span>
<span class="err">                </span><span class="o">};</span>
<span class="err">            </span><span class="o">}.</span><span class="na">start</span><span class="o">();</span>
<span class="err">        </span><span class="o">}</span>
<span class="err">         </span>
<span class="err">        </span><span class="k">while</span><span class="o">(</span><span class="n">Thread</span><span class="o">.</span><span class="na">activeCount</span><span class="o">()&gt;</span><span class="mi">1</span><span class="o">)</span><span class="err">  </span><span class="c1">//保证前面的线程都执行完</span>
<span class="err">            </span><span class="n">Thread</span><span class="o">.</span><span class="na">yield</span><span class="o">();</span>
<span class="err">        </span><span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">test</span><span class="o">.</span><span class="na">inc</span><span class="o">);</span>
<span class="err">    </span><span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p> 　　大家想一下这段程序的输出结果是多少？也许有些朋友认为是10000。但是事实上运行它会发现每次运行结果都不一致，都是一个小于10000的数字。
　　可能有的朋友就会有疑问，不对啊，上面是对变量inc进行自增操作，由于volatile保证了可见性，那么在每个线程中对inc自增完之后，在其他线程中都能看到修改后的值啊，所以有10个线程分别进行了1000次操作，那么最终inc的值应该是1000*10=10000。
　　这里面就有一个误区了，volatile关键字能保证可见性没有错，但是上面的程序错在没能保证原子性。可见性只能保证每次读取的是最新的值，但是volatile没办法保证对变量的操作的原子性。
　　在前面已经提到过，自增操作是不具备原子性的，它包括读取变量的原始值、进行加1操作、写入工作内存。那么就是说自增操作的三个子操作可能会分割开执行，就有可能导致下面这种情况出现：
　　假如某个时刻变量inc的值为10，
　　线程1对变量进行自增操作，线程1先读取了变量inc的原始值，然后线程1被阻塞了；
　　然后线程2对变量进行自增操作，线程2也去读取变量inc的原始值，由于线程1只是对变量inc进行读取操作，而没有对变量进行修改操作，所以不会导致线程2的工作内存中缓存变量inc的缓存行无效，所以线程2会直接去主存读取inc的值，发现inc的值时10，然后进行加1操作，并把11写入工作内存，最后写入主存。
　　然后线程1接着进行加1操作，由于已经读取了inc的值，注意此时在线程1的工作内存中inc的值仍然为10，所以线程1对inc进行加1操作后inc的值为11，然后将11写入工作内存，最后写入主存。
　　那么两个线程分别进行了一次自增操作后，inc只增加了1。
　　解释到这里，可能有朋友会有疑问，不对啊，前面不是保证一个变量在修改volatile变量时，会让缓存行无效吗？然后其他线程去读就会读到新的值，对，这个没错。这个就是上面的happens-before规则中的volatile变量规则，但是要注意，线程1对变量进行读取操作之后，被阻塞了的话，并没有对inc值进行修改。然后虽然volatile能保证线程2对变量inc的值读取是从内存中读取的，但是线程1没有进行修改，所以线程2根本就不会看到修改的值。
　　根源就在这里，自增操作不是原子性操作，而且volatile也无法保证对变量的任何操作都是原子性的。
　　把上面的代码改成以下任何一种都可以达到效果：</p>

<h4 id="1synchronized">1、synchronized</h4>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Test</span> <span class="o">{</span>
    <span class="kd">public</span>  <span class="kt">int</span> <span class="n">inc</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    
    <span class="kd">public</span> <span class="kd">synchronized</span> <span class="kt">void</span> <span class="nf">increase</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">inc</span><span class="o">++;</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="kd">final</span> <span class="n">Test</span> <span class="n">test</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Test</span><span class="o">();</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">10</span><span class="o">;</span><span class="n">i</span><span class="o">++){</span>
            <span class="k">new</span> <span class="nf">Thread</span><span class="o">(){</span>
                <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
                    <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span><span class="n">j</span><span class="o">&lt;</span><span class="mi">1000</span><span class="o">;</span><span class="n">j</span><span class="o">++)</span>
                        <span class="n">test</span><span class="o">.</span><span class="na">increase</span><span class="o">();</span>
                <span class="o">};</span>
            <span class="o">}.</span><span class="na">start</span><span class="o">();</span>
        <span class="o">}</span>
        
        <span class="k">while</span><span class="o">(</span><span class="n">Thread</span><span class="o">.</span><span class="na">activeCount</span><span class="o">()&gt;</span><span class="mi">1</span><span class="o">)</span>  <span class="c1">//保证前面的线程都执行完</span>
            <span class="n">Thread</span><span class="o">.</span><span class="na">yield</span><span class="o">();</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">test</span><span class="o">.</span><span class="na">inc</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>

<h4 id="2采用lock">2、　　采用Lock：</h4>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Test</span> <span class="o">{</span>
    <span class="kd">public</span>  <span class="kt">int</span> <span class="n">inc</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="n">Lock</span> <span class="n">lock</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ReentrantLock</span><span class="o">();</span>
    
    <span class="kd">public</span>  <span class="kt">void</span> <span class="nf">increase</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">lock</span><span class="o">.</span><span class="na">lock</span><span class="o">();</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="n">inc</span><span class="o">++;</span>
        <span class="o">}</span> <span class="k">finally</span><span class="o">{</span>
            <span class="n">lock</span><span class="o">.</span><span class="na">unlock</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="kd">final</span> <span class="n">Test</span> <span class="n">test</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Test</span><span class="o">();</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">10</span><span class="o">;</span><span class="n">i</span><span class="o">++){</span>
            <span class="k">new</span> <span class="nf">Thread</span><span class="o">(){</span>
                <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
                    <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span><span class="n">j</span><span class="o">&lt;</span><span class="mi">1000</span><span class="o">;</span><span class="n">j</span><span class="o">++)</span>
                        <span class="n">test</span><span class="o">.</span><span class="na">increase</span><span class="o">();</span>
                <span class="o">};</span>
            <span class="o">}.</span><span class="na">start</span><span class="o">();</span>
        <span class="o">}</span>
        
        <span class="k">while</span><span class="o">(</span><span class="n">Thread</span><span class="o">.</span><span class="na">activeCount</span><span class="o">()&gt;</span><span class="mi">1</span><span class="o">)</span>  <span class="c1">//保证前面的线程都执行完</span>
            <span class="n">Thread</span><span class="o">.</span><span class="na">yield</span><span class="o">();</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">test</span><span class="o">.</span><span class="na">inc</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>

<h4 id="3atomicinteger">3、AtomicInteger</h4>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Test</span> <span class="o">{</span>
    <span class="kd">public</span>  <span class="n">AtomicInteger</span> <span class="n">inc</span> <span class="o">=</span> <span class="k">new</span> <span class="n">AtomicInteger</span><span class="o">();</span>
     
    <span class="kd">public</span>  <span class="kt">void</span> <span class="nf">increase</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">inc</span><span class="o">.</span><span class="na">getAndIncrement</span><span class="o">();</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="kd">final</span> <span class="n">Test</span> <span class="n">test</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Test</span><span class="o">();</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">10</span><span class="o">;</span><span class="n">i</span><span class="o">++){</span>
            <span class="k">new</span> <span class="nf">Thread</span><span class="o">(){</span>
                <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
                    <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span><span class="n">j</span><span class="o">&lt;</span><span class="mi">1000</span><span class="o">;</span><span class="n">j</span><span class="o">++)</span>
                        <span class="n">test</span><span class="o">.</span><span class="na">increase</span><span class="o">();</span>
                <span class="o">};</span>
            <span class="o">}.</span><span class="na">start</span><span class="o">();</span>
        <span class="o">}</span>
        
        <span class="k">while</span><span class="o">(</span><span class="n">Thread</span><span class="o">.</span><span class="na">activeCount</span><span class="o">()&gt;</span><span class="mi">1</span><span class="o">)</span>  <span class="c1">//保证前面的线程都执行完</span>
            <span class="n">Thread</span><span class="o">.</span><span class="na">yield</span><span class="o">();</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">test</span><span class="o">.</span><span class="na">inc</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>

<h3 id="32volatile能保证有序性吗">3.2、volatile能保证有序性吗？</h3>

<p>在前面提到volatile关键字能禁止指令重排序，所以volatile能在一定程度上保证有序性。
　　volatile关键字禁止指令重排序有两层意思：
　　1）当程序执行到volatile变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见；在其后面的操作肯定还没有进行；
　　2）在进行指令优化时，不能将在对volatile变量访问的语句放在其后面执行，也不能把volatile变量后面的语句放到其前面执行。
　　可能上面说的比较绕，举个简单的例子：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//x、y为非volatile变量</span>
<span class="c1">//flag为volatile变量</span>
<span class="err"> </span>
<span class="n">x</span> <span class="o">=</span><span class="err"> </span><span class="mi">2</span><span class="o">;</span><span class="err">        </span><span class="c1">//语句1</span>
<span class="n">y</span> <span class="o">=</span><span class="err"> </span><span class="mi">0</span><span class="o">;</span><span class="err">        </span><span class="c1">//语句2</span>
<span class="n">flag</span> <span class="o">=</span><span class="err"> </span><span class="kc">true</span><span class="o">;</span><span class="err">  </span><span class="c1">//语句3</span>
<span class="n">x</span> <span class="o">=</span><span class="err"> </span><span class="mi">4</span><span class="o">;</span><span class="err">         </span><span class="c1">//语句4</span>

</code></pre></div></div>

<p> 　　由于flag变量为volatile变量，那么在进行指令重排序的过程的时候，不会将语句3放到语句1、语句2前面，也不会讲语句3放到语句4、语句5后面。但是要注意语句1和语句2的顺序、语句4和语句5的顺序是不作任何保证的。
　　并且volatile关键字能保证，执行到语句3时，语句1和语句2必定是执行完毕了的，且语句1和语句2的执行结果对语句3、语句4、语句5是可见的。
　　那么我们回到前面举的一个例子：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//线程1:</span>
<span class="n">context</span> <span class="o">=</span> <span class="n">loadContext</span><span class="o">();</span><span class="err">   </span><span class="c1">//语句1</span>
<span class="n">inited</span> <span class="o">=</span><span class="err"> </span><span class="kc">true</span><span class="o">;</span><span class="err">             </span><span class="c1">//语句2</span>
<span class="err"> </span>
<span class="c1">//线程2:</span>
<span class="k">while</span><span class="o">(!</span><span class="n">inited</span> <span class="o">){</span>
<span class="err">  </span><span class="n">sleep</span><span class="o">()</span>
<span class="o">}</span>
<span class="n">doSomethingwithconfig</span><span class="o">(</span><span class="n">context</span><span class="o">);</span>

</code></pre></div></div>
<p>前面举这个例子的时候，提到有可能语句2会在语句1之前执行，那么久可能导致context还没被初始化，而线程2中就使用未初始化的context去进行操作，导致程序出错。
　　这里如果用volatile关键字对inited变量进行修饰，就不会出现这种问题了，因为当执行到语句2时，必定能保证context已经初始化完毕。</p>

<h3 id="34volatile的原理和实现机制">3.4、volatile的原理和实现机制</h3>

<p>　　前面讲述了源于volatile关键字的一些使用，下面我们来探讨一下volatile到底如何保证可见性和禁止指令重排序的。
　　下面这段话摘自《深入理解Java虚拟机》：
　　
　　“观察加入volatile关键字和没有加入volatile关键字时所生成的汇编代码发现，加入volatile关键字时，会多出一个lock前缀指令”
　　lock前缀指令实际上相当于一个内存屏障（也成内存栅栏），内存屏障会提供3个功能：
　　
　　1）它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成；
　　
　　2）它会强制将对缓存的修改操作立即写入主存；
　　
　　3）如果是写操作，它会导致其他CPU中对应的缓存行无效。</p>

<h3 id="35使用volatile关键字的场景">3.5、使用volatile关键字的场景</h3>

<p>使用volatile 的条件主要是 保证操作是原子性操作，才能保证使用volatile关键字的程序在并发时能够正确执行。（前提）</p>

<p>1、状态标记量</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">volatile</span><span class="err"> </span><span class="kt">boolean</span><span class="err"> </span><span class="n">flag</span> <span class="o">=</span><span class="err"> </span><span class="kc">false</span><span class="o">;</span>
<span class="err"> </span>
<span class="k">while</span><span class="o">(!</span><span class="n">flag</span><span class="o">){</span>
<span class="err">    </span><span class="n">doSomething</span><span class="o">();</span>
<span class="o">}</span>
<span class="err"> </span>
<span class="kd">public</span><span class="err"> </span><span class="kt">void</span><span class="err"> </span><span class="n">setFlag</span><span class="o">()</span> <span class="o">{</span>
<span class="err">    </span><span class="n">flag</span> <span class="o">=</span><span class="err"> </span><span class="kc">true</span><span class="o">;</span>
<span class="o">}</span>

</code></pre></div></div>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">volatile</span><span class="err"> </span><span class="kt">boolean</span><span class="err"> </span><span class="n">inited</span> <span class="o">=</span><span class="err"> </span><span class="kc">false</span><span class="o">;</span>
<span class="c1">//线程1:</span>
<span class="n">context</span> <span class="o">=</span> <span class="n">loadContext</span><span class="o">();</span><span class="err">  </span>
<span class="n">inited</span> <span class="o">=</span><span class="err"> </span><span class="kc">true</span><span class="o">;</span><span class="err">            </span>
<span class="err"> </span>
<span class="c1">//线程2:</span>
<span class="k">while</span><span class="o">(!</span><span class="n">inited</span> <span class="o">){</span>
<span class="n">sleep</span><span class="o">()</span>
<span class="o">}</span>
<span class="n">doSomethingwithconfig</span><span class="o">(</span><span class="n">context</span><span class="o">);</span>

</code></pre></div></div>

<p>2、单例模式检查</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span><span class="err"> </span><span class="nc">Singleton</span><span class="o">{</span>
<span class="err">    </span><span class="kd">private</span><span class="err"> </span><span class="kd">volatile</span><span class="err"> </span><span class="kd">static</span><span class="err"> </span><span class="n">Singleton</span> <span class="n">instance</span> <span class="o">=</span><span class="err"> </span><span class="kc">null</span><span class="o">;</span>
<span class="err">     </span>
<span class="err">    </span><span class="kd">private</span><span class="err"> </span><span class="n">Singleton</span><span class="o">()</span> <span class="o">{</span>
<span class="err">         </span>
<span class="err">    </span><span class="o">}</span>
<span class="err">     </span>
<span class="err">    </span><span class="kd">public</span><span class="err"> </span><span class="kd">static</span><span class="err"> </span><span class="n">Singleton</span> <span class="nf">getInstance</span><span class="o">()</span> <span class="o">{</span>
<span class="err">        </span><span class="k">if</span><span class="o">(</span><span class="n">instance</span><span class="o">==</span><span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
<span class="err">            </span><span class="kd">synchronized</span><span class="err"> </span><span class="o">(</span><span class="n">Singleton</span><span class="o">.</span><span class="na">class</span><span class="o">)</span> <span class="o">{</span>
<span class="err">                </span><span class="k">if</span><span class="o">(</span><span class="n">instance</span><span class="o">==</span><span class="kc">null</span><span class="o">)</span>
<span class="err">                    </span><span class="n">instance</span> <span class="o">=</span><span class="err"> </span><span class="k">new</span><span class="err"> </span><span class="n">Singleton</span><span class="o">();</span>
<span class="err">            </span><span class="o">}</span>
<span class="err">        </span><span class="o">}</span>
<span class="err">        </span><span class="k">return</span><span class="err"> </span><span class="n">instance</span><span class="o">;</span>
<span class="err">    </span><span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>

<p>volatile和synchronize区别</p>

<p>1、volatile修饰的变量，synchronize修饰的是同步代码块或者是同步方法
2、volatile不能保证原子性，synchronize能够保证原子性</p>

<p>博主文章来源,感谢<a href="https://blog.csdn.net/basycia/article/details/52058986">https://blog.csdn.net/basycia/article/details/52058986</a></p>

<p><br /><br /><br />
如果满意，请打赏博主任意金额，感兴趣的请下方留言吧。可与博主自由讨论哦</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">支付包</th>
      <th style="text-align: center">微信</th>
      <th style="text-align: center">微信公众号</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center"><img src="https://raw.githubusercontent.com/HealerJean/HealerJean.github.io/master/assets/img/tctip/alpay.jpg" alt="支付宝" /></td>
      <td style="text-align: center"><img src="https://raw.githubusercontent.com/HealerJean/HealerJean.github.io/master/assets/img/tctip/weixin.jpg" alt="微信" /></td>
      <td style="text-align: center"><img src="https://raw.githubusercontent.com/HealerJean/HealerJean.github.io/master/assets/img/my/qrcode_for_gh_a23c07a2da9e_258.jpg" alt="微信公众号" /></td>
    </tr>
  </tbody>
</table>

<!-- Gitalk 评论 start  -->

<link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css" />

<script src="https://unpkg.com/gitalk@latest/dist/gitalk.min.js"></script>
<p> </p>
<div id="gitalk-container"></div>
<p>  <br />
 <script type="text/javascript">
    var gitalk = new Gitalk({
		clientID: `1d164cd85549874d0e3a`,
		clientSecret: `527c3d223d1e6608953e835b547061037d140355`,
		repo: `HealerJean.github.io`,
		owner: 'HealerJean',
		admin: ['HealerJean'],
		id: 'c3tNKgjDaTAKn5EF',
    });
    gitalk.render('gitalk-container');
</script> </p>

<!-- Gitalk end -->

  
	</div>
	<footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <!--
  <%- list_categories(item.categories, {
      show_count: false,
      class: 'article-category',
      style: 'none',
      separator: '►'
  }) %>
  -->
  
  <a class="article-category-link" href="/categories/#Thread">Thread</a>
  
</div>


  <div class="article-tags">
  <!--
  <% var tags = [];
    item.tags.forEach(function(tag){
      tags.push('<a href="' + config.root + tag.path + '">' + tag.name + '</a>');
    }); %>-->
  <span></span> <!--<%- tags.join('') %>-->
  
  
  <a href="/tags/#Thread">Thread</a>
  
  </div>

</div>



	<div class="article-share" id="share">
	
	  <div data-url="http://localhost:4000/thread/2018/05/03/6_%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%A3%B0%E6%98%8E%E5%91%A8%E6%9C%9F%E7%8A%B6%E6%80%81%E5%92%8CVolatile%E5%85%B3%E9%94%AE%E5%AD%97/" data-title="6、多线程的声明周期状态和volatile | HealeJean的梦想博客" data-tsina="" class="share clearfix">
	  </div>
	
	</div>


</footer>
   
	</article>
	
<nav class="article-nav clearfix">
 
 <div class="prev" >
 <a href="/redis/2018/05/02/11_CacheCloud%E7%9B%91%E6%8E%A7%E8%BF%90%E7%BB%B4/" title="11、CacheCloud监控运维">
  <strong>上一篇：</strong><br/>
  <span>
  11、CacheCloud监控运维</span>
</a>
</div>


<div class="next">
<a href="/docker/2018/05/04/4_DockerUI/"  title="4、web管理工具DockerUI部署记录">
 <strong>下一篇：</strong><br/> 
 <span>4、web管理工具DockerUI部署记录
</span>
</a>
</div>

</nav>

	

</div>  

      
      
      <div class="openaside"><a class="navbutton" href="#" title="Show Sidebar"></a></div>

  <div id="toc" class="toc-aside toc-content">
 
 <!--<%- toc(item.content) %>-->
 
  </div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="Hide Sidebar"></a></div>
<aside class="clearfix">


  <div class="linkslist">
  <p class="asidetitle">个人网站</p>
    <ul>
        
          <li>
            <a href="http://blog.csdn.net/u012954706" target="_blank" title="csdn">csdn</a>
          </li>
        
          <li>
            <a href="http://www.cnblogs.com/HealerJean/" target="_blank" title="博客园">博客园</a>
          </li>
        
          <li>
            <a href="https://weibo.com/u/3889598250/" target="_blank" title="微博">微博</a>
          </li>
        
          <li>
            <a href="https://www.jianshu.com/u/54ba972e92a8" target="_blank" title="简书">简书</a>
          </li>
        
          <li>
            <a href="https://www.zhihu.com/people/healerjean" target="_blank" title="知乎">知乎</a>
          </li>
        
    </ul>
</div>

  <div class="weiboshow">

     <p class="asidetitle">个人信息</p>
     <script src="/assets/img/person/jquery.js"></script>
     <script src="/assets/img/person/jquery-github-user-widget.js"></script>
     <div class="github-widget-user" data-user="HealerJean">	</div>

</div>


  
<div class="tagslist">
	<p class="asidetitle">标签</p>
		<ul class="clearfix">
		
			
				<li><a href="/tags/#Job" title="Job">Job<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/#MarkDown" title="MarkDown">MarkDown<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/#GitHub" title="GitHub">GitHub<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/#Mac" title="Mac">Mac<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/#Thread" title="Thread">Thread<sup>7</sup></a></li>
			
		
			
				<li><a href="/tags/#Url" title="Url">Url<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/#Mysql" title="Mysql">Mysql<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/#Database" title="Database">Database<sup>19</sup></a></li>
			
		
			
				<li><a href="/tags/#Annotation" title="Annotation">Annotation<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/#SortAlgorithm" title="SortAlgorithm">SortAlgorithm<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/#CAS" title="CAS">CAS<sup>11</sup></a></li>
			
		
			
				<li><a href="/tags/#Maven" title="Maven">Maven<sup>4</sup></a></li>
			
		
			
				<li><a href="/tags/#HTML" title="HTML">HTML<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/#AngularJs" title="AngularJs">AngularJs<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/#WeChat" title="WeChat">WeChat<sup>9</sup></a></li>
			
		
			
				<li><a href="/tags/#Experience" title="Experience">Experience<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/#Team" title="Team">Team<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/#SoftWare" title="SoftWare">SoftWare<sup>5</sup></a></li>
			
		
			
				<li><a href="/tags/#Utils" title="Utils">Utils<sup>4</sup></a></li>
			
		
			
				<li><a href="/tags/#Hibernate" title="Hibernate">Hibernate<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/#Date" title="Date">Date<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/#Log" title="Log">Log<sup>4</sup></a></li>
			
		
			
				<li><a href="/tags/#JSON" title="JSON">JSON<sup>4</sup></a></li>
			
		
			
				<li><a href="/tags/#Docker" title="Docker">Docker<sup>16</sup></a></li>
			
		
			
				<li><a href="/tags/#GrayLog" title="GrayLog">GrayLog<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/#SpringBoot" title="SpringBoot">SpringBoot<sup>21</sup></a></li>
			
		
			
				<li><a href="/tags/#Redis" title="Redis">Redis<sup>16</sup></a></li>
			
		
			
				<li><a href="/tags/#Ehcache" title="Ehcache">Ehcache<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/#Druid" title="Druid">Druid<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/#Quartz" title="Quartz">Quartz<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/#Swagger" title="Swagger">Swagger<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/#Netty" title="Netty">Netty<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/#NIO" title="NIO">NIO<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/#WebSocket" title="WebSocket">WebSocket<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/#Map" title="Map">Map<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/#JVM" title="JVM">JVM<sup>11</sup></a></li>
			
		
			
				<li><a href="/tags/#Mybatis" title="Mybatis">Mybatis<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/#Element" title="Element">Element<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/#Graphics" title="Graphics">Graphics<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/#Linux" title="Linux">Linux<sup>4</sup></a></li>
			
		
			
				<li><a href="/tags/#Databases" title="Databases">Databases<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/#Nginx" title="Nginx">Nginx<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/#SpirngBoot" title="SpirngBoot">SpirngBoot<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/#Linu" title="Linu">Linu<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/#Java" title="Java">Java<sup>15</sup></a></li>
			
		
			
				<li><a href="/tags/#JAVA" title="JAVA">JAVA<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/#Google" title="Google">Google<sup>1</sup></a></li>
			
		
		</ul>
</div>


  


  


</aside>
</div>
    </div>
    <footer><div id="footer" >

	<!-- 打赏功能 -->
  <!-- <script src="http://static.tctip.com/tctip-1.0.0.min.js"></script> -->
  <script src="/assets/img/tctip/tctip-1.0.1.min.js"></script>
	<script>  
	new tctip({
	  top: '20%',
	  button: {
	    id: 9,
	    type: 'dashang',
	  },
	  list: [
	    {
	      type: 'alipay',
	      qrImg: '/assets/img/tctip/alpay.jpg'
	    }, {
	      type: 'wechat',
	      qrImg: '/assets/img/tctip/weixin.jpg'
	    }
	  ]
	}).init()
	</script>



	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<section class="info">
		<p> 欢迎来到  HealerJean 的梦想博客. <br/>
			------您已走进一个高级软件开发工程师的成长之路</p>
	</section>
	 


<!--  自带的分享功能 	-->
	<div class="social-font" class="clearfix">
		
		<a href="http://weibo.com/3889598250" target="_blank" class="icon-weibo" title="微博"></a>
		
		
		
		
		<a href="https://twitter.com/mxzdhealer" target="_blank" class="icon-twitter" title="twitter"></a>
		
		
		
		
		
		
		
		<a href="mailto:mxzdhealer@gmail.com" target="_blank" class="icon-email" title="Email Me"></a>
		
	</div> 


	<!--
			<%  Array.prototype.S=String.fromCharCode(2);
			  Array.prototype.in_array=function(e){
    			var r=new RegExp(this.S+e+this.S);
    			return (r.test(this.S+this.join(this.S)+this.S));
				};
				var cc = new Array('by','by-nc','by-nc-nd','by-nc-sa','by-nd','by-sa','zero'); %>
		<% if (cc.in_array(theme.creative_commons) ) { %>
				<div class="cc-license">
          <a href="http://creativecommons.org/licenses/<%= theme.creative_commons %>/4.0" class="cc-opacity" target="_blank">
            <img src="<%- config.root %>img/cc-<%= theme.creative_commons %>.svg" alt="Creative Commons" />
          </a>
        </div>
    <% } %>
				-->

		<p class="copyright">
		welcome to <a href="http://jekyllrb.com" target="_blank" title="jekyll">HealerJean</a> 
		blog <a href="https://github.com/simpleyyt/jekyll-jacman" target="_blank" title="Jacman">for</a> © 2017 
		
		<a href="about" target="_blank" title="HealerJean">HealerJean</a>
		
		
		</p>
</div>
</footer>
    <script src="/assets/js/jquery-2.0.3.min.js"></script>
<script src="/assets/js/jquery.imagesloaded.min.js"></script>
<script src="/assets/js/gallery.js"></script>
<script src="/assets/js/jquery.qrcode-0.12.0.min.js"></script>
<script src="/assets/js/toc.js"></script>

<script type="text/javascript">
$(document).ready(function(){
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });

  

  $(window).resize(function(){
    getSize();
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
      
      $('#toc.toc-aside').css('display', 'none');
      
    }
  });
});
</script>




<script type="text/javascript">
$(document).ready(function(){
  $('#toc.toc-aside').toc({
    title: "文章目录",
    showEffect: "none"
  });
  $('#toc.toc-article').toc({
    title: "文章目录",
    showEffect: "show",
    showSpeed: 0
  });
});
</script>



<script type="text/javascript">
$(document).ready(function(){
  var ai = $('.article-content>iframe'),
      ae = $('.article-content>embed'),
      t  = $('#toc'),
      ta = $('#toc.toc-aside'),
      o  = $('.openaside'),
      c  = $('.closeaside');
  if(ai.length>0){
    ai.wrap('<div class="video-container" />');
  };
  if(ae.length>0){
   ae.wrap('<div class="video-container" />');
  };
  c.click(function(){
    ta.css('display', 'block').addClass('fadeIn');
  });
  o.click(function(){
    ta.css('display', 'none');
  });
  $(window).scroll(function(){
    ta.css("top",Math.max(140,320-$(this).scrollTop()));
  });
});
</script>



<script type="text/javascript">
$(document).ready(function(){
  var $this = $('.share'),
      url = $this.attr('data-url'),
      encodedUrl = encodeURIComponent(url),
      title = $this.attr('data-title'),
      tsina = $this.attr('data-tsina'),
      description = $this.attr('description');
  var html = [
  '<div class="hoverqrcode clearfix"></div>',
  '<a class="overlay" id="qrcode"></a>',
  '<div class="qrcode clearfix"><span>扫描二维码分享到微信朋友圈</span><a class="qrclose" href="#nothing"></a><strong>Loading...Please wait</strong><img id="qrcode-pic" data-src="http://s.jiathis.com/qrcode.php?url=' + encodedUrl + '"/></div>',
  '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"></a>',
  '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
  '<a href="#qrcode" class="article-share-qrcode" title="微信"></a>',
  '<a href="http://widget.renren.com/dialog/share?resourceUrl=' + encodedUrl + '&srcUrl=' + encodedUrl + '&title=' + title +'" class="article-share-renren" target="_blank" title="人人"></a>',
  '<a href="http://service.weibo.com/share/share.php?title='+title+'&url='+encodedUrl +'&ralateUid='+ tsina +'&searchPic=true&style=number' +'" class="article-share-weibo" target="_blank" title="微博"></a>',
  '<span title="Share to"></span>'
  ].join('');
  $this.append(html);

  $('.article-share-qrcode').click(function(){
    var imgSrc = $('#qrcode-pic').attr('data-src');
    $('#qrcode-pic').attr('src', imgSrc);
    $('#qrcode-pic').load(function(){
        $('.qrcode strong').text(' ');
    });
  });
/*
  $('.hoverqrcode').hide();

  var myWidth = 0;
  function updatehoverqrcode(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
    var qrsize = myWidth > 1024 ? 200:100;
    var options = {render: 'image', size: qrsize, fill: '#2ca6cb', text: url, radius: 0.5, quiet: 1};
    var p = $('.article-share-qrcode').position();
    $('.hoverqrcode').empty().css('width', qrsize).css('height', qrsize)
                          .css('left', p.left-qrsize/2+20).css('top', p.top-qrsize-10)
                          .qrcode(options);
  };
  $(window).resize(function(){
    $('.hoverqrcode').hide();
  });
  $('.article-share-qrcode').click(function(){
    updatehoverqrcode();
    $('.hoverqrcode').toggle();
  });
  $('.article-share-qrcode').hover(function(){}, function(){
      //$('.hoverqrcode').hide();
  });
  */
});
</script>






<!--

-->




<link rel="stylesheet" href="/assets/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/assets/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      if ($(this).hasClass('emoji')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
});
</script>


<!-- Analytics Begin -->





<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="返回顶部"><img src="/assets/img/scrollup.png"/></a>
	</div>
	<script src="/assets/js/totop.js"></script>


<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
</html>

