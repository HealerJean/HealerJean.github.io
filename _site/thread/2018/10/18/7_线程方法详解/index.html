

 <!DOCTYPE HTML>
<html lang="zh-CN">
<head>
  <meta name="baidu-site-verification" content="0r55fUD7QR" />
  <meta charset="UTF-8">
    
    
    
    
    <title>线程方法详解 | HealeJean的梦想博客</title>


    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="HealerJean">
    

    
    <!--<%- open_graph({twitter_id: theme.author.twitter, google_plus: theme.author.google_plus}) %>-->

    <meta name="description" content="page.description">
    
    <meta property="og:type" content="article">
    
    <meta property="og:title" content="线程方法详解">
    <meta property="og:url" content="/thread/2018/10/18/7_%E7%BA%BF%E7%A8%8B%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3/">
    <meta property="og:site_name" content="HealeJean的梦想博客">
    <meta property="og:description" content="线程方法详解">
    <meta name="twitter:card" content="summary">
    <meta name="twitter:title" content="线程方法详解">
    <meta name="twitter:description" content="page.description">
    <meta name="twitter:creator" content="@mxzdhealer">
    <link rel="publisher" href="">

    
    <link rel="alternative" href="/atom.xml" title="HealeJean的梦想博客" type="application/atom+xml">
    
    
    <link rel="icon" href="/assets/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/assets/img/jacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/assets/img/jacman.jpg">
    

    <link rel="stylesheet" href="/assets/css/style.css" type="text/css">
    <link rel="stylesheet" href="/assets/css/highlight.css" type="text/css">
    
    
  <!-- 百度统计 -->
    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?19549885065170e0019f01e9975dfc1d";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>
    <!-- 百度联盟 -->
    <meta name="baidu_union_verify" content="c2f387067cf0849991ea870f73c055f2">
  
</head>

  <body>
    <header>
        <div>
		    
			<div id="imglogo">
				<a href="/"><img src="/assets/img/logo.png" alt="HealeJean的梦想博客" title="HealeJean的梦想博客"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="HealeJean的梦想博客">HealeJean的梦想博客</a></h1>
				<h2 class="blog-motto">一个高级软件开发工程师的成长之路</h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="menu">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">主页</a></li>
					
						<li><a href="/categories">技术</a></li>
					
						<li><a href="/archives">归档</a></li>
					
						<li><a href="/categories/#Job">生活日记</a></li>
					
						<li><a href="/about">个人简历</a></li>
					
						<li><a href="/friends">友情链接</a></li>
					
					<li>
 					
					<form class="search" action="/search" method="get" accept-charset="utf-8">
						<input type="search" id="search" name="q" autocomplete="off" maxlength="20" placeholder="搜索" />
					</form>
					
					</li>
				</ul>
			</nav>
</div>

    </header>
    <div id="container">
      



<div id="main" class="post" itemscope itemprop="blogPost">
  
	<article itemprop="articleBody"> 
	<header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/thread/2018/10/18/7_%E7%BA%BF%E7%A8%8B%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3/" title="线程方法详解" itemprop="url">线程方法详解</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="HealerJean" target="_blank" itemprop="author">HealerJean</a>
		
  <p class="article-time">
    <time datetime="2018-10-18 11:33:00 +0800" itemprop="datePublished"> 发表于 2018-10-18</time>
    
  </p>
</header>
	<div class="article-content">
		
		<div id="toc" class="toc-article toc-content" style="display: none;">
		
			<!--<%- toc(item.content) %>-->
		
		</div>
		
		<!-- image url 
https://raw.githubusercontent.com/HealerJean/HealerJean.github.io/master/blogImages
　　首行缩进
<font color="red">  </font>

<font  color="red" size="4">   </font>


<font size="4">   </font>
-->

<h2 id="前言">前言</h2>

<h2 id="一概念">一、概念</h2>

<h3 id="1并行和并发">1、并行和并发</h3>
<p>1、并行：多个任务同时执行 <br /></p>

<p>2、并发：多个任务交替进行，肉眼观察和并行是一样的。<br /></p>

<font color="red" size="4">   

记住：多线程就是分时利用CPU，宏观上让所有线程一起执行 ，也叫并发

</font>

<h3 id="2同步和异步">2、同步和异步</h3>

<p>1、同步：指发送一个请求,需要等待返回,然后才能够发送下一个请求，有个等待过程；<br /></p>

<p>2、异步：指发送一个请求,不需要等待返回,随时可以再发送下一个请求，即不需要等待。 <br /></p>

<p>区别：一个需要等待，一个不需要等待，在部分情况下，我们的项目开发中都会优先选择不需要等待的异步交互方式。</p>

<h3 id="3临界区">3、临界区</h3>

<p>表示一种公共的资源或者说是共享数据，可以被多个线程使用，但是每一次，只能有一个线程使用它，一旦临界区资源被占用，其他线程要是想使用这个资源，就必须等待。</p>

<h3 id="4线程的几种状态">4、线程的几种状态</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="kn">package</span> <span class="n">com</span><span class="o">.</span><span class="na">hlj</span><span class="o">.</span><span class="na">moudle</span><span class="o">.</span><span class="na">thread</span><span class="o">.</span><span class="na">dm001</span><span class="err">线程状态</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">org.junit.Test</span><span class="o">;</span>

<span class="cm">/**
 * 作者 ：HealerJean
 * 日期 ：2019/2/16  下午4:19.
 * 类描述：
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Dm01Status</span> <span class="o">{</span>

    <span class="cm">/**
     * 打印线程的集中状态
     */</span>
    <span class="nd">@Test</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">printThreadStatus</span><span class="o">(){</span>
        <span class="k">for</span><span class="o">(</span><span class="n">Thread</span><span class="o">.</span><span class="na">State</span> <span class="nl">state:</span><span class="n">Thread</span><span class="o">.</span><span class="na">State</span><span class="o">.</span><span class="na">values</span><span class="o">()){</span>
            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">state</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="cm">/** 打印结果
         NEW              //新建状态    Thread thread = new Thread()
         RUNNABLE         //可运行状态  Thread.start() ;
         BLOCKED          //阻塞状态    synchronized对象或者类锁
         WAITING          //等待状态
                                1、synchronized /调用object.wait(),,如果将它变成RUNNABLE状态调用Object.notify()
                                2、thread.join()
                                3、lock.lock
                                4、condition.await()
                                5、Thread.sleep()

         TIMED_WAITING    //有限等待状态 这个和wainting有点类似，但是这个是有时间限制的。如果超过了时间，自动变成RUNNABLE
         TERMINATED       //被终止追昂头
                                1、正常退出
                                2、 因为一个没有捕获的异常终止了run（）方法二意外死亡
     */</span>



<span class="o">}</span>


</code></pre></div></div>

<h4 id="41new-新建状态">4.1、NEW 新建状态</h4>

<p>新建状态    Thread thread = new Thread()</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
    /**
     * 1、NEW 新建状态
     */
    @Test
    public  void testNEW(){
        Thread thread = new Thread(()-&gt;{
            while (true){

            }
        });
        System.out.println(thread.getState()); //NEW
    }
   

</code></pre></div></div>

<h3 id="问题thread的run与start的区别">问题：Thread的run（）与start（）的区别</h3>

<p>1、Thread.start()方法(native)启动线程，使之进入可运行状态，当cpu分配时间该线程时，由JVM调度执行run()方法。<br /></p>

<p>2、相当于玩游戏机，只有一个游戏机（cpu），可是有很多人要玩，于是，start是排队！等CPU选中你就是轮到你，你就run（），当CPU的运行的时间片执行完，这个线程就继续排队，等待下一次的run（）。<br /></p>

<p>1.start（）方法来启动线程，真正实现了多线程运行。这时无需等待run方法体代码执行完毕，可以直接继续执行下面的代码；通过调用Thread类的start()方法来启动一个线程， 这时此线程是处于可运行状态， 并没有运行。 然后通过此Thread类调用方法run()来完成其运行操作的， 这里方法run()称为线程体，它包含了要执行的这个线程的内容， Run方法运行结束， 此线程终止。然后CPU再调度其它线程。<br /></p>

<p>2.run（）方法当作普通方法的方式调用。程序还是要顺序执行，要等待run方法体执行完毕后，才可继续执行下面的代码； 程序中只有主线程——这一个线程， 其程序执行路径还是只有一条， 这样就没有达到写线程的目的。</p>

<h4 id="42runnable-可运行状态">4.2、RUNNABLE 可运行状态</h4>

<p>Thread thread = new Thread()
 thread.start() ;</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="cm">/**
     * 2、RUNNABLE 可运行状态
     */</span>
    <span class="nd">@Test</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">testRUNNALBE</span><span class="o">(){</span>
        <span class="n">Thread</span> <span class="n">thread</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Thread</span><span class="o">(()-&gt;{</span>
            <span class="k">while</span> <span class="o">(</span><span class="kc">true</span><span class="o">){</span>

            <span class="o">}</span>
        <span class="o">});</span>
        <span class="n">thread</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">thread</span><span class="o">.</span><span class="na">getState</span><span class="o">());</span> <span class="c1">//RUNNABLE</span>
    <span class="o">}</span>


</code></pre></div></div>

<h4 id="43阻塞状态">4.3、阻塞状态</h4>

<p>阻塞状态    synchronized对象或者类锁</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="n">com</span><span class="o">.</span><span class="na">hlj</span><span class="o">.</span><span class="na">moudle</span><span class="o">.</span><span class="na">thread</span><span class="o">.</span><span class="na">dm001</span><span class="err">线程状态</span><span class="o">;</span>

<span class="cm">/**
 * 作者 ：HealerJean
 * 日期 ：2019/2/16  下午4:33.
 * 类描述：  synchronized对象或者类锁 可以造成线程阻塞状态
 */</span>


<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Dm02</span><span class="err">阻塞状态</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">TaskBlockedObject</span> <span class="n">blockedTask</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TaskBlockedObject</span><span class="o">()</span> <span class="o">;</span>

       <span class="n">Thread</span> <span class="n">thread1</span> <span class="o">=</span>  <span class="k">new</span> <span class="n">Thread</span><span class="o">(()-&gt;{</span>
           <span class="n">blockedTask</span><span class="o">.</span><span class="na">offerThread1</span><span class="o">();</span>
        <span class="o">},</span><span class="s">"线程1"</span><span class="o">);</span>


        <span class="n">Thread</span> <span class="n">thread2</span>  <span class="o">=</span>  <span class="k">new</span> <span class="n">Thread</span><span class="o">(()-&gt;{</span>
            <span class="n">blockedTask</span><span class="o">.</span><span class="na">offerThread1</span><span class="o">();</span>
        <span class="o">},</span><span class="s">"线程2"</span><span class="o">);</span>

        <span class="n">thread1</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
        <span class="n">thread2</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">thread1</span><span class="o">.</span><span class="na">getName</span><span class="o">()+</span><span class="s">":"</span><span class="o">+</span><span class="n">thread1</span><span class="o">.</span><span class="na">getState</span><span class="o">());</span> <span class="c1">// 线程1:RUNNABLE</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">thread2</span><span class="o">.</span><span class="na">getName</span><span class="o">()+</span><span class="s">":"</span><span class="o">+</span><span class="n">thread2</span><span class="o">.</span><span class="na">getState</span><span class="o">());</span> <span class="c1">// 线程2:BLOCKED</span>
    <span class="o">}</span>

<span class="o">}</span>

<span class="kd">class</span> <span class="nc">TaskBlockedObject</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">Object</span> <span class="n">object</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Object</span><span class="o">();</span>

    <span class="cm">/**
     * 提供给线程1进行调用
     */</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">offerThread1</span><span class="o">(){</span>
        <span class="kd">synchronized</span> <span class="o">(</span><span class="n">object</span><span class="o">){</span>
            <span class="k">while</span> <span class="o">(</span><span class="kc">true</span><span class="o">){</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="cm">/**
     * 提供给线程2进行调用
     */</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">offerThread2</span><span class="o">(){</span>
        <span class="kd">synchronized</span> <span class="o">(</span><span class="n">object</span><span class="o">){</span>
            <span class="k">while</span> <span class="o">(</span><span class="kc">true</span><span class="o">){</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>


</code></pre></div></div>

<h3 id="5死锁">5、死锁</h3>

<p>过多的同步会造成死锁</p>

<h4 id="死锁活锁饥饿">死锁、活锁、饥饿</h4>

<p>死锁就是，线程A占用资源，线程B也占用资源，但是都不释放
活锁，就是A和B 都占用资源，但是又同时释放，这样来来回回就是活锁
饥饿。比如高优先级的线程，一直占用线程，低优先级的一直不能得到线程</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="n">com</span><span class="o">.</span><span class="na">hlj</span><span class="o">.</span><span class="na">moudle</span><span class="o">.</span><span class="na">thread</span><span class="o">.</span><span class="na">d02</span><span class="err">死锁</span><span class="o">;</span>

<span class="cm">/**
 * 作者 ：HealerJean
 * 日期 ：2019/2/16  下午5:13.
 * 类描述：过多的同步会造成死锁
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">D01DeadLockThread</span> <span class="kd">implements</span> <span class="n">Runnable</span> <span class="o">{</span>

    <span class="cm">/**
     * 注意的的这里的final是 常亮。这样即使new两个对象，启动线程也是访问同一个资源
     线程thread1占有资源objectA，线程thread2占有资源objectB，
     当两个线程发出请求时，由于所请求的资源都在对方手中，从而发生线程阻塞，造成了线程的死锁。
     */</span>
        <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">Object</span> <span class="n">objectA</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Object</span><span class="o">();</span>
        <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">Object</span> <span class="n">objectB</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Object</span><span class="o">();</span>
        <span class="kd">private</span> <span class="kt">boolean</span> <span class="n">flag</span><span class="o">;</span>

        <span class="nd">@Override</span>
        <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
            <span class="n">String</span> <span class="n">threadName</span> <span class="o">=</span> <span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getName</span><span class="o">();</span>
            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"当前线程 为："</span> <span class="o">+</span> <span class="n">threadName</span> <span class="o">+</span> <span class="s">"\tflag = "</span> <span class="o">+</span> <span class="n">flag</span><span class="o">);</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">flag</span><span class="o">)</span> <span class="o">{</span>
                <span class="kd">synchronized</span> <span class="o">(</span><span class="n">objectA</span><span class="o">)</span> <span class="o">{</span>
                    <span class="k">try</span> <span class="o">{</span>
                        <span class="n">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">1000</span><span class="o">);</span> <span class="c1">//等待其他线程执行</span>
                    <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
                        <span class="c1">// TODO Auto-generated catch block</span>
                        <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
                    <span class="o">}</span>
                    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">threadName</span> <span class="o">+</span> <span class="s">"已进入同步代码块objectA，准备进入objectB"</span><span class="o">);</span>
                    <span class="kd">synchronized</span> <span class="o">(</span><span class="n">objectB</span><span class="o">)</span> <span class="o">{</span>
                        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">threadName</span> <span class="o">+</span> <span class="s">"已经进入同步代码块objectB"</span><span class="o">);</span>
                    <span class="o">}</span>
                <span class="o">}</span>

            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="kd">synchronized</span> <span class="o">(</span><span class="n">objectB</span><span class="o">)</span> <span class="o">{</span>
                    <span class="k">try</span> <span class="o">{</span>
                        <span class="n">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">1000</span><span class="o">);</span> <span class="c1">//等待其他线程执行</span>
                    <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
                        <span class="c1">// TODO Auto-generated catch block</span>
                        <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
                    <span class="o">}</span>
                    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">threadName</span> <span class="o">+</span> <span class="s">"已进入同步代码块objectB，准备进入objectA"</span><span class="o">);</span>
                    <span class="kd">synchronized</span> <span class="o">(</span><span class="n">objectA</span><span class="o">)</span> <span class="o">{</span>
                        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">threadName</span> <span class="o">+</span> <span class="s">"已经进入同步代码块objectA"</span><span class="o">);</span>
                    <span class="o">}</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">D01DeadLockThread</span> <span class="n">deadlock1</span> <span class="o">=</span> <span class="k">new</span> <span class="n">D01DeadLockThread</span><span class="o">();</span>
            <span class="n">D01DeadLockThread</span> <span class="n">deadlock2</span> <span class="o">=</span> <span class="k">new</span> <span class="n">D01DeadLockThread</span><span class="o">();</span>
            
            <span class="n">deadlock1</span><span class="o">.</span><span class="na">flag</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
            <span class="n">Thread</span> <span class="n">thread1</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Thread</span><span class="o">(</span><span class="n">deadlock1</span><span class="o">);</span>

            <span class="n">deadlock2</span><span class="o">.</span><span class="na">flag</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
            <span class="n">Thread</span> <span class="n">thread2</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Thread</span><span class="o">(</span><span class="n">deadlock2</span><span class="o">);</span>

            <span class="n">thread1</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
            <span class="n">thread2</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>

        <span class="o">}</span>

    <span class="o">}</span>



<span class="err">当前线程</span> <span class="err">为：</span><span class="n">Thread</span><span class="o">-</span><span class="mi">1</span>	<span class="n">flag</span> <span class="o">=</span> <span class="kc">false</span>
<span class="err">当前线程</span> <span class="err">为：</span><span class="n">Thread</span><span class="o">-</span><span class="mi">0</span>	<span class="n">flag</span> <span class="o">=</span> <span class="kc">true</span>
<span class="n">Thread</span><span class="o">-</span><span class="mi">0</span><span class="err">已进入同步代码块</span><span class="n">objectA</span><span class="err">，准备进入</span><span class="n">objectB</span>
<span class="n">Thread</span><span class="o">-</span><span class="mi">1</span><span class="err">已进入同步代码块</span><span class="n">objectB</span><span class="err">，准备进入</span><span class="n">objectA</span>


</code></pre></div></div>

<h4 id="61测试结果">6.1、测试结果</h4>

<p>发现这里的程序并没有执行，说明死锁成功了</p>

<p><img src="https://raw.githubusercontent.com/HealerJean/HealerJean.github.io/master/blogImages/WX20190216-172424.png" alt="WX20190216-172424" /></p>

<h4 id="62死锁的条件">6.2、死锁的条件</h4>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1） 互斥条件： 某种资源一次只允许一个进程访问，即该资源一旦分配给某个进程，其他进程就不能再访问，直到该进程访问结束。

2） 请求与保持条件：一个进程本身占有资源（一种或多种），同时还有资源未得到满足，正在等待其他进程释放该资源。

3） 不剥夺条件 ：别人已经占有了某项资源，你不能因为自己也需要该资源，就去把别人的资源抢过来。

4） 循环等待：一直等待自己需要的资源

</code></pre></div></div>

<h3 id="6线程优先级">6、线程优先级</h3>

<p>main的优先级，是普通的优先级<br /></p>

<p>注意不是线程中执行速度的快慢<br /></p>

<p>首先说 线程优先级，并不能保证优先级高的先运行，也不保证优先级高的更多的分配CPU时间，只是对系统的建议而已，到底运行哪个，是操作系统决定的，都不是java说了算的。<br /></p>

<p>但这些优先级需要操作系统的支持。不同操作系统上优先级并不相同</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="kn">package</span> <span class="n">com</span><span class="o">.</span><span class="na">hlj</span><span class="o">.</span><span class="na">moudle</span><span class="o">.</span><span class="na">thread</span><span class="o">.</span><span class="na">d03</span><span class="err">线程优先级</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">org.junit.Test</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.concurrent.atomic.AtomicLong</span><span class="o">;</span>

<span class="cm">/**
 * 作者 ：HealerJean
 * 日期 ：2019/2/16  下午5:47.
 *
 *  1、main的优先级，是普通的优先级
 *  2、线程优先级别thread1.setPriority
 *  3、线程优先级，并不能保证优先级高的先运行，也不保证优先级高的更多的分配CPU时间
 *    只是对系统的建议而已，到底运行哪个，是操作系统决定的，都不是java说了算的。
 *    线程的优先级仍然无法保障线程的执行次序。只不过，优先级高的线程获取CPU资源的概率较大，优先级低的并非没机会执行。
 *  4、少量的执行看不出来效果只有数量特别多的时候才会有效果
 *
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">D01Priority</span> <span class="o">{</span>



    <span class="nd">@Test</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">testPriority</span><span class="o">()</span> <span class="o">{</span>

        <span class="n">Thread</span> <span class="n">thread1</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Thread</span><span class="o">(()-&gt;{</span>
                <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"正常优先级 counter1:"</span><span class="o">);</span>
        <span class="o">},</span><span class="s">"线程1"</span><span class="o">);</span>

        <span class="n">Thread</span> <span class="n">thread2</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Thread</span><span class="o">(()-&gt;{</span>
                <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"最高优先级 counter2:"</span><span class="o">);</span>
        <span class="o">},</span><span class="s">"线程2"</span><span class="o">);</span>

        <span class="n">Thread</span> <span class="n">thread3</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Thread</span><span class="o">(()-&gt;{</span>
                <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"最低优先级 counter3:"</span><span class="o">);</span>
        <span class="o">},</span><span class="s">"线程3"</span><span class="o">);</span>

        <span class="n">thread1</span><span class="o">.</span><span class="na">setPriority</span><span class="o">(</span><span class="n">Thread</span><span class="o">.</span><span class="na">NORM_PRIORITY</span><span class="o">);</span> <span class="c1">//线程1  正常优先级</span>
        <span class="n">thread2</span><span class="o">.</span><span class="na">setPriority</span><span class="o">(</span><span class="n">Thread</span><span class="o">.</span><span class="na">MAX_PRIORITY</span><span class="o">);</span>  <span class="c1">//线程2  最高优先级</span>
        <span class="n">thread3</span><span class="o">.</span><span class="na">setPriority</span><span class="o">(</span><span class="n">Thread</span><span class="o">.</span><span class="na">MIN_PRIORITY</span> <span class="o">);</span> <span class="c1">//线程3  最低优先级</span>

        <span class="n">thread1</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
        <span class="n">thread2</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
        <span class="n">thread3</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>


    <span class="o">}</span>


<span class="o">}</span>


</code></pre></div></div>

<h2 id="二线程方法">二、线程方法</h2>

<h2 id="1谦让-threadyield">1、谦让 <code class="highlighter-rouge">Thread.yield()</code></h2>

<p>Java线程中有一个Thread.yield( )方法，把自己CPU执行的时间让掉，让自己或者其它的线程运行。（也就是谁先抢到谁执行,<font color="red" size="4">  记得：相当于原来的线程从来没有执行过哦） </font><br /></p>

<p>相当于是将run()运行状态转变为start()状态<br /></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="n">com</span><span class="o">.</span><span class="na">hlj</span><span class="o">.</span><span class="na">moudle</span><span class="o">.</span><span class="na">thread</span><span class="o">.</span><span class="na">d04yield</span><span class="err">谦让</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">org.junit.Test</span><span class="o">;</span>

<span class="cm">/**
 * 作者 ：HealerJean
 * 日期 ：2019/2/16  下午6:14.
 * 类描述：

    Java线程中有一个Thread.yield()方法，把自己CPU执行的时间让掉，让自己或者其它的线程运行。（也就是谁先抢到谁执行）

 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">D01Yield</span> <span class="o">{</span>

    <span class="nd">@Test</span>
    <span class="kd">public</span>  <span class="kt">void</span> <span class="nf">testYield</span><span class="o">(){</span>
        <span class="n">Thread</span> <span class="n">thread1</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Thread</span><span class="o">(()-&gt;{</span>
            <span class="n">task</span><span class="o">();</span>
        <span class="o">},</span><span class="s">"线程1"</span><span class="o">);</span>

        <span class="n">Thread</span> <span class="n">thread2</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Thread</span><span class="o">(()-&gt;{</span>
            <span class="n">task</span><span class="o">();</span>
        <span class="o">},</span><span class="s">"线程2"</span><span class="o">);</span>

        <span class="n">thread1</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
        <span class="n">thread2</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>

    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">task</span><span class="o">(){</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="mi">50</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// 当i为30时，该线程就会把CPU时间让掉，让其他或者自己的线程执行（也就是谁先抢到谁执行）</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">30</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">yield</span><span class="o">();</span>
                <span class="c1">//下面的将不会打印，相当于把当前线程让掉了</span>
                <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">""</span> <span class="o">+</span> <span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getName</span><span class="o">()</span> <span class="o">+</span> <span class="s">"-----"</span> <span class="o">+</span> <span class="n">i</span><span class="o">);</span>
            <span class="o">}</span><span class="k">else</span> <span class="o">{</span>
                <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">""</span> <span class="o">+</span> <span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getName</span><span class="o">()</span> <span class="o">+</span> <span class="s">"-----"</span> <span class="o">+</span> <span class="n">i</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>


</code></pre></div></div>

<h2 id="2终止线程-stop-弃用了">2、终止线程 stop （弃用了）</h2>

<p>一般来说，线程执行完毕会自动结束，无需手动关闭<br /></p>

<p>线程提供给了一个Stop方法，可以即使终止一个线程，但是会发现stop已经被弃用了。Thread.stop()方法在结束线程的时候，会直接终止线程，这个线程就会立即释放掉所有的锁，而这些锁恰恰是用来维护对象的一致性的，如果此时写到了一半，强行中止，那么对象就会被破坏，或者线程可能在操作数据库，强⾏中断导致数据不一致，从而混乱的问题。所以现在不使用了</p>

<h4 id="21真正结束">2。1、真正结束</h4>

<p>中止线程的正确方法为，添加一个标记变量，用于提示线程是否需要退出</p>

<h2 id="3线程中断threadinterrupt">3、线程中断<code class="highlighter-rouge">thread.interrupt</code></h2>

<p>严格 讲，线程中断不会使线程立即退出，而是给线程发送一个通知（而使用Threasd.sleep() 抛出了异常，然后中断状态被清空），告诉目标线程，有人希望你退出， 后续目前线程接到通知怎么处理，是线程自己的事情了</p>

<blockquote>
  <p>1、中断异常的抛出：如果此线程处于阻塞状态(比如调⽤了wait方法，io等待)，则会立刻退出阻塞，并抛出InterruptedException异常（中断标志位已经被清空了），线程就可以通过捕获InterruptedException来做⼀定的处理，然后让线程退出。</p>
</blockquote>

<blockquote>
  <p>2、中断标记状态的判断： 如果此线程正处于运行之中，则线程不受任何影响，继续运行，仅仅是线程的中断标记被设置为true。所以线程要在适当的位置通过调用isInterrupted方法来查看自⼰是否被中断，并做退出操作。</p>
</blockquote>

<h3 id="31简单测试">3.1、简单测试</h3>

<p>像下面这种需要捕获中断异常的，中断标志位已经被清空了，也就是说在catch中捕获的 查看状态为false</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>

<span class="kn">package</span> <span class="n">com</span><span class="o">.</span><span class="na">hlj</span><span class="o">.</span><span class="na">moudle</span><span class="o">.</span><span class="na">thread</span><span class="o">.</span><span class="na">d06Interupt</span><span class="err">线程中断</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">org.junit.Test</span><span class="o">;</span>

<span class="cm">/**
 * 作者 ：HealerJean
 * 日期 ：2019/2/16  下午6:49.

 严格 讲，线程中断不会使线程立即退出，而是给线程发送一个通知（抛出了异常），告诉目标线程，有人希望你退出，
         后续目前线程接到通知怎么处理，是线程自己的事情了
 
    像下面这种需要捕获中断异常的，中断标志位以及被清空了了，也就是说在catch中捕获的 查看状态为false

 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">D01</span><span class="err">简单测试</span> <span class="o">{</span>

    <span class="nd">@Test</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="n">test</span><span class="err">简单测试</span><span class="o">(){</span>

        <span class="n">Thread</span> <span class="n">thread</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Thread</span><span class="o">(()-&gt;{</span>

            <span class="k">try</span> <span class="o">{</span>
                <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"1、线程开始执行"</span><span class="o">);</span>
                <span class="n">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">5000</span><span class="o">);</span>
                <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"2、线程结束休眠"</span><span class="o">);</span>
            <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"3、线程中断休眠"</span><span class="o">);</span>
                <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getState</span><span class="o">()</span> <span class="o">+</span> <span class="s">"中断状态"</span> <span class="o">+</span> <span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">isInterrupted</span><span class="o">());</span>
                <span class="k">return</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"4、线程正在运行"</span><span class="o">);</span>

        <span class="o">});</span>

        <span class="n">thread</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="n">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">1000</span><span class="o">);</span><span class="c1">//准备进行中断，让上面的线程确保已经执行</span>
            <span class="n">thread</span><span class="o">.</span><span class="na">interrupt</span><span class="o">();</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>

<span class="o">}</span>


<span class="mi">1</span><span class="err">、线程开始执行</span>
<span class="mi">3</span><span class="err">、线程中断休眠</span>
<span class="n">RUNNABLE</span><span class="err">中断状态</span><span class="kc">false</span>


</code></pre></div></div>

<h3 id="32new和terminated-下中断线程毫无意义返回中断状态为false">3.2、new和terminated 下中断线程毫无意义，返回中断状态为false</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="n">com</span><span class="o">.</span><span class="na">hlj</span><span class="o">.</span><span class="na">moudle</span><span class="o">.</span><span class="na">thread</span><span class="o">.</span><span class="na">d06Interupt</span><span class="err">线程中断</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">org.junit.Test</span><span class="o">;</span>

<span class="cm">/**
 * 作者 ：HealerJean
 * 日期 ：2019/2/17  下午3:42.
 * 类描述： 测试中断状态
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">D02New</span><span class="err">中断</span> <span class="o">{</span>


    <span class="cm">/**
     * 线程的new状态表示还未调用start方法，还未真正启动。线程的terminated状态表示线程已经运行终止。
     * 这两个状态下调用中断方法来中断线程的时候，Java认为毫无意义，
     * 所以并不会设置线程的中断标识位，什么事也不会发生。
     *
     * 返回中断状态为false
     */</span>
    <span class="nd">@Test</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="err">测试</span><span class="n">new</span><span class="err">中断</span><span class="o">(){</span>

        <span class="n">Thread</span> <span class="n">thread</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Thread</span><span class="o">(()-&gt;{</span>

        <span class="o">});</span>

        <span class="c1">//new新建状态 返回 false</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"线程状态:"</span><span class="o">+</span><span class="n">thread</span><span class="o">.</span><span class="na">getState</span><span class="o">()+</span><span class="s">"-中断状态"</span><span class="o">+</span><span class="n">thread</span><span class="o">.</span><span class="na">isInterrupted</span><span class="o">());</span>

        <span class="c1">//此时线程还没启动 就进行中断，其实毫无意义</span>
        <span class="n">thread</span><span class="o">.</span><span class="na">interrupt</span><span class="o">();</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"中断状态"</span><span class="o">+</span><span class="n">thread</span><span class="o">.</span><span class="na">isInterrupted</span><span class="o">());</span>

        <span class="c1">//启动线程</span>
        <span class="n">thread</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>

        <span class="k">try</span> <span class="o">{</span>
            <span class="n">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">3000</span><span class="o">);</span><span class="c1">//确保线程已经执行完毕</span>
            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"线程状态:"</span><span class="o">+</span><span class="n">thread</span><span class="o">.</span><span class="na">getState</span><span class="o">()+</span><span class="s">"-中断状态"</span><span class="o">+</span><span class="n">thread</span><span class="o">.</span><span class="na">isInterrupted</span><span class="o">());</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
        <span class="o">}</span>

        <span class="cm">/** 打印结果

         线程状态:NEW-中断状态false
         中断状态false
         线程状态:TERMINATED-中断状态false

         */</span>


    <span class="o">}</span>

<span class="o">}</span>

</code></pre></div></div>

<h3 id="33runnable状态下中断">3.3、RUNNABLE状态下中断</h3>

<font color="red" size="4">  

处于RUNNABLE状态的线程在遭遇中断操作的时候只会设置该线程的中断标志位，并不会让线程实际中断，而是会继续执行，不受影响
 </font>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="kn">package</span> <span class="n">com</span><span class="o">.</span><span class="na">hlj</span><span class="o">.</span><span class="na">moudle</span><span class="o">.</span><span class="na">thread</span><span class="o">.</span><span class="na">d06Interupt</span><span class="err">线程中断</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">org.junit.Test</span><span class="o">;</span>

<span class="cm">/**
 * 作者 ：HealerJean
 * 日期 ：2019/2/17  下午3:53.
 * 类描述：
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">D03RUNNABLE</span><span class="err">中断</span> <span class="o">{</span>

    <span class="nd">@Test</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="n">testRUNNABLE</span><span class="err">中断测试</span><span class="o">(){</span>

        <span class="n">Thread</span> <span class="n">thread</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Thread</span><span class="o">(()-&gt;{</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">100</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
                <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="n">i</span><span class="o">+</span><span class="s">""</span><span class="o">+</span><span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">isInterrupted</span><span class="o">()+</span><span class="s">"___"</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">});</span>

        <span class="n">thread</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="n">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span> <span class="c1">//确保上面的线程在执行过程中进行中断</span>
            <span class="n">thread</span><span class="o">.</span><span class="na">interrupt</span><span class="o">();</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
        <span class="o">}</span>

        <span class="cm">/**
         * 打印结果
         0false___1false___2false___3false___4false___5false___6false___7false___8false___9false___10false___11false___12false___13false___14false___15false___16false___17false___18false___19false___20false___21false___22false___23false___24false___25false___26false___27false___28false___29false___30false___31false___32false___33false___34false___35false___36false___37false___38false___39false___40false___41false___42false___43false___44false___45false___46false___47false___48false___49false___50false___51false___52false___53false___54false___55false___56false___57false___58false___59false___60false___61false___62false___63false___64false___65false___66false___67false___68false___69false___70false___71false___72false___73false___74false___75false___76true___77true___78true___79true___80true___81true___82true___83true___84true___85true___86true___87true___88true___89true___90true___91true___92true___93true___94true___95true___96true___97true___98true___99true___         */</span>

    <span class="o">}</span>

<span class="o">}</span>



</code></pre></div></div>

<h4 id="332合适的场景结束中断">3.3.2、合适的场景结束中断</h4>

<p>程序让我们已经执行的线程进行中断，它又不是赶着去投胎，我们在合适场景下if判断中断标志位是否被设置，结束任务执行不就完事了</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>

<span class="kn">package</span> <span class="n">com</span><span class="o">.</span><span class="na">hlj</span><span class="o">.</span><span class="na">moudle</span><span class="o">.</span><span class="na">thread</span><span class="o">.</span><span class="na">d06Interupt</span><span class="err">线程中断</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">org.junit.Test</span><span class="o">;</span>

<span class="cm">/**
 * 作者 ：HealerJean
 * 日期 ：2019/2/17  下午3:53.
 * 类描述：
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">D03RUNNABLE</span><span class="err">中断</span> <span class="o">{</span>

    <span class="nd">@Test</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="n">testRUNNABLE</span><span class="err">中断测试</span><span class="o">(){</span>

        <span class="n">Thread</span> <span class="n">thread</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Thread</span><span class="o">(()-&gt;{</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">100</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
                <span class="k">if</span><span class="o">(</span><span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">isInterrupted</span><span class="o">()){</span>
                    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"\n程序已经被中断了，结束程序运行"</span><span class="o">);</span>
                    <span class="k">return</span><span class="o">;</span>
                <span class="o">}</span>
                <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="n">i</span><span class="o">+</span><span class="s">""</span><span class="o">+</span><span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">isInterrupted</span><span class="o">()+</span><span class="s">"___"</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">});</span>

        <span class="n">thread</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="n">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span> <span class="c1">//确保上面的线程在执行过程中进行中断</span>
            <span class="n">thread</span><span class="o">.</span><span class="na">interrupt</span><span class="o">();</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
        <span class="o">}</span>

        <span class="cm">/**
        

       
0false___1false___2false___3false___4false___5false___6false___7false___8false___9false___10false___11false___12false___13false___14false___15false___16false___17false___18false___19false___20false___21false___22false___23false___24false___25false___26false___27false___28false___29false___30false___31false___32false___33false___34false___35false___36false___37false___38false___39false___40false___41false___42false___43false___44false___45false___46false___47false___48false___49false___50false___51false___52false___53false___54false___55false___56false___57false___58false___59false___60false___61false___62false___63false___64false___65false___
程序已经被中断了，结束程序运行
        
        */</span>

    <span class="o">}</span>

<span class="o">}</span>

</code></pre></div></div>

<h3 id="34blocked中断">3.4、BLOCKED中断</h3>

<p>阻塞状态下中断线程，并不会结束阻塞线程的运行，运行状态下的场景是一样的，需要我们对阻塞线程的状态进行判断，然后去修改让它结束运行</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="kn">package</span> <span class="n">com</span><span class="o">.</span><span class="na">hlj</span><span class="o">.</span><span class="na">moudle</span><span class="o">.</span><span class="na">thread</span><span class="o">.</span><span class="na">d06Interupt</span><span class="err">线程中断</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">org.junit.Test</span><span class="o">;</span>

<span class="cm">/**
 * 作者 ：HealerJean
 * 日期 ：2019/2/17  下午4:17.
 * 类描述： 阻塞状态下中断线程，并不会结束阻塞线程的运行，
 * 其实和运行状态下的场景是一样的，需要我们对阻塞线程的状态进行判断，然后去修改让它结束运行
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">D03BLOCKED</span><span class="err">中断</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span>   <span class="kd">synchronized</span> <span class="kt">void</span>  <span class="nf">task</span><span class="o">(){</span>
        <span class="k">while</span> <span class="o">(</span><span class="kc">true</span><span class="o">){</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="nd">@Test</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="n">BLOCKED</span><span class="err">中断</span><span class="o">(){</span>

        <span class="n">Thread</span> <span class="n">thread1</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Thread</span><span class="o">(()-&gt;{</span>

            <span class="n">task</span><span class="o">();</span>
        <span class="o">});</span>

        <span class="n">Thread</span> <span class="n">thread2</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Thread</span><span class="o">(()-&gt;{</span>
            <span class="n">task</span><span class="o">();</span>
        <span class="o">});</span>


        <span class="n">thread1</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="n">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">1000</span><span class="o">);</span> <span class="c1">//确保线程1已经启动</span>
            <span class="n">thread2</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>

        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
        <span class="o">}</span>

        <span class="k">try</span> <span class="o">{</span>
            <span class="n">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">1000</span><span class="o">);</span> <span class="c1">//确保上面的两个线程已经执行</span>
            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"线程1状态"</span><span class="o">+</span><span class="n">thread1</span><span class="o">.</span><span class="na">getState</span><span class="o">()+</span><span class="s">"————————————"</span><span class="o">);</span>
            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"线程2状态"</span><span class="o">+</span><span class="n">thread2</span><span class="o">.</span><span class="na">getState</span><span class="o">()+</span><span class="s">"————————————"</span><span class="o">);</span>

            <span class="n">thread2</span><span class="o">.</span><span class="na">interrupt</span><span class="o">();</span>
            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"线程1状态"</span><span class="o">+</span><span class="n">thread1</span><span class="o">.</span><span class="na">getState</span><span class="o">()+</span><span class="s">"————————————"</span><span class="o">+</span><span class="n">thread1</span><span class="o">.</span><span class="na">isInterrupted</span><span class="o">());</span>
            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"线程2状态"</span><span class="o">+</span><span class="n">thread2</span><span class="o">.</span><span class="na">getState</span><span class="o">()+</span><span class="s">"————————————"</span><span class="o">+</span><span class="n">thread2</span><span class="o">.</span><span class="na">isInterrupted</span><span class="o">());</span>

        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
        <span class="o">}</span>


        <span class="cm">/**
         * 线程1状态RUNNABLE————————————
         * 线程2状态BLOCKED————————————
         * 线程1状态RUNNABLE————————————false
         * 线程2状态BLOCKED————————————true
         *
         *
         */</span>



    <span class="o">}</span>


<span class="o">}</span>



</code></pre></div></div>

<h3 id="35waitingtimed_waiting">3.5、WAITING/TIMED_WAITING</h3>

<p>这两种状态本质上是同一种状态，只不过TIMED_WAITING在等待一段时间后会自动释放自己，而WAITING则是无限期等待，需要其他线程调用notify方法释放自己。但是他们都是线程在运行的过程中由于缺少某些条件而被挂起在某个对象的等待队列上。<font color="red" size="4">当这些线程遇到中断操作的时候，会抛出一个InterruptedException异常（只有主动抛出的时候，别忘记了，造成WAITING的情况有很多种哦），</font></p>

<p>并清空中断标志位  ,也就是说在当前线程中查看中断状态为flase，而不是像上面的Runnalbe中是false了，因为它捕获了异常，当然可以继续执行线程任务啦，所以才false，和Thread.sleep清空中断标志位是一样的，都需要抛出异常</p>

<p>&lt;/font&gt;</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>

<span class="kn">package</span> <span class="n">com</span><span class="o">.</span><span class="na">hlj</span><span class="o">.</span><span class="na">moudle</span><span class="o">.</span><span class="na">thread</span><span class="o">.</span><span class="na">d06Interupt</span><span class="err">线程中断</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">org.junit.Test</span><span class="o">;</span>

<span class="cm">/**
 * 作者 ：HealerJean
 * 日期 ：2019/2/17  下午4:28.
 *
 这两种状态本质上是同一种状态，只不过TIMED_WAITING在等待一段时间后会自动释放自己，
 而WAITING则是无限期等待，需要其他线程调用notify方法释放自己。

 但是他们都是线程在运行的过程中由于缺少某些条件而被挂起在某个对象的等待队列上。
 当这些线程遇到中断操作的时候，会抛出一个InterruptedException异常，并清空中断标志位。例如：

 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">D05WAIT</span><span class="err">中断</span> <span class="o">{</span>

    <span class="nd">@Test</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="n">BLOCKED</span><span class="err">中断</span><span class="o">()</span> <span class="o">{</span>

        <span class="n">Thread</span> <span class="n">thread</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Thread</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="o">{</span>
            <span class="k">try</span> <span class="o">{</span>
                <span class="kd">synchronized</span> <span class="o">(</span><span class="k">this</span><span class="o">){</span>
                    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getState</span><span class="o">()</span> <span class="o">+</span> <span class="s">"中断状态"</span> <span class="o">+</span> <span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">isInterrupted</span><span class="o">());</span>
                    <span class="n">wait</span><span class="o">();</span>
                    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"wait"</span><span class="o">);</span>
                <span class="o">}</span>
            <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getState</span><span class="o">()</span> <span class="o">+</span> <span class="s">"中断状态"</span> <span class="o">+</span> <span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">isInterrupted</span><span class="o">());</span>
            <span class="o">}</span>
        <span class="o">});</span>

        <span class="n">thread</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="n">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">1000</span><span class="o">);</span> <span class="c1">//确保线程1已经启动</span>
            <span class="n">thread</span><span class="o">.</span><span class="na">interrupt</span><span class="o">();</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
        <span class="o">}</span>


        <span class="cm">/**

         RUNNABLE中断状态false
         RUNNABLE中断状态false
         
         */</span>


    <span class="o">}</span>
<span class="o">}</span>



</code></pre></div></div>

<h3 id="36总结">3.6、总结:</h3>

<h4 id="new和terminated对于中断操作几乎是屏蔽的毫无意义">NEW和TERMINATED对于中断操作几乎是屏蔽的,毫无意义</h4>

<h4 id="runnable和blocked类似对于中断操作只是设置中断标志位并没有强制终止线程对于线程的终止权利依然在程序手中">RUNNABLE和BLOCKED类似，对于中断操作只是设置中断标志位并没有强制终止线程，对于线程的终止权利依然在程序手中</h4>

<h4 id="waitingtimed_waiting状态下的线程对于中断操作是敏感的他们会抛出异常并清空中断标志位">WAITING/TIMED_WAITING状态下的线程对于中断操作是敏感的，他们会抛出异常并清空中断标志位。</h4>

<h2 id="4join-等待线程执行结束">4、join 等待线程执行结束</h2>

<p>很多时候，一个线程的输入，非常依赖别的线程的输出，此时，需要等待线程执行完毕，才能继续执行，所以出现了join方法，有两个join方法</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="kd">public</span> <span class="kd">final</span> <span class="kt">void</span> <span class="nf">join</span><span class="o">()</span> <span class="kd">throws</span> <span class="n">InterruptedException</span> 

<span class="kd">public</span> <span class="kd">final</span> <span class="kd">synchronized</span> <span class="kt">void</span> <span class="nf">join</span><span class="o">(</span><span class="kt">long</span> <span class="n">millis</span><span class="o">)</span>

</code></pre></div></div>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="kn">package</span> <span class="n">com</span><span class="o">.</span><span class="na">hlj</span><span class="o">.</span><span class="na">moudle</span><span class="o">.</span><span class="na">thread</span><span class="o">.</span><span class="na">d07Join</span><span class="err">等待程序执行结束</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">org.junit.Test</span><span class="o">;</span>

<span class="cm">/**
 * 作者 ：HealerJean
 * 日期 ：2019/2/17  下午4:51.

    主线程，等待异步线程执行结束
    Join等待线程执行结束
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">D01Join</span> <span class="o">{</span>



    <span class="nd">@Test</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">testJoin</span><span class="o">(){</span>

        <span class="n">Thread</span> <span class="n">thread</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Thread</span><span class="o">(()-&gt;{</span>

            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span> <span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
                <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="n">i</span><span class="o">+</span><span class="s">"_"</span><span class="o">);</span>
            <span class="o">}</span>
            
        <span class="o">});</span>

        <span class="n">thread</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>

        <span class="k">try</span> <span class="o">{</span>
            <span class="n">thread</span><span class="o">.</span><span class="na">join</span><span class="o">();</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
        <span class="o">}</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"\n主程序结束运行"</span><span class="o">);</span>


        <span class="cm">/**
         * 
         0_1_2_3_4_5_6_7_8_9_
         主程序结束运行


         */</span>
    <span class="o">}</span>


<span class="o">}</span>


</code></pre></div></div>

<h2 id="5守护进程daemon">5、守护进程<code class="highlighter-rouge">Daemon</code></h2>

<p>守护线程，是在后台默默的完成一些系统的服务，比如垃圾回收线程，与之相对于的就是用户线程，用户线程可以认为是系统的工作线程，如果用户线程全部结束，也就意味着，这个应用程序无事可做了，那么守护线程要守护的对象也就不存在了，整个应用程序也就结束了，必须在start之前设置  thread.setDaemon(true);否则会跑出一个IllegalThreadStateException异常。你不能把正在运行的常规线程设置为守护线程</p>

<h3 id="51注意事项">5.1、注意事项</h3>

<font color="red" size="4"> 

不要认为所有的应用都可以分配给Daemon来进行服务，比如读写操作或者计算逻辑。因为不可能知道在所有的User完成之前，Daemon是否已经完成了预期的服务任务。一旦User退出了，可能大量数据还没有来得及读入或写出，计算任务也可能多次运行结果不一样。这对程序是毁灭性的。造成这个结果理由已经说过了：一旦所有User Thread离开了，虚拟机也就退出运行了。

</font>

<p>主线程结束了，daemon结束并不是会马上结束，毕竟人家还需要一点点时间嘛，是不是</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="kn">package</span> <span class="n">com</span><span class="o">.</span><span class="na">hlj</span><span class="o">.</span><span class="na">moudle</span><span class="o">.</span><span class="na">thread</span><span class="o">.</span><span class="na">d08Daemon</span><span class="err">守护线程</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">org.junit.Test</span><span class="o">;</span>

<span class="cm">/**
 * 作者 ：HealerJean
 * 日期 ：2019/2/17  下午5:00.
 * 类描述：

 守护线程，是在后台默默的完成一些系统的服务，比如垃圾回收线程，与之相对于的就是用户线程，
 用户线程可以认为是系统的工作线程，如果用户线程全部结束，也就意味着，这个应用程序无事可做了，
 那么守护线程要守护的对象也就不存在了，整个应用程序也就结束了，必须在start之前设置  thread.setDaemon(true);否则会跑出一个IllegalThreadStateException异常。你不能把正在运行的常规线程设置为守护线程。
 注意事项 ：

(2) 不要认为所有的应用都可以分配给Daemon来进行服务，比如读写操作或者计算逻辑。因为不可能知道在所有的User完成之前，Daemon是否已经完成了预期的服务任务。一旦User退出了，可能大量数据还没有来得及读入或写出，计算任务也可能多次运行结果不一样。这对程序是毁灭性的。造成这个结果理由已经说过了：一旦所有User Thread离开了，虚拟机也就退出运行了。


 *
 *
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">D01Daemon</span> <span class="o">{</span>

        <span class="nd">@Test</span>
        <span class="kd">public</span> <span class="kt">void</span> <span class="nf">testJoin</span><span class="o">(){</span>

            <span class="n">Thread</span> <span class="n">thread</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Thread</span><span class="o">(()-&gt;{</span>
                <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">;</span>
                <span class="k">while</span> <span class="o">(</span><span class="kc">true</span><span class="o">){</span>
                    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">printf</span><span class="o">(</span><span class="s">"_"</span><span class="o">+(</span><span class="n">i</span><span class="o">++));</span>
                <span class="o">}</span>

            <span class="o">});</span>


            <span class="n">thread</span><span class="o">.</span><span class="na">setDaemon</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span><span class="c1">//进程守护，主线程执行完毕，它就结束运行吧</span>
            <span class="n">thread</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>

            <span class="k">try</span> <span class="o">{</span>
                <span class="n">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>
            <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
            <span class="o">}</span>
            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"\n主程序结束运行"</span><span class="o">);</span>


            <span class="cm">/**

             _1_2_3_4_5_6_7_8_9_10_11_12_13_14_15_16_17_18_19_20_21_22_23
             主程序结束运行
             _24_25_26_27_28_29_30_31_32_33_34_35_36_37_38_39_40_41_42_43_44_45_46_47_48_49_50_51_52_53
             Process finished with exit code 0
             _54_55_56_57_58_59_60_61_62_63_64_65_66_67_68_69_70_71_72_73_74_75_76_77_78_79_80_81_82_83_84_85

             */</span>
        <span class="o">}</span>


<span class="o">}</span>

</code></pre></div></div>

<h2 id="6wait-notify-notifyall">6、wait ，notify notifyAll</h2>

<h3 id="61详细介绍">6.1、详细介绍</h3>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1）wait()、notify()和notifyAll()方法是本地方法，并且为final方法，无法被重写。

2）等待和唤醒必须是同一个锁，调用某个对象的wait()方法能让当前线程阻塞，并且当前线程必须拥有此对象的monitor（即锁），调用某个对象的notify()方法，当前线程也必须拥有这个对象的monitor，因此调用notify()方法必须在同步块或者同步方法中进行（synchronized块或者synchronized方法）。

3）调用某个对象的notify()方法能够唤醒一个正在等待这个对象的monitor的线程，如果有多个线程都在等待这个对象的monitor，则只能唤醒其中一个线程；具体唤醒哪个线程则不得而知。

4）调用notifyAll()方法能够唤醒所有正在等待这个对象的monitor的线程；


</code></pre></div></div>

<font color="red" size="4"> 


 一个线程被唤醒不代表立即获取了对象的monitor，只有等调用完notify()或者notifyAll()并退出synchronized块，释放对象锁后，其余线程才可获得锁执行wait后面的剩余代码，不是从头开始哦。

</font>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code> 
 <span class="mi">1</span><span class="err">）</span><span class="n">wait</span><span class="o">()</span><span class="err">、</span><span class="n">notify</span><span class="o">()</span><span class="err">和</span><span class="n">notifyAll</span><span class="o">()</span><span class="err">方法是本地方法，并且为</span><span class="n">final</span><span class="err">方法，无法被重写。</span>

 <span class="mi">2</span><span class="err">）调用某个对象的</span><span class="n">wait</span><span class="o">()</span><span class="err">方法能让当前线程阻塞，并且当前线程必须拥有此对象的</span><span class="n">monitor</span><span class="err">（即锁），调用某个对象的</span><span class="n">notify</span><span class="o">()</span><span class="err">方法，当前线程也必须拥有这个对象的</span><span class="n">monitor</span><span class="err">，因此调用</span><span class="n">notify</span><span class="o">()</span><span class="err">方法必须在同步块或者同步方法中进行（</span><span class="n">synchronized</span><span class="err">块或者</span><span class="n">synchronized</span><span class="err">方法）。</span>

 <span class="mi">3</span><span class="err">）调用某个对象的</span><span class="n">notify</span><span class="o">()</span><span class="err">方法能够唤醒一个正在等待这个对象的</span><span class="n">monitor</span><span class="err">的线程，如果有多个线程都在等待这个对象的</span><span class="n">monitor</span><span class="err">，则只能唤醒其中一个线程；具体唤醒哪个线程则不得而知。</span>

 <span class="mi">4</span><span class="err">）调用</span><span class="n">notifyAll</span><span class="o">()</span><span class="err">方法能够唤醒所有正在等待这个对象的</span><span class="n">monitor</span><span class="err">的线程；</span>

 <span class="err">一个线程被唤醒不代表立即获取了对象的</span><span class="n">monitor</span><span class="err">，只有等调用完</span><span class="n">notify</span><span class="o">()</span><span class="err">或者</span><span class="n">notifyAll</span><span class="o">()</span><span class="err">并退出</span><span class="n">synchronized</span><span class="err">块，释放对象锁后，其余线程才可获得锁执行剩余代码，不是从头开始哦。</span>

 <span class="o">*/</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">D01WatitNotify</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">final</span>  <span class="kd">static</span> <span class="n">Object</span> <span class="n">object</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Object</span><span class="o">()</span> <span class="o">;</span>

    <span class="nd">@Test</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">testWati</span><span class="o">(){</span>

        <span class="n">Thread</span> <span class="n">thread</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Thread</span><span class="o">(()-&gt;{</span>
            <span class="k">try</span> <span class="o">{</span>
                <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"线程1"</span><span class="o">);</span>
                <span class="kd">synchronized</span> <span class="o">(</span><span class="n">object</span><span class="o">){</span>
                    <span class="n">object</span><span class="o">.</span><span class="na">wait</span><span class="o">(</span><span class="mi">1000</span><span class="o">);</span>
                    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"wait"</span><span class="o">);</span>
                <span class="o">}</span>
            <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
            <span class="o">}</span>
        <span class="o">});</span>


        <span class="n">Thread</span> <span class="n">thread2</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Thread</span><span class="o">(()-&gt;{</span>
            <span class="kd">synchronized</span> <span class="o">(</span><span class="n">object</span><span class="o">){</span>
                <span class="n">object</span><span class="o">.</span><span class="na">notify</span><span class="o">();</span> <span class="c1">//唤醒持有该对象的其他线程,执行完本同步代码块才会执行线程1</span>
                <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"notify"</span><span class="o">);</span>
            <span class="o">}</span>

            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"线程2释放了锁"</span><span class="o">);</span>

        <span class="o">});</span>

        <span class="n">thread</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
        <span class="n">thread2</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>

        <span class="k">try</span> <span class="o">{</span>
            <span class="n">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">10000</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
        <span class="o">}</span>

        <span class="cm">/**

         notify
         线程2释放了锁 //不排除第第三行输出
         wait

         */</span>
    <span class="o">}</span>

<span class="o">}</span>



<span class="err">线程</span><span class="mi">1</span>
<span class="n">notify</span>
<span class="err">线程</span><span class="mi">2</span><span class="err">释放了锁</span>
<span class="n">wait</span>


</code></pre></div></div>

<h3 id="62thread和wait区别">6.2、Thread和wait区别</h3>

<h4 id="1这两个方法来自不同的类分别是thread和object">1、这两个方法来自不同的类分别是Thread和Object</h4>

<h4 id="2sleep方法没有释放锁而wait方法释放了锁使得其他线程可以使用同步控制块或者方法">2、sleep方法没有释放锁，而wait方法释放了锁，使得其他线程可以使用同步控制块或者方法</h4>

<p>如果线程拥有某个或某些对象的同步锁，那么在调用了wait()后，这个线程就会释放它持有的所有同步资源，而不限于这个被调用了wait()方法的对象。wait()方法也同样会在wait的过程中有可能被其他对象调用interrupt()方法中断</p>

<h4 id="3waitnotify和notifyall只能在同步控制方法或者同步控制块里面使用而sleep可以在-任何地方使用使用范围">3、wait，notify和notifyAll只能在同步控制方法或者同步控制块里面使用，而sleep可以在 任何地方使用（使用范围）</h4>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="n">object</span><span class="o">.</span><span class="na">wait</span><span class="o">.</span> <span class="err">让其他的线程先执行</span>
<span class="n">object</span><span class="o">.</span><span class="na">notify</span> <span class="err">唤醒这个线程</span>

<span class="kd">synchronized</span><span class="o">(</span><span class="n">x</span><span class="o">){</span>
<span class="err">　　</span><span class="n">x</span><span class="o">.</span><span class="na">notify</span><span class="o">()</span>
<span class="err">　　</span><span class="c1">//或者wait()</span>
<span class="o">}</span>
</code></pre></div></div>

<h4 id="4wait属于object的成员方法一旦一个对象调用了wait方法必须要采用notify和notifyall方法唤醒该进程">4、wait属于Object的成员方法，一旦一个对象调用了wait方法，必须要采用notify()和notifyAll()方法唤醒该进程;</h4>

<h4 id="5sleep和wait方法必需捕获异常而notify和notifyall不需要捕获异常">5、sleep和wait方法必需捕获异常，而notify和notifyAll不需要捕获异常。</h4>

<h3 id="63生产者和消费者">6.3、生产者和消费者</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="kn">package</span> <span class="n">com</span><span class="o">.</span><span class="na">hlj</span><span class="o">.</span><span class="na">moudle</span><span class="o">.</span><span class="na">thread</span><span class="o">.</span><span class="na">d09wait</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">org.junit.Test</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.PriorityQueue</span><span class="o">;</span>

<span class="cm">/**
 * 作者 ：HealerJean
 * 日期 ：2019/2/17  下午7:58.
 * 类描述：
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">D01</span><span class="err">生产者和消费者</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="kt">int</span> <span class="n">queueSize</span> <span class="o">=</span> <span class="mi">100</span><span class="o">;</span>
    <span class="kd">private</span> <span class="n">PriorityQueue</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">queue</span> <span class="o">=</span> <span class="k">new</span> <span class="n">PriorityQueue</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;(</span><span class="n">queueSize</span><span class="o">);</span>

    <span class="nd">@Test</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">test</span><span class="o">()</span>  <span class="o">{</span>



        <span class="n">Thread</span> <span class="n">producer</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Thread</span><span class="o">(()-&gt;{</span>
            <span class="k">while</span><span class="o">(</span><span class="kc">true</span><span class="o">){</span>
                <span class="kd">synchronized</span> <span class="o">(</span><span class="n">queue</span><span class="o">)</span> <span class="o">{</span>
                    <span class="k">while</span><span class="o">(</span><span class="n">queue</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">==</span> <span class="n">queueSize</span><span class="o">){</span>
                        <span class="k">try</span> <span class="o">{</span>
                            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"队列满，等待有空余空间"</span><span class="o">);</span>
                            <span class="n">queue</span><span class="o">.</span><span class="na">wait</span><span class="o">();</span>
                        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
                            <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
                        <span class="o">}</span>
                    <span class="o">}</span>
                    <span class="n">queue</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>        <span class="c1">//每次插入一个元素</span>
                    <span class="n">queue</span><span class="o">.</span><span class="na">notify</span><span class="o">();</span>           <span class="c1">//有数据了，防止消费者一直在等待没有数据获取</span>
                    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"向队列取中插入一个元素，队列剩余空间："</span><span class="o">+(</span><span class="n">queueSize</span><span class="o">-</span><span class="n">queue</span><span class="o">.</span><span class="na">size</span><span class="o">()));</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">});</span>

        <span class="n">Thread</span> <span class="n">consumer</span>  <span class="o">=</span> <span class="k">new</span> <span class="n">Thread</span><span class="o">(()-&gt;{</span>
            <span class="k">while</span><span class="o">(</span><span class="kc">true</span><span class="o">){</span>
                <span class="kd">synchronized</span> <span class="o">(</span><span class="n">queue</span><span class="o">)</span> <span class="o">{</span>
                    <span class="k">while</span><span class="o">(</span><span class="n">queue</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">==</span> <span class="mi">0</span><span class="o">){</span>
                        <span class="k">try</span> <span class="o">{</span>
                            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"队列空，等待数据"</span><span class="o">);</span>
                            <span class="n">queue</span><span class="o">.</span><span class="na">wait</span><span class="o">();</span> <span class="c1">//持续执行while，等待当前线程</span>
                        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span><span class="c1">//如果当前线程出现了中断</span>
                            <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
                        <span class="o">}</span>
                    <span class="o">}</span>
                    <span class="n">queue</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>          <span class="c1">//每次移走队首元素</span>
                    <span class="n">queue</span><span class="o">.</span><span class="na">notify</span><span class="o">();</span>        <span class="c1">//数据消耗了，防止生产者队列满了数据获取不到</span>
                    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"从队列取走一个元素，队列剩余"</span><span class="o">+</span><span class="n">queue</span><span class="o">.</span><span class="na">size</span><span class="o">()+</span><span class="s">"个元素"</span><span class="o">);</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">});</span>

        <span class="n">producer</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
        <span class="n">consumer</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
    <span class="o">}</span>

<span class="o">}</span>


</code></pre></div></div>

<h2 id="7线程组">7、线程组</h2>

<p>如果没有显示指定属于哪个线程组，那么该线程就属于默认线程组（即main线程组）。默认情况下，子线程和父线程处于同一个线程组。 只有在创建线程时才能指定其所在的线程组，线程运行中途不能改变它所属的线程组</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="n">com</span><span class="o">.</span><span class="na">hlj</span><span class="o">.</span><span class="na">moudle</span><span class="o">.</span><span class="na">thread</span><span class="o">.</span><span class="na">D10</span><span class="err">线程组</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">org.junit.Test</span><span class="o">;</span>

<span class="cm">/**
 * 作者 ：HealerJean
 * 日期 ：2019/2/17  下午8:13.
 * 类描述：线程组
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">D01ThreadGroup</span> <span class="o">{</span>


    <span class="nd">@Test</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">testThreadGrpup</span><span class="o">(){</span>

        <span class="cm">/**
         * 每个线程都有线程组，默认是 main
         */</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getThreadGroup</span><span class="o">().</span><span class="na">getName</span><span class="o">());</span>

        <span class="n">ThreadGroup</span> <span class="n">tg</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ThreadGroup</span><span class="o">(</span><span class="s">"PrintGroup"</span><span class="o">);</span>

        <span class="n">Thread</span> <span class="n">thread1</span><span class="o">=</span> <span class="k">new</span> <span class="n">Thread</span><span class="o">(</span><span class="n">tg</span><span class="o">,()-&gt;{</span>
            <span class="k">while</span> <span class="o">(</span><span class="kc">true</span><span class="o">){</span>

            <span class="o">}</span>
        <span class="o">},</span><span class="s">"线程1"</span><span class="o">);</span>


        <span class="n">Thread</span> <span class="n">thread2</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Thread</span><span class="o">(</span><span class="n">tg</span><span class="o">,()-&gt;{</span>
            <span class="k">while</span> <span class="o">(</span><span class="kc">true</span><span class="o">){</span>
            <span class="o">}</span>
        <span class="o">},</span><span class="s">"线程2"</span><span class="o">);</span>

        <span class="n">thread1</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
        <span class="n">thread2</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">tg</span><span class="o">.</span><span class="na">activeCount</span><span class="o">());</span> <span class="c1">//2 返回此线程组中活动线程的估计数。</span>


    <span class="o">}</span>

<span class="o">}</span>

</code></pre></div></div>

<h3 id="71作用">7.1、作用</h3>

<p>　　这个线程组可以用来管理一组线程，通过activeCount() 来查看活动线程的数量。其他没有什么大的用处。　<br /></p>

<p>线程组是为了方便线程的管理 线程池是为了管理线程的生命周期，复用线程，减少创建销毁线程的开销。</p>

<h1 id="三lock">三、Lock</h1>

<h2 id="1reentrantlock可重入锁">1、ReentrantLock可重入锁</h2>

<p>开发人员必须手动选择何时加锁（lock本身就是锁），何时释放锁，冲入锁的灵活性，远远高原synchronized，但是一定要记得，退出临界区是，一定要释放锁，否则其他线程没有机会再使用临界区（多个线程交替使用，不像synchronize，线程单独霸占）</p>

<h3 id="11locklock-lockunlock的简单使用">1.1、lock.lock() lock.unlock()的简单使用</h3>

<p>下面的输出结果永远都是 40</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="kn">package</span> <span class="n">com</span><span class="o">.</span><span class="na">hlj</span><span class="o">.</span><span class="na">moudle</span><span class="o">.</span><span class="na">thread</span><span class="o">.</span><span class="na">D11ReentrantLock</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">org.junit.Test</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.concurrent.locks.Lock</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.concurrent.locks.ReentrantLock</span><span class="o">;</span>

<span class="cm">/**
 * 作者 ：HealerJean
 * 日期 ：2019/2/17  下午8:57.
 * 类描述：reentrantlock 可重入锁
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">D01ReentrantLock</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="n">Lock</span> <span class="n">lock</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ReentrantLock</span><span class="o">()</span> <span class="o">;</span>
    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="o">;</span>
    <span class="nd">@Test</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">testReentrantlock</span><span class="o">(){</span>

        <span class="n">Thread</span> <span class="n">thread</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Thread</span><span class="o">(()-&gt;{</span>

            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="mi">20</span> <span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
                <span class="n">lock</span><span class="o">.</span><span class="na">lock</span><span class="o">();</span>
                  <span class="n">i</span><span class="o">++</span> <span class="o">;</span>
                <span class="n">lock</span><span class="o">.</span><span class="na">unlock</span><span class="o">();</span>
            <span class="o">}</span>

        <span class="o">});</span>

        <span class="n">Thread</span> <span class="n">thread2</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Thread</span><span class="o">(()-&gt;{</span>

            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="mi">20</span> <span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
                <span class="n">lock</span><span class="o">.</span><span class="na">lock</span><span class="o">();</span>
                <span class="n">i</span><span class="o">++</span> <span class="o">;</span>
                <span class="n">lock</span><span class="o">.</span><span class="na">unlock</span><span class="o">();</span>
            <span class="o">}</span>

        <span class="o">});</span>

        <span class="n">thread</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
        <span class="n">thread2</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="n">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">1000</span><span class="o">);</span>
            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
        <span class="o">}</span>


    <span class="o">}</span>


<span class="o">}</span>


</code></pre></div></div>

<h2 id="2中断锁-lockinterruptibly">2、中断锁 lockInterruptibly</h2>

<p>lock不会抛出异常，lockInterruptibly会抛出异常</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
//    不可以用下面的接口喽，因为它没有lockInterruptibly 方法
//    public Lock lock = new ReentrantLock() ;


lockInterruptibly（） 如果当前线程未被中断，获取锁
isHeldByCurrentThread() 当前线程是否保持锁锁定，线程的执行lock方法的前后分别是false和true

</code></pre></div></div>

<h4 id="测试两个锁各互相需要对方的锁但是都不释放这里中断一个让对方获取让对方执行">测试，两个锁各互相需要对方的锁，但是都不释放，这里中断一个，让对方获取，让对方执行</h4>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="kn">package</span> <span class="n">com</span><span class="o">.</span><span class="na">hlj</span><span class="o">.</span><span class="na">moudle</span><span class="o">.</span><span class="na">thread</span><span class="o">.</span><span class="na">D11ReentrantLock</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">org.junit.Test</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.concurrent.locks.Lock</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.concurrent.locks.ReentrantLock</span><span class="o">;</span>

<span class="cm">/**
 * 作者 ：HealerJean
 * 日期 ：2019/2/17  下午9:11.
 * 类描述：
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">D02</span><span class="err">中断</span><span class="n">lockInterruptibly</span> <span class="o">{</span>

<span class="c1">//    不可以用下面的接口喽，因为它没有lockInterruptibly 方法</span>
<span class="c1">//    public Lock lock = new ReentrantLock() ;</span>

    <span class="kd">public</span> <span class="n">ReentrantLock</span> <span class="n">lock1</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ReentrantLock</span><span class="o">()</span> <span class="o">;</span>
    <span class="kd">public</span> <span class="n">ReentrantLock</span> <span class="n">lock2</span><span class="o">=</span> <span class="k">new</span> <span class="n">ReentrantLock</span><span class="o">()</span> <span class="o">;</span>

    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="o">;</span>

    <span class="nd">@Test</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="err">线程中断</span><span class="o">(){</span>
        <span class="n">Thread</span> <span class="n">thread1</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Thread</span><span class="o">(()-&gt;{</span>
            <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">;</span>
            <span class="n">task</span><span class="o">();</span>
        <span class="o">},</span><span class="s">"线程1"</span><span class="o">);</span>
        <span class="n">Thread</span> <span class="n">thread2</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Thread</span><span class="o">(()-&gt;{</span>
            <span class="n">i</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">;</span>
            <span class="n">task</span><span class="o">();</span>
        <span class="o">},</span><span class="s">"线程2"</span><span class="o">);</span>

        <span class="n">thread1</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
        <span class="n">thread2</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>

        <span class="k">try</span> <span class="o">{</span>
            <span class="n">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">1000</span><span class="o">);</span> <span class="c1">//等待线程1和线程2分到到了获取各自锁的地方，然后执行下面的中断</span>
            <span class="n">thread2</span><span class="o">.</span><span class="na">interrupt</span><span class="o">();</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
        <span class="o">}</span>

    <span class="o">}</span>

    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">task</span><span class="o">(</span> <span class="o">)</span> <span class="o">{</span>
        <span class="k">try</span> <span class="o">{</span>
             <span class="k">if</span> <span class="o">(</span> <span class="n">i</span><span class="o">==</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">lock1</span><span class="o">.</span><span class="na">lockInterruptibly</span><span class="o">();</span>
                <span class="n">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">500</span><span class="o">);</span> <span class="c1">//等待线程2执行</span>
                <span class="n">lock2</span><span class="o">.</span><span class="na">lockInterruptibly</span><span class="o">();</span>
                <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"111111"</span><span class="o">);</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="n">lock2</span><span class="o">.</span><span class="na">lockInterruptibly</span><span class="o">();</span>
                <span class="n">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">500</span><span class="o">);</span><span class="c1">//等待线程1执行</span>
                <span class="n">lock1</span><span class="o">.</span><span class="na">lockInterruptibly</span><span class="o">();</span>
                <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"2222222"</span><span class="o">);</span>
            <span class="o">}</span>

        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getName</span><span class="o">()+</span><span class="s">"中断了，但是这里跑出了InterruptedException异常，所以释放了"</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
            <span class="c1">//判断是否拥有锁，先进来的先把锁解开了</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">lock1</span><span class="o">.</span><span class="na">isHeldByCurrentThread</span><span class="o">())</span> <span class="o">{</span>
                <span class="n">lock1</span><span class="o">.</span><span class="na">unlock</span><span class="o">();</span>
            <span class="o">}</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">lock2</span><span class="o">.</span><span class="na">isHeldByCurrentThread</span><span class="o">())</span> <span class="o">{</span>
                <span class="n">lock2</span><span class="o">.</span><span class="na">unlock</span><span class="o">();</span>
            <span class="o">}</span>
            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getName</span><span class="o">()</span> <span class="o">+</span> <span class="s">":线程退出"</span><span class="o">);</span>
        <span class="o">}</span>

    <span class="o">}</span>


<span class="err">线程</span><span class="mi">2</span><span class="err">中断了，但是这里跑出了</span><span class="n">InterruptedException</span><span class="err">异常，所以释放了</span>
<span class="err">线程</span><span class="mi">2</span><span class="o">:</span><span class="err">线程退出</span>
<span class="mi">111111</span>
<span class="err">线程</span><span class="mi">1</span><span class="o">:</span><span class="err">线程退出</span>



<span class="o">}</span>


</code></pre></div></div>

<h2 id="3锁申请等待限时locktrylock5-timeunitseconds">3、锁申请等待限时<code class="highlighter-rouge">lock.tryLock(5, TimeUnit.SECONDS)</code></h2>

<h2 id="32锁申请不限时locktrylock-不介绍了">3.2、锁申请不限时lock.tryLock()) 不介绍了</h2>

<p>限时等待，比如，约好朋友，他如果2个小时没来，那么，就不等了,也就是说不会执行里面的代码了</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="kd">public</span> <span class="n">ReentrantLock</span> <span class="n">lock</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ReentrantLock</span><span class="o">()</span> <span class="o">;</span>

</code></pre></div></div>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="n">com</span><span class="o">.</span><span class="na">hlj</span><span class="o">.</span><span class="na">moudle</span><span class="o">.</span><span class="na">thread</span><span class="o">.</span><span class="na">D11ReentrantLock</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">org.junit.Test</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.concurrent.TimeUnit</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.concurrent.locks.Lock</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.concurrent.locks.ReentrantLock</span><span class="o">;</span>

<span class="cm">/**
 * 作者 ：HealerJean
 * 日期 ：2019/2/17  下午9:37.
 * 类描述：
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">D03</span><span class="err">锁申请等待限时</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="n">ReentrantLock</span> <span class="n">lock</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ReentrantLock</span><span class="o">()</span> <span class="o">;</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">task</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">try</span> <span class="o">{</span><span class="c1">//等待时长，计时单位</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">lock</span><span class="o">.</span><span class="na">tryLock</span><span class="o">(</span><span class="mi">5</span><span class="o">,</span> <span class="n">TimeUnit</span><span class="o">.</span><span class="na">SECONDS</span><span class="o">))</span> <span class="o">{</span>
                <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getName</span><span class="o">());</span>
                <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"get lock success"</span><span class="o">);</span>
                <span class="n">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">6000</span><span class="o">);</span> <span class="c1">//占用线程6秒，哈哈，肯定大于5秒了，所以两个</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getName</span><span class="o">());</span>
                <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"get lock failed"</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
        <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">lock</span><span class="o">.</span><span class="na">isHeldByCurrentThread</span><span class="o">())</span> <span class="o">{</span>
                <span class="n">lock</span><span class="o">.</span><span class="na">unlock</span><span class="o">();</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="nd">@Test</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">testReentrantlock</span><span class="o">(){</span>

        <span class="n">Thread</span> <span class="n">thread</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Thread</span><span class="o">(()-&gt;{</span>
            <span class="n">task</span><span class="o">();</span>
        <span class="o">},</span><span class="s">"线程1"</span><span class="o">);</span>
        <span class="n">Thread</span> <span class="n">thread2</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Thread</span><span class="o">(()-&gt;{</span>
            <span class="n">task</span><span class="o">();</span>
        <span class="o">},</span><span class="s">"线程2"</span><span class="o">);</span>

        <span class="n">thread</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
        <span class="n">thread2</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="n">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">8000</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
        <span class="o">}</span>

    <span class="o">}</span>

<span class="o">}</span>


    <span class="cm">/**
     线程2
     get lock success
     线程1
     get lock failed
     */</span>

<span class="err">都有可能出现</span>
<span class="err">线程</span><span class="mi">1</span>
<span class="n">get</span> <span class="n">lock</span> <span class="n">success</span>
<span class="err">线程</span><span class="mi">2</span>
<span class="n">get</span> <span class="n">lock</span> <span class="n">failed</span>


</code></pre></div></div>

<h2 id="4公平锁-new-reentrantlocktrue">4、公平锁 new ReentrantLock(true);</h2>

<p>默认情况下，锁都是非公平的，synchronized关键字进行的锁控制，是非公平的，重入锁，允许我们进行公平性的设置，如果没有特别需求，还是不用公平锁
<br /></p>

<p>公平锁的一个特点是:不会产生饥饿现象,只要排队最终都会得到资源，但是实现公平锁要求系统维护一个有序队列,因此公平锁的实现成本较高,性能相对低下.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
    <span class="kd">public</span> <span class="kd">static</span> <span class="n">ReentrantLock</span> <span class="n">fairLock</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ReentrantLock</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span><span class="c1">//设置true指定锁是公平的,也可以不设置,分别运行观察</span>
</code></pre></div></div>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="n">com</span><span class="o">.</span><span class="na">hlj</span><span class="o">.</span><span class="na">moudle</span><span class="o">.</span><span class="na">thread</span><span class="o">.</span><span class="na">D11ReentrantLock</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">org.junit.Test</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.concurrent.locks.ReentrantLock</span><span class="o">;</span>

<span class="cm">/**
 * 作者 ：HealerJean
 * 日期 ：2019/2/17  下午10:05.
 * 类描述：
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">D05</span><span class="err">公平锁</span><span class="n">True</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="n">ReentrantLock</span> <span class="n">lock</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ReentrantLock</span><span class="o">(</span><span class="kc">true</span><span class="o">)</span> <span class="o">;</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">task</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">while</span> <span class="o">(</span><span class="kc">true</span><span class="o">){</span>
            <span class="n">lock</span><span class="o">.</span><span class="na">lock</span><span class="o">();</span>
            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getName</span><span class="o">());</span>
            <span class="n">lock</span><span class="o">.</span><span class="na">unlock</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="nd">@Test</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">test</span><span class="o">(){</span>

        <span class="n">Thread</span> <span class="n">thread</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Thread</span><span class="o">(()-&gt;{</span>
            <span class="n">task</span><span class="o">();</span>
        <span class="o">},</span><span class="s">"线程1"</span><span class="o">);</span>
        <span class="n">Thread</span> <span class="n">thread2</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Thread</span><span class="o">(()-&gt;{</span>
            <span class="n">task</span><span class="o">();</span>
        <span class="o">},</span><span class="s">"线程2"</span><span class="o">);</span>

        <span class="n">thread</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
        <span class="n">thread2</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="n">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">8000</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
        <span class="o">}</span>

    <span class="o">}</span>
<span class="o">}</span>


<span class="err">发现整整齐齐</span> 

<span class="err">线程</span><span class="mi">1</span>
<span class="err">线程</span><span class="mi">2</span>
<span class="err">线程</span><span class="mi">1</span>
<span class="err">线程</span><span class="mi">2</span>
<span class="err">线程</span><span class="mi">1</span>
<span class="err">线程</span><span class="mi">2</span>
<span class="err">线程</span><span class="mi">1</span>
<span class="err">线程</span><span class="mi">2</span>
<span class="err">线程</span><span class="mi">1</span>
<span class="err">线程</span><span class="mi">2</span>
<span class="err">线程</span><span class="mi">1</span>

</code></pre></div></div>

<h2 id="5condition-条件">5、Condition 条件</h2>

<p>和wait和notify有点像<br /></p>

<p>1、await()方法会让当前线程等待，同事释放当前锁，，当其他线程使用signal（或者signalAll（）方法时，先回重新获得锁，并继续执行<br /></p>

<p>2、singal（）方法用于唤醒一个在线程中等待的线程，，这方法在使用的时候，也要求线程，先获得相关锁，然后唤醒线程，在singal之后，要释放掉相关锁(unlock)，谦让给被唤醒的线程，让它可以继续执行。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="kn">package</span> <span class="n">com</span><span class="o">.</span><span class="na">hlj</span><span class="o">.</span><span class="na">moudle</span><span class="o">.</span><span class="na">thread</span><span class="o">.</span><span class="na">D11ReentrantLock</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">org.junit.Test</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.concurrent.locks.Condition</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.concurrent.locks.Lock</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.concurrent.locks.ReentrantLock</span><span class="o">;</span>

<span class="cm">/**
 * 作者 ：HealerJean
 * 日期 ：2019/2/17  下午10:11.
 *
 * 1、await()方法会让当前线程等待，同事释放当前锁，，当其他线程使用signal（或者signalAll（）方法时，先回重新获得锁，并继续执行
 * 2、singal（）方法用于唤醒一个再线程中等待的线程，，这方法在使用的时候，也要求线程，先获得相关锁，然后唤醒线程，在singal之后，要释放掉相关锁，谦让给被唤醒的线程，让它可以继续执行。
 *
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">D06Condition</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="n">Lock</span> <span class="n">lock</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ReentrantLock</span><span class="o">(</span><span class="kc">true</span><span class="o">)</span> <span class="o">;</span>
    <span class="kd">public</span> <span class="n">Condition</span> <span class="n">condition</span> <span class="o">=</span> <span class="n">lock</span><span class="o">.</span><span class="na">newCondition</span><span class="o">();</span>


    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">task</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">lock</span><span class="o">.</span><span class="na">lock</span><span class="o">();</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="n">condition</span><span class="o">.</span><span class="na">await</span><span class="o">();</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
        <span class="o">}</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getName</span><span class="o">());</span>
        <span class="n">lock</span><span class="o">.</span><span class="na">unlock</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="nd">@Test</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">test</span><span class="o">(){</span>

        <span class="n">Thread</span> <span class="n">thread</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Thread</span><span class="o">(()-&gt;{</span>
            <span class="n">task</span><span class="o">();</span>
        <span class="o">},</span><span class="s">"线程1"</span><span class="o">);</span>

        <span class="n">thread</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="n">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">500</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
        <span class="o">}</span>

        <span class="n">lock</span><span class="o">.</span><span class="na">lock</span><span class="o">();</span>
        <span class="n">condition</span><span class="o">.</span><span class="na">signal</span><span class="o">();</span>
        <span class="n">lock</span><span class="o">.</span><span class="na">unlock</span><span class="o">();</span>



    <span class="o">}</span>

<span class="o">}</span>


        <span class="cm">/**
         * 打印结果
         * 线程1
         */</span>
        


</code></pre></div></div>

<h2 id="6读写锁reentrantreadwritelockreadlock">6、读写锁<code class="highlighter-rouge">reentrantReadWriteLock.readLock()</code></h2>

<p>解释：</p>

<p>对于Synchronized、ReentrantLock，同一时间内只能有一个线程访问被锁定的代码，那么读写锁则不同，其本质是分离两个锁，即读锁和写锁。<br /></p>

<p>ReadWriteLock是JDK5开始提供的读写分离锁。读写分离开有效的帮助减少锁的竞争，以提升系统性能。用锁分离的机制避免多个读操作线程之间的等待。 <br /></p>

<font color="red">在读锁下，多个线程呢个可以并发的进行访问，但是在写锁的时候，只能顺序的访问。</font>

<p>比如线程A1，A2，A3进行写操作，B1，B2,B3进行读操作，这样就能让B1，B2.B3,之间并行，如果系统中读操作次数远远大于写操作，这种方式就会很有用了<br /></p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
读读不互斥，读读不阻塞

写写互斥，写写阻塞，

读写互斥 读阻塞写 ，写阻塞读

private static ReentrantReadWriteLock reentrantReadWriteLock = new ReentrantReadWriteLock();
private static Lock readLock = reentrantReadWriteLock.readLock();
private static Lock writeLock = reentrantReadWriteLock.writeLock();



</code></pre></div></div>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="n">com</span><span class="o">.</span><span class="na">hlj</span><span class="o">.</span><span class="na">moudle</span><span class="o">.</span><span class="na">thread</span><span class="o">.</span><span class="na">D11ReentrantLock</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">org.junit.Test</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.Random</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.concurrent.locks.Lock</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.concurrent.locks.ReentrantLock</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.concurrent.locks.ReentrantReadWriteLock</span><span class="o">;</span>

<span class="cm">/**
 * 作者 ：HealerJean
 * 日期 ：2019/2/17  下午10:31.
 * 类描述：
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">D07</span><span class="err">读写锁</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="n">Lock</span> <span class="n">lock</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ReentrantLock</span><span class="o">();</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="n">ReentrantReadWriteLock</span> <span class="n">reentrantReadWriteLock</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ReentrantReadWriteLock</span><span class="o">();</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="n">Lock</span> <span class="n">readLock</span> <span class="o">=</span> <span class="n">reentrantReadWriteLock</span><span class="o">.</span><span class="na">readLock</span><span class="o">();</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="n">Lock</span> <span class="n">writeLock</span> <span class="o">=</span> <span class="n">reentrantReadWriteLock</span><span class="o">.</span><span class="na">writeLock</span><span class="o">();</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">int</span> <span class="n">value</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="n">Object</span> <span class="nf">handleRead</span><span class="o">(</span><span class="n">Lock</span> <span class="n">lock</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">InterruptedException</span> <span class="o">{</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="n">lock</span><span class="o">.</span><span class="na">lock</span><span class="o">();</span>
            <span class="n">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">1000</span><span class="o">);</span><span class="c1">// 模拟读操作</span>
            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"读操作:"</span> <span class="o">+</span> <span class="n">value</span><span class="o">);</span>
            <span class="k">return</span> <span class="n">value</span><span class="o">;</span>
        <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
            <span class="n">lock</span><span class="o">.</span><span class="na">unlock</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">handleWrite</span><span class="o">(</span><span class="n">Lock</span> <span class="n">lock</span><span class="o">,</span> <span class="kt">int</span> <span class="n">index</span><span class="o">)</span>
            <span class="kd">throws</span> <span class="n">InterruptedException</span> <span class="o">{</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="n">lock</span><span class="o">.</span><span class="na">lock</span><span class="o">();</span>
            <span class="n">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">1000</span><span class="o">);</span><span class="c1">// 模拟写操作</span>
            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"写操作:"</span> <span class="o">+</span> <span class="n">value</span><span class="o">);</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">index</span><span class="o">;</span>
        <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
            <span class="n">lock</span><span class="o">.</span><span class="na">unlock</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>
        <span class="n">TestReadThread</span> <span class="n">testReadThread</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TestReadThread</span><span class="o">();</span>
        <span class="n">TestWriteThread</span> <span class="n">testWriteThread</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TestWriteThread</span><span class="o">();</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">18</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">new</span> <span class="nf">Thread</span><span class="o">(</span><span class="n">testReadThread</span><span class="o">).</span><span class="na">start</span><span class="o">();</span>
        <span class="o">}</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">18</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">20</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">new</span> <span class="nf">Thread</span><span class="o">(</span><span class="n">testWriteThread</span><span class="o">).</span><span class="na">start</span><span class="o">();</span>
        <span class="o">}</span>

    <span class="o">}</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">TestReadThread</span> <span class="kd">extends</span> <span class="n">Thread</span> <span class="o">{</span>
        <span class="nd">@Override</span>
        <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
            <span class="k">try</span> <span class="o">{</span>
                <span class="c1">//Test.handleRead(lock);</span>
                <span class="n">D07</span><span class="err">读写锁</span><span class="o">.</span><span class="na">handleRead</span><span class="o">(</span><span class="n">readLock</span><span class="o">);</span>
            <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">TestWriteThread</span> <span class="kd">extends</span> <span class="n">Thread</span> <span class="o">{</span>
        <span class="nd">@Override</span>
        <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
            <span class="k">try</span> <span class="o">{</span>
                <span class="c1">//Test.handleWrite(lock,new Random().nextInt(100));</span>
                <span class="n">D07</span><span class="err">读写锁</span><span class="o">.</span><span class="na">handleWrite</span><span class="o">(</span><span class="n">writeLock</span><span class="o">,</span><span class="k">new</span> <span class="n">Random</span><span class="o">().</span><span class="na">nextInt</span><span class="o">(</span><span class="mi">100</span><span class="o">));</span>
            <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>

<span class="o">}</span>

<span class="err">时间上观察，发现读操作一些字全部执行完成了，说明不互斥，也不阻塞，不影响，但是写操作是顺序访问的</span>

<span class="err">读操作</span><span class="o">:</span><span class="mi">0</span>
<span class="err">读操作</span><span class="o">:</span><span class="mi">0</span>
<span class="err">读操作</span><span class="o">:</span><span class="mi">0</span>
<span class="err">读操作</span><span class="o">:</span><span class="mi">0</span>
<span class="err">读操作</span><span class="o">:</span><span class="mi">0</span>
<span class="err">读操作</span><span class="o">:</span><span class="mi">0</span>
<span class="err">读操作</span><span class="o">:</span><span class="mi">0</span>
<span class="err">读操作</span><span class="o">:</span><span class="mi">0</span>
<span class="err">读操作</span><span class="o">:</span><span class="mi">0</span>
<span class="err">读操作</span><span class="o">:</span><span class="mi">0</span>
<span class="err">读操作</span><span class="o">:</span><span class="mi">0</span>
<span class="err">读操作</span><span class="o">:</span><span class="mi">0</span>
<span class="err">读操作</span><span class="o">:</span><span class="mi">0</span>
<span class="err">读操作</span><span class="o">:</span><span class="mi">0</span>
<span class="err">读操作</span><span class="o">:</span><span class="mi">0</span>
<span class="err">读操作</span><span class="o">:</span><span class="mi">0</span>
<span class="err">读操作</span><span class="o">:</span><span class="mi">0</span>
<span class="err">读操作</span><span class="o">:</span><span class="mi">0</span>
<span class="err">写操作</span><span class="o">:</span><span class="mi">0</span>
<span class="err">写操作</span><span class="o">:</span><span class="mi">7</span>
</code></pre></div></div>

<p><br /><br /><br /></p>
<font color="red"> 感兴趣的，欢迎添加博主微信， </font>
<p><br />
哈，博主很乐意和各路好友交流，如果满意，请打赏博主任意金额，感兴趣的在微信转账的时候，备注您的微信或者其他联系方式。添加博主微信哦。
<br />
请下方留言吧。可与博主自由讨论哦</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">微信</th>
      <th style="text-align: center">微信公众号</th>
      <th style="text-align: center">支付宝</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center"><img src="https://raw.githubusercontent.com/HealerJean/HealerJean.github.io/master/assets/img/tctip/weixin.jpg" alt="微信" /></td>
      <td style="text-align: center"><img src="https://raw.githubusercontent.com/HealerJean/HealerJean.github.io/master/assets/img/my/qrcode_for_gh_a23c07a2da9e_258.jpg" alt="微信公众号" /></td>
      <td style="text-align: center"><img src="https://raw.githubusercontent.com/HealerJean/HealerJean.github.io/master/assets/img/tctip/alpay.jpg" alt="支付宝" /></td>
    </tr>
  </tbody>
</table>

<!-- Gitalk 评论 start  -->

<link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css" />

<script src="https://unpkg.com/gitalk@latest/dist/gitalk.min.js"></script>
<p> </p>
<div id="gitalk-container"></div>
<p>  <br />
 <script type="text/javascript">
    var gitalk = new Gitalk({
		clientID: `1d164cd85549874d0e3a`,
		clientSecret: `527c3d223d1e6608953e835b547061037d140355`,
		repo: `HealerJean.github.io`,
		owner: 'HealerJean',
		admin: ['HealerJean'],
		id: '3N2T5z8WE9bRmIvk',
    });
    gitalk.render('gitalk-container');
</script> </p>

<!-- Gitalk end -->

  
	</div>
	<footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <!--
  <%- list_categories(item.categories, {
      show_count: false,
      class: 'article-category',
      style: 'none',
      separator: '►'
  }) %>
  -->
  
  <a class="article-category-link" href="/categories/#Thread">Thread</a>
  
</div>


  <div class="article-tags">
  <!--
  <% var tags = [];
    item.tags.forEach(function(tag){
      tags.push('<a href="' + config.root + tag.path + '">' + tag.name + '</a>');
    }); %>-->
  <span></span> <!--<%- tags.join('') %>-->
  
  
  <a href="/tags/#Thread">Thread</a>
  
  </div>

</div>



	<div class="article-share" id="share">
	
	  <div data-url="http://localhost:4000/thread/2018/10/18/7_%E7%BA%BF%E7%A8%8B%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3/" data-title="线程方法详解 | HealeJean的梦想博客" data-tsina="" class="share clearfix">
	  </div>
	
	</div>


</footer>
   
	</article>
	
<nav class="article-nav clearfix">
 
 <div class="prev" >
 <a href="/java/2018/10/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/" title="设计模式之观察者模式">
  <strong>上一篇：</strong><br/>
  <span>
  设计模式之观察者模式</span>
</a>
</div>


<div class="next">
<a href="/thread/2018/10/19/_8_%E5%85%B3%E9%97%AD%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BB%A5%E5%8F%8A%E5%88%A4%E6%96%AD%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BB%BB%E5%8A%A1%E6%89%A7%E8%A1%8C%E5%AE%8C%E6%88%90/"  title="关闭线程池以及判断线程池任务执行完成">
 <strong>下一篇：</strong><br/> 
 <span>关闭线程池以及判断线程池任务执行完成
</span>
</a>
</div>

</nav>

	

</div>  

      
      
      <div class="openaside"><a class="navbutton" href="#" title="Show Sidebar"></a></div>

  <div id="toc" class="toc-aside toc-content">
 
 <!--<%- toc(item.content) %>-->
 
  </div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="Hide Sidebar"></a></div>
<aside class="clearfix">


  <div class="linkslist">
  <p class="asidetitle">个人网站</p>
    <ul>
        
          <li>
            <a href="http://blog.csdn.net/u012954706" target="_blank" title="csdn">csdn</a>
          </li>
        
          <li>
            <a href="http://www.cnblogs.com/HealerJean/" target="_blank" title="博客园">博客园</a>
          </li>
        
          <li>
            <a href="https://weibo.com/u/3889598250/" target="_blank" title="微博">微博</a>
          </li>
        
          <li>
            <a href="https://www.jianshu.com/u/54ba972e92a8" target="_blank" title="简书">简书</a>
          </li>
        
          <li>
            <a href="https://www.zhihu.com/people/healerjean" target="_blank" title="知乎">知乎</a>
          </li>
        
    </ul>
</div>

  <div class="weiboshow">

     <p class="asidetitle">个人信息</p>
     <script src="/assets/img/person/jquery.js"></script>
     <script src="/assets/img/person/jquery-github-user-widget.js"></script>
     <div class="github-widget-user" data-user="HealerJean">	</div>

</div>


  
<div class="tagslist">
	<p class="asidetitle">标签</p>
		<ul class="clearfix">
		
			
				<li><a href="/tags/#Java" title="Java">Java<sup>28</sup></a></li>
			
		
			
				<li><a href="/tags/#MarkDown" title="MarkDown">MarkDown<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/#SpringBoot" title="SpringBoot">SpringBoot<sup>24</sup></a></li>
			
		
			
				<li><a href="/tags/#Docker" title="Docker">Docker<sup>17</sup></a></li>
			
		
			
				<li><a href="/tags/#server" title="server">server<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/#Quartz" title="Quartz">Quartz<sup>7</sup></a></li>
			
		
			
				<li><a href="/tags/#database" title="database">database<sup>6</sup></a></li>
			
		
			
				<li><a href="/tags/#SoftWare" title="SoftWare">SoftWare<sup>6</sup></a></li>
			
		
			
				<li><a href="/tags/#GitHub" title="GitHub">GitHub<sup>5</sup></a></li>
			
		
			
				<li><a href="/tags/#Mac" title="Mac">Mac<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/#Thread" title="Thread">Thread<sup>8</sup></a></li>
			
		
			
				<li><a href="/tags/#Url" title="Url">Url<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/#Annotation" title="Annotation">Annotation<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/#SortAlgorithm" title="SortAlgorithm">SortAlgorithm<sup>12</sup></a></li>
			
		
			
				<li><a href="/tags/#CAS" title="CAS">CAS<sup>10</sup></a></li>
			
		
			
				<li><a href="/tags/#Maven" title="Maven">Maven<sup>5</sup></a></li>
			
		
			
				<li><a href="/tags/#HTML" title="HTML">HTML<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/#AngularJs" title="AngularJs">AngularJs<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/#WeChat" title="WeChat">WeChat<sup>13</sup></a></li>
			
		
			
				<li><a href="/tags/#Experience" title="Experience">Experience<sup>4</sup></a></li>
			
		
			
				<li><a href="/tags/#Team" title="Team">Team<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/#Utils" title="Utils">Utils<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/#Hibernate" title="Hibernate">Hibernate<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/#Date" title="Date">Date<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/#Log" title="Log">Log<sup>4</sup></a></li>
			
		
			
				<li><a href="/tags/#JSON" title="JSON">JSON<sup>5</sup></a></li>
			
		
			
				<li><a href="/tags/#GrayLog" title="GrayLog">GrayLog<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/#Database" title="Database">Database<sup>18</sup></a></li>
			
		
			
				<li><a href="/tags/#Redis" title="Redis">Redis<sup>16</sup></a></li>
			
		
			
				<li><a href="/tags/#Ehcache" title="Ehcache">Ehcache<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/#Druid" title="Druid">Druid<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/#Swagger" title="Swagger">Swagger<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/#Netty" title="Netty">Netty<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/#NIO" title="NIO">NIO<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/#WebSocket" title="WebSocket">WebSocket<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/#Map" title="Map">Map<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/#JVM" title="JVM">JVM<sup>11</sup></a></li>
			
		
			
				<li><a href="/tags/#Element" title="Element">Element<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/#Job" title="Job">Job<sup>5</sup></a></li>
			
		
			
				<li><a href="/tags/#Graphics" title="Graphics">Graphics<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/#Linux" title="Linux">Linux<sup>4</sup></a></li>
			
		
			
				<li><a href="/tags/#Databases" title="Databases">Databases<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/#Nginx" title="Nginx">Nginx<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/#SpirngBoot" title="SpirngBoot">SpirngBoot<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/#Linu" title="Linu">Linu<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/#JAVA" title="JAVA">JAVA<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/#Server" title="Server">Server<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/#Google" title="Google">Google<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/#Git" title="Git">Git<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/#分布式" title="分布式">分布式<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/#SpringCloud" title="SpringCloud">SpringCloud<sup>6</sup></a></li>
			
		
			
				<li><a href="/tags/#http" title="http">http<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/#docker" title="docker">docker<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/#Json" title="Json">Json<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/#Database~~~~" title="Database~~~~">Database~~~~<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/#weChat" title="weChat">weChat<sup>1</sup></a></li>
			
		
		</ul>
</div>


  


  


</aside>
</div>
    </div>
    <footer><div id="footer" >

	<!-- 打赏功能 -->
  <!-- <script src="http://static.tctip.com/tctip-1.0.0.min.js"></script> -->
  <script src="/assets/img/tctip/tctip-1.0.1.min.js"></script>
	<script>  
	new tctip({
	  top: '20%',
	  button: {
	    id: 9,
	    type: 'dashang',
	  },
	  list: [
	    {
	      type: 'alipay',
	      qrImg: '/assets/img/tctip/alpay.jpg'
	    }, {
	      type: 'wechat',
	      qrImg: '/assets/img/tctip/weixin.jpg'
	    }
	  ]
	}).init()
	</script>



	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<section class="info">
		<p> 欢迎来到  HealerJean 的梦想博客. <br/>
			------您已走进一个高级软件开发工程师的成长之路</p>
	</section>
	 


<!--  自带的分享功能 	-->
	<div class="social-font" class="clearfix">
		
		<a href="http://weibo.com/3889598250" target="_blank" class="icon-weibo" title="微博"></a>
		
		
		
		
		<a href="https://twitter.com/mxzdhealer" target="_blank" class="icon-twitter" title="twitter"></a>
		
		
		
		
		
		
		
		<a href="mailto:healerjean@gmail.com" target="_blank" class="icon-email" title="Email Me"></a>
		
	</div> 


	<!--
			<%  Array.prototype.S=String.fromCharCode(2);
			  Array.prototype.in_array=function(e){
    			var r=new RegExp(this.S+e+this.S);
    			return (r.test(this.S+this.join(this.S)+this.S));
				};
				var cc = new Array('by','by-nc','by-nc-nd','by-nc-sa','by-nd','by-sa','zero'); %>
		<% if (cc.in_array(theme.creative_commons) ) { %>
				<div class="cc-license">
          <a href="http://creativecommons.org/licenses/<%= theme.creative_commons %>/4.0" class="cc-opacity" target="_blank">
            <img src="<%- config.root %>img/cc-<%= theme.creative_commons %>.svg" alt="Creative Commons" />
          </a>
        </div>
    <% } %>
				-->

		<p class="copyright">
		welcome to <a href="http://jekyllrb.com" target="_blank" title="jekyll">HealerJean</a> 
		blog <a href="https://github.com/simpleyyt/jekyll-jacman" target="_blank" title="Jacman">for</a> © 2017 
		
		<a href="about" target="_blank" title="HealerJean">HealerJean</a>
		
		
		</p>
</div>
</footer>
    <script src="/assets/js/jquery-2.0.3.min.js"></script>
<script src="/assets/js/jquery.imagesloaded.min.js"></script>
<script src="/assets/js/gallery.js"></script>
<script src="/assets/js/jquery.qrcode-0.12.0.min.js"></script>
<script src="/assets/js/toc.js"></script>

<script type="text/javascript">
$(document).ready(function(){
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });

  

  $(window).resize(function(){
    getSize();
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
      
      $('#toc.toc-aside').css('display', 'none');
      
    }
  });
});
</script>




<script type="text/javascript">
$(document).ready(function(){
  $('#toc.toc-aside').toc({
    title: "文章目录",
    showEffect: "none"
  });
  $('#toc.toc-article').toc({
    title: "文章目录",
    showEffect: "show",
    showSpeed: 0
  });
});
</script>



<script type="text/javascript">
$(document).ready(function(){
  var ai = $('.article-content>iframe'),
      ae = $('.article-content>embed'),
      t  = $('#toc'),
      ta = $('#toc.toc-aside'),
      o  = $('.openaside'),
      c  = $('.closeaside');
  if(ai.length>0){
    ai.wrap('<div class="video-container" />');
  };
  if(ae.length>0){
   ae.wrap('<div class="video-container" />');
  };
  c.click(function(){
    ta.css('display', 'block').addClass('fadeIn');
  });
  o.click(function(){
    ta.css('display', 'none');
  });
  $(window).scroll(function(){
    ta.css("top",Math.max(140,320-$(this).scrollTop()));
  });
});
</script>



<script type="text/javascript">
$(document).ready(function(){
  var $this = $('.share'),
      url = $this.attr('data-url'),
      encodedUrl = encodeURIComponent(url),
      title = $this.attr('data-title'),
      tsina = $this.attr('data-tsina'),
      description = $this.attr('description');
  var html = [
  '<div class="hoverqrcode clearfix"></div>',
  '<a class="overlay" id="qrcode"></a>',
  '<div class="qrcode clearfix"><span>扫描二维码分享到微信朋友圈</span><a class="qrclose" href="#nothing"></a><strong>Loading...Please wait</strong><img id="qrcode-pic" data-src="http://s.jiathis.com/qrcode.php?url=' + encodedUrl + '"/></div>',
  '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"></a>',
  '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
  '<a href="#qrcode" class="article-share-qrcode" title="微信"></a>',
  '<a href="http://widget.renren.com/dialog/share?resourceUrl=' + encodedUrl + '&srcUrl=' + encodedUrl + '&title=' + title +'" class="article-share-renren" target="_blank" title="人人"></a>',
  '<a href="http://service.weibo.com/share/share.php?title='+title+'&url='+encodedUrl +'&ralateUid='+ tsina +'&searchPic=true&style=number' +'" class="article-share-weibo" target="_blank" title="微博"></a>',
  '<span title="Share to"></span>'
  ].join('');
  $this.append(html);

  $('.article-share-qrcode').click(function(){
    var imgSrc = $('#qrcode-pic').attr('data-src');
    $('#qrcode-pic').attr('src', imgSrc);
    $('#qrcode-pic').load(function(){
        $('.qrcode strong').text(' ');
    });
  });
/*
  $('.hoverqrcode').hide();

  var myWidth = 0;
  function updatehoverqrcode(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
    var qrsize = myWidth > 1024 ? 200:100;
    var options = {render: 'image', size: qrsize, fill: '#2ca6cb', text: url, radius: 0.5, quiet: 1};
    var p = $('.article-share-qrcode').position();
    $('.hoverqrcode').empty().css('width', qrsize).css('height', qrsize)
                          .css('left', p.left-qrsize/2+20).css('top', p.top-qrsize-10)
                          .qrcode(options);
  };
  $(window).resize(function(){
    $('.hoverqrcode').hide();
  });
  $('.article-share-qrcode').click(function(){
    updatehoverqrcode();
    $('.hoverqrcode').toggle();
  });
  $('.article-share-qrcode').hover(function(){}, function(){
      //$('.hoverqrcode').hide();
  });
  */
});
</script>






<!--

-->




<link rel="stylesheet" href="/assets/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/assets/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      if ($(this).hasClass('emoji')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
});
</script>


<!-- Analytics Begin -->





<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="返回顶部"><img src="/assets/img/scrollup.png"/></a>
	</div>
	<script src="/assets/js/totop.js"></script>


<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
</html>

