---
title: Dubbo的SPI原理
date: 2020-06-27 03:33:00
tags: 
- Dubbo
category: 
- Dubbo
description: Dubbo的SPI原理
---

**前言**     

 Github：[https://github.com/HealerJean](https://github.com/HealerJean)         

 博客：[http://blog.healerjean.com](http://HealerJean.github.io)          




> SPI 全称为 `Service Provider Interface`，是一种服务发现机制。**SPI 的本质是将接口实现类的全限定名配置在文件中，并由服务加载器读取配置文件，加载实现类。这样可以在运行时，动态为接口替换实现类**。      
>
> 正因此特性，我们可以很容易的通过 SPI 机制为我们的程序提供拓展功能。SPI 机制在第三方框架中也有所应用，比如 Dubbo 就是通过 SPI 机制加载所有的组件。不过，Dubbo 并未使用 Java 原生的 SPI 机制，而是对其进行了增强，使其能够更好的满足需求。在 Dubbo 中，SPI 是一个非常重要的模块。基于 SPI，我们可以很容易的对 Dubbo 进行拓展。如果大家想要学习 Dubbo 的源码，SPI 机制务必弄懂。接下来，我们先来了解一下 Java SPI 与 Dubbo SPI 的用法，然后再来分析 Dubbo SPI 的源码。



# 1、SPI 实例

## 1.1、Java SPI

### 1.1.1、接口**`Robot`**

```java
public interface Robot {

    void sayHello();

}
```



#### 1.1.1.1、实现类`OptimusPrime`

```java
@Slf4j
public class OptimusPrime implements Robot {

    @Override
    public void sayHello() {
      log.info("Hello, I am Optimus Prime.");
    }
}
```



#### 1.1.1.2、实现类`Bumblebee`

```java
@Slf4j
public class Bumblebee implements Robot {


    @Override
    public void sayHello() {
        log.info("Hello, I am Bumblebee.");
    }
}
```



### 1.1.2、 接口全限名配置文件

> resources -> META-INFO ->services 

```services
com.healerjean.proj.study.spi.OptimusPrime
com.healerjean.proj.study.spi.Bumblebee
```



![image-20200627155645060](/Users/healerjean/Desktop/Now/HealerJean.github.io/blogImages/image-20200627155645060.png)





### 1.1.3、Main方法测试

```java
@Slf4j
public class JavaSPITest {

    @Test
    public void sayHello() {
        ServiceLoader<Robot> serviceLoader = ServiceLoader.load(Robot.class);
        log.info("Java SPI--------");
        serviceLoader.forEach(Robot::sayHello);
    }
}
```



#### 1.1.3.1、控制台日志

```
2020-06-27 15:58:02 INFO  -[                                ]- Java SPI-------- com.healerjean.proj.study.spi.java.JavaSPITest.sayHello[21]
2020-06-27 15:58:02 INFO  -[                                ]- Hello, I am Optimus Prime. com.healerjean.proj.study.spi.OptimusPrime.sayHello[16]
2020-06-27 15:58:02 INFO  -[                                ]- Hello, I am Bumblebee. com.healerjean.proj.study.spi.Bumblebee.sayHello[17]
```



## 1.2、Dubbo SPI

> 继续使用上面的代码，对其进行改动一点点

### 1.2.1、接口添加注解`@SPI`

```java
@SPI
public interface Robot {

    void sayHello();

}
```



### 1.2.2、配置文件

> dubbo配置文件一般在dubbo文件夹中，但是其实通过后面的源码我们也可以知道，不一定非要在这个文件夹中，其他文件夹也是可以的

```
optimusPrime = com.healerjean.proj.study.spi.OptimusPrime
bumblebee = com.healerjean.proj.study.spi.Bumblebee
```

![image-20200627160249742](/Users/healerjean/Desktop/Now/HealerJean.github.io/blogImages/image-20200627160249742.png)





### 1.2.3、Main方法启测试

```java
@Slf4j
public class DubboSPITest {

    @Test
    public void sayHello()  {
        ExtensionLoader<Robot> extensionLoader =  ExtensionLoader.getExtensionLoader(Robot.class);

        log.info("dubbo SPI--------");
        log.info("----------------------------");
        log.info("从配置文件中获取--------");
        Robot optimusPrime = extensionLoader.getExtension("optimusPrime");
        optimusPrime.sayHello();
        Robot bumblebee = extensionLoader.getExtension("bumblebee");
        bumblebee.sayHello();
        log.info("----------------------------");

        log.info("{}", extensionLoader.getSupportedExtensions());


    }
```



#### 1.2.3.1、控制台日志

```
2020-06-27 16:04:19 INFO  -[                                ]- using logger: com.alibaba.dubbo.common.logger.slf4j.Slf4jLoggerAdapter com.alibaba.dubbo.common.logger.LoggerFactory.[]
2020-06-27 16:04:19 INFO  -[                                ]- dubbo SPI-------- com.healerjean.proj.study.spi.dubbo.DubboSPITest.sayHello[21]
2020-06-27 16:04:19 INFO  -[                                ]- ---------------------------- com.healerjean.proj.study.spi.dubbo.DubboSPITest.sayHello[22]
2020-06-27 16:04:19 INFO  -[                                ]- 从配置文件中获取-------- com.healerjean.proj.study.spi.dubbo.DubboSPITest.sayHello[23]
2020-06-27 16:04:20 INFO  -[                                ]- Hello, I am Optimus Prime. com.healerjean.proj.study.spi.OptimusPrime.sayHello[16]
2020-06-27 16:04:20 INFO  -[                                ]- Hello, I am Bumblebee. com.healerjean.proj.study.spi.Bumblebee.sayHello[17]
2020-06-27 16:04:20 INFO  -[                                ]- ---------------------------- com.healerjean.proj.study.spi.dubbo.DubboSPITest.sayHello[28]
2020-06-27 16:04:20 INFO  -[                                ]- ["bumblebee","optimusPrime"] com.healerjean.proj.study.spi.dubbo.DubboSPITest.sayHello[30]
```



# 2、SPI源码分析  

## 2.1、获取扩展点加载`ExtensionLoader`  

> 所有扩展必须加上`@SPI`注解才能通过`ExtensionLoader`加载。对于一个扩展点只会加载一次，生成一个`ExtensionLoader`。通过`ExtensionLoader.getExtensionLoader(class type)`传入一个`spi`扩展返回一个`ExtensionLoader`实例。
> 

```javav
ExtensionLoader<Robot> extensionLoader =  ExtensionLoader.getExtensionLoader(Robot.class);  
```



```java
// static 变量，所有的扩展点都只会加载一次，然后就会放到这里。相当于缓存，type为key的值，扩展点就是value
private static final ConcurrentMap<Class<?>, ExtensionLoader<?>> EXTENSION_LOADERS = new ConcurrentHashMap<Class<?>, ExtensionLoader<?>>();



@SuppressWarnings("unchecked")
public static <T> ExtensionLoader<T> getExtensionLoader(Class<T> type) {
  if (type == null)
    throw new IllegalArgumentException("Extension type == null");
  if (!type.isInterface()) {
    throw new IllegalArgumentException("Extension type(" + type + ") is not interface!");
  }

  //必须加SPI注解
  if (!withExtensionAnnotation(type)) {
    throw new IllegalArgumentException("Extension type(" + type +
                                       ") is not extension, because WITHOUT @" + SPI.class.getSimpleName() + " Annotation!");
  }

  //从缓存中取，如果缓存中没有 则，new一个扩展点加载
  ExtensionLoader<T> loader = (ExtensionLoader<T>) EXTENSION_LOADERS.get(type);
  if (loader == null) {
    //如果缓存中没有 则，new一个扩展点加载,并将它放到缓存中去，这个type，就是key的值
    EXTENSION_LOADERS.putIfAbsent(type, new ExtensionLoader<T>(type));
    loader = (ExtensionLoader<T>) EXTENSION_LOADERS.get(type);
  }
  return loader;
}



//验证 是否有@SPI注解
private static <T> boolean withExtensionAnnotation(Class<T> type) {
  return type.isAnnotationPresent(SPI.class);
}
```







> 首次进入的话，`type`是`Robot.class`肯定不等扩展点工厂，然后通过3元表达式可以看到，我们需要先获取扩展点工厂加载（`ExtensionFactory`）,，这样的话，扩展点工厂的属性`objectFactory`，就是null，而我们传入的`Robot.class`，中的属性`objectFactory`，则是通过扩展点工厂获取的适配扩展点工厂，     
>
> 接着我们看如果获取适配加载点，以及适配加载点是什么`getAdaptiveExtension()`   



```java

private final Class<?> type;
private final ExtensionFactory objectFactory;



private ExtensionLoader(Class<?> type) {
    this.type = type;
    objectFactory = (type == ExtensionFactory.class ? 
                     null : 
                     ExtensionLoader.getExtensionLoader(ExtensionFactory.class).getAdaptiveExtension());
}
```



### 2.1.2、获取适配扩展点  



> `Dubbo`中的扩展点均有多个实现，而框架设计原则又让我们针对接口编程而不是实现，这就需要在运行期才能决定具体使用哪个扩展实现类。Dubbo提供了Adpative注解，让我们自行决定究竟是自己提供扩展的适配还是由Dubbo来帮我们生成动态适配。后面会给出2个自定义扩展实现，一个是我们自定义适配，另一个是Dubbo提供动态适配。  



```
适配扩展点
adaptive=com.alibaba.dubbo.common.extension.factory.AdaptiveExtensionFactory
spi=com.alibaba.dubbo.common.extension.factory.SpiExtensionFactory
spring=com.alibaba.dubbo.config.spring.extension.SpringExtensionFactory
```



```java
@SPI
public interface ExtensionFactory {

    <T> T getExtension(Class<T> type, String name);

}
```



```java
@Adaptive
public class AdaptiveExtensionFactory implements ExtensionFactory {

    private final List<ExtensionFactory> factories;

    public AdaptiveExtensionFactory() {
        ExtensionLoader<ExtensionFactory> loader = ExtensionLoader.getExtensionLoader(ExtensionFactory.class);
        List<ExtensionFactory> list = new ArrayList<ExtensionFactory>();
        for (String name : loader.getSupportedExtensions()) {
            list.add(loader.getExtension(name));
        }
        factories = Collections.unmodifiableList(list);
    }

    @Override
    public <T> T getExtension(Class<T> type, String name) {
        for (ExtensionFactory factory : factories) {
            T extension = factory.getExtension(type, name);
            if (extension != null) {
                return extension;
            }
        }
        return null;
    }

}
```



```java
public class SpiExtensionFactory implements ExtensionFactory {

    @Override
    public <T> T getExtension(Class<T> type, String name) {
        if (type.isInterface() && type.isAnnotationPresent(SPI.class)) {
            ExtensionLoader<T> loader = ExtensionLoader.getExtensionLoader(type);
            if (!loader.getSupportedExtensions().isEmpty()) {
                return loader.getAdaptiveExtension();
            }
        }
        return null;
    }

}
```



```java
public class SpringExtensionFactory implements ExtensionFactory {

    private static final Set<ApplicationContext> contexts = new ConcurrentHashSet<ApplicationContext>();

    public static void addApplicationContext(ApplicationContext context) {
        contexts.add(context);
    }

    public static void removeApplicationContext(ApplicationContext context) {
        contexts.remove(context);
    }

    @Override
    @SuppressWarnings("unchecked")
    public <T> T getExtension(Class<T> type, String name) {
        for (ApplicationContext context : contexts) {
            if (context.containsBean(name)) {
                Object bean = context.getBean(name);
                if (type.isInstance(bean)) {
                    return (T) bean;
                }
            }
        }
        return null;
    }

}
```







```java
public class Holder<T> {

    private volatile T value;

    public void set(T value) {
        this.value = value;
    }

    public T get() {
        return value;
    }

}
```



```java
//当前对象中的缓存的适配扩展点
private final Holder<Object> cachedAdaptiveInstance = new Holder<Object>();


//获取适配扩展点，如果没有的话，就创建，然后放到当前对象的cachedAdaptiveInstance 中去
@SuppressWarnings("unchecked")
public T getAdaptiveExtension() {
  //从当前对象 的缓存属性，扩展点实例中获取一个适配扩展点
  Object instance = cachedAdaptiveInstance.get();
  if (instance == null) {
    if (createAdaptiveInstanceError == null) {
      synchronized (cachedAdaptiveInstance) {
        instance = cachedAdaptiveInstance.get();
        if (instance == null) {
          try {
            // 经过锁流程后还是没有的话，我们就要创建适配扩展点了，创建完成之后，放到当前对象的缓存适配属性cachedAdaptiveInstance中去
            instance = createAdaptiveExtension();
            cachedAdaptiveInstance.set(instance);
          } catch (Throwable t) {
            createAdaptiveInstanceError = t;
            throw new IllegalStateException("fail to create adaptive instance: " + t.toString(), t);
          }
        }
      }
    } else {
      throw new IllegalStateException("fail to create adaptive instance: " + createAdaptiveInstanceError.toString(), createAdaptiveInstanceError);
    }
  }

  return (T) instance;
}
```



#### 2.1.2.1、创建适配扩展点  

>  先执行getAdaptiveExtensionClass() 获取一个适配扩展点的calss对象之后，再通过反射实例化一个对象，然后再通过方能发，injectExtension对适配扩展点对象其中的属性进行注入

```java
//创建适配扩展点
@SuppressWarnings("unchecked")
private T createAdaptiveExtension() {
    try {
      // 先执行getAdaptiveExtensionClass() 获取一个适配扩展点的calss对象之后，再通过反射实例化一个对象，
      // 然后再通过方能发，injectExtension对适配扩展点对象其中的属性进行注入
        return injectExtension((T) getAdaptiveExtensionClass().newInstance());
    } catch (Exception e) {
        throw new IllegalStateException("Can not create adaptive extension " + type + ", cause: " + e.getMessage(), e);
    }
}
```





```java
//当发现扩展点类class的时候，这里就会赋值
private volatile Class<?> cachedAdaptiveClass = null;


private Class<?> getAdaptiveExtensionClass() {
  //获取所有的扩展点类class
  getExtensionClasses();
  //通过上面的一步正常情况下的话，cachedAdaptiveClass 适配扩展点类就存在了
  if (cachedAdaptiveClass != null) {
    return cachedAdaptiveClass;
  }
  return cachedAdaptiveClass = createAdaptiveExtensionClass();
}


//从当前对象的的属性  缓存类 中获取所有的扩展点（不包含适配扩展点哦，具体看下面loadExtensionClasses的代码）
private Map<String, Class<?>> getExtensionClasses() {
  Map<String, Class<?>> classes = cachedClasses.get();
  if (classes == null) {
    synchronized (cachedClasses) {
      classes = cachedClasses.get();
      if (classes == null) {
        //加载所所有的扩展点，加载完成之后放到当前对象的属性cachedClasses 中
        classes = loadExtensionClasses();
        cachedClasses.set(classes);
      }
    }
  }
  return classes;
}



private static final String SERVICES_DIRECTORY = "META-INF/services/";
private static final String DUBBO_DIRECTORY = "META-INF/dubbo/";
private static final String DUBBO_INTERNAL_DIRECTORY = DUBBO_DIRECTORY + "internal/";

// 加载扩展类class
private Map<String, Class<?>> loadExtensionClasses() {
  final SPI defaultAnnotation = type.getAnnotation(SPI.class);
  if (defaultAnnotation != null) {
    String value = defaultAnnotation.value();
    if ((value = value.trim()).length() > 0) {
      String[] names = NAME_SEPARATOR.split(value);
      if (names.length > 1) {
        throw new IllegalStateException("more than 1 default extension name on extension " + type.getName()
                                        + ": " + Arrays.toString(names));
      }
      if (names.length == 1) cachedDefaultName = names[0];
    }
  }

  //将来key就是  我们的配置文件中的name，value就是类。而下面这些变量就解释了我上面在啊实例中说的目录的问题，不一定是dubb文件夹中
  Map<String, Class<?>> extensionClasses = new HashMap<String, Class<?>>();
  loadDirectory(extensionClasses, DUBBO_INTERNAL_DIRECTORY);
  loadDirectory(extensionClasses, DUBBO_DIRECTORY);
  loadDirectory(extensionClasses, SERVICES_DIRECTORY);
  return extensionClasses;
}


private void loadDirectory(Map<String, Class<?>> extensionClasses, String dir) {
  String fileName = dir + type.getName();
  try {
    Enumeration<java.net.URL> urls;
    ClassLoader classLoader = findClassLoader();
    if (classLoader != null) {
      urls = classLoader.getResources(fileName);
    } else {
      urls = ClassLoader.getSystemResources(fileName);
    }
    if (urls != null) {
      while (urls.hasMoreElements()) {
        java.net.URL resourceURL = urls.nextElement();
        loadResource(extensionClasses, classLoader, resourceURL);
      }
    }
  } catch (Throwable t) {
    logger.error("Exception when load extension class(interface: " +
                 type + ", description file: " + fileName + ").", t);
  }
}

private void loadResource(Map<String, Class<?>> extensionClasses, ClassLoader classLoader, java.net.URL resourceURL) {
  try {
    BufferedReader reader = new BufferedReader(new InputStreamReader(resourceURL.openStream(), "utf-8"));
    try {
      String line;
      while ((line = reader.readLine()) != null) {
        final int ci = line.indexOf('#');
        if (ci >= 0) line = line.substring(0, ci);
        line = line.trim();
        if (line.length() > 0) {
          try {
            String name = null;
            int i = line.indexOf('=');
            if (i > 0) {
              name = line.substring(0, i).trim();
              line = line.substring(i + 1).trim();
            }
            if (line.length() > 0) {
              loadClass(extensionClasses, resourceURL, Class.forName(line, true, classLoader), name);
            }
          } catch (Throwable t) {
            IllegalStateException e = new IllegalStateException("Failed to load extension class(interface: " + type + ", class line: " + line + ") in " + resourceURL + ", cause: " + t.getMessage(), t);
            exceptions.put(line, e);
          }
        }
      }
    } finally {
      reader.close();
    }
  } catch (Throwable t) {
    logger.error("Exception when load extension class(interface: " +
                 type + ", class file: " + resourceURL + ") in " + resourceURL, t);
  }
}



private final ConcurrentMap<Class<?>, String> cachedNames = new ConcurrentHashMap<Class<?>, String>();

private final Holder<Map<String, Class<?>>> cachedClasses = new Holder<Map<String, Class<?>>>();


private void loadClass(Map<String, Class<?>> extensionClasses, java.net.URL resourceURL, Class<?> clazz, String name) throws NoSuchMethodException {
  if (!type.isAssignableFrom(clazz)) {
    throw new IllegalStateException("Error when load extension class(interface: " +
                                    type + ", class line: " + clazz.getName() + "), class "
                                    + clazz.getName() + "is not subtype of interface.");
  }
  
  //如果扩展点类上面的注解有 Adaptive ,则不会放到map中，而是给当前属性 cachedAdaptiveClass 赋值
  if (clazz.isAnnotationPresent(Adaptive.class)) {
    if (cachedAdaptiveClass == null) {
      cachedAdaptiveClass = clazz;
    } else if (!cachedAdaptiveClass.equals(clazz)) {
      throw new IllegalStateException("More than 1 adaptive class found: "
                                      + cachedAdaptiveClass.getClass().getName()
                                      + ", " + clazz.getClass().getName());
    }
  } else if (isWrapperClass(clazz)) {
    Set<Class<?>> wrappers = cachedWrapperClasses;
    if (wrappers == null) {
      cachedWrapperClasses = new ConcurrentHashSet<Class<?>>();
      wrappers = cachedWrapperClasses;
    }
    wrappers.add(clazz);
  } else {
    clazz.getConstructor();
    if (name == null || name.length() == 0) {
      name = findAnnotationName(clazz);
      if (name == null || name.length() == 0) {
        if (clazz.getSimpleName().length() > type.getSimpleName().length()
            && clazz.getSimpleName().endsWith(type.getSimpleName())) {
          name = clazz.getSimpleName().substring(0, clazz.getSimpleName().length() - type.getSimpleName().length()).toLowerCase();
        } else {
          throw new IllegalStateException("No such extension name for the class " + clazz.getName() + " in the config " + resourceURL);
        }
      }
    }
    String[] names = NAME_SEPARATOR.split(name);
    if (names != null && names.length > 0) {
      Activate activate = clazz.getAnnotation(Activate.class);
      if (activate != null) {
        cachedActivates.put(names[0], activate);
      }
      
      // 正常情况下，则 spi 和 spring的扩展点工厂类，会进入
      for (String n : names) {
        if (!cachedNames.containsKey(clazz)) {
          cachedNames.put(clazz, n);
        }
        Class<?> c = extensionClasses.get(n);
        if (c == null) {
          extensionClasses.put(n, clazz);
        } else if (c != clazz) {
          throw new IllegalStateException("Duplicate extension " + type.getName() + " name " + n + " on " + c.getName() + " and " + clazz.getName());
        }
      }
    }
  }
}
```







#### 2.1.2.2、扩展点通过反射进行实例化

```java
@SuppressWarnings("unchecked")
private T createAdaptiveExtension() {
    try {
        return injectExtension((T) getAdaptiveExtensionClass().newInstance());
    } catch (Exception e) {
        throw new IllegalStateException("Can not create adaptive extension " + type + ", cause: " + e.getMessage(), e);
    }
}
```





```java
@Adaptive
public class AdaptiveExtensionFactory implements ExtensionFactory {

    private final List<ExtensionFactory> factories;

    public AdaptiveExtensionFactory() {
       //执行这个的时候，静态缓存中已经有了扩展点工厂了
        ExtensionLoader<ExtensionFactory> loader = ExtensionLoader.getExtensionLoader(ExtensionFactory.class);
        List<ExtensionFactory> list = new ArrayList<ExtensionFactory>();
       // 当前实力缓存中已经有了扩展类的所有属性了,所以这里是从缓存中取出的
        for (String name : loader.getSupportedExtensions()) {
           //通过扩展点加载，加载所有的扩展点实现类，spi,spring
            list.add(loader.getExtension(name));
        }
        factories = Collections.unmodifiableList(list);
    }

    @Override
    public <T> T getExtension(Class<T> type, String name) {
        for (ExtensionFactory factory : factories) {
            T extension = factory.getExtension(type, name);
            if (extension != null) {
                return extension;
            }
        }
        return null;
    }

}
```



```java
//存放当前对象所有的扩展点实现实例
private final ConcurrentMap<String, Holder<Object>> cachedInstances = new ConcurrentHashMap<String, Holder<Object>>();


@SuppressWarnings("unchecked")
public T getExtension(String name) {
  if (name == null || name.length() == 0)
    throw new IllegalArgumentException("Extension name == null");
  if ("true".equals(name)) {
    return getDefaultExtension();
  }
  // 从当前对象的缓存实例中取
  Holder<Object> holder = cachedInstances.get(name);
  if (holder == null) {
    cachedInstances.putIfAbsent(name, new Holder<Object>());
    holder = cachedInstances.get(name);
  }
  Object instance = holder.get();
  if (instance == null) {
    synchronized (holder) {
      instance = holder.get();
      if (instance == null) {
        //获取不到则进行创建
        instance = createExtension(name);
        holder.set(instance);
      }
    }
  }
  return (T) instance;
}

// 扩展点实例所有实例的静态属性，缓存
private static final ConcurrentMap<Class<?>, Object> EXTENSION_INSTANCES = new ConcurrentHashMap<Class<?>, Object>();


private T createExtension(String name) {
  Class<?> clazz = getExtensionClasses().get(name);
  if (clazz == null) {
    throw findException(name);
  }
  try {
    //通过缓存中取，娶不到，就通过反射实例化
    T instance = (T) EXTENSION_INSTANCES.get(clazz);
    if (instance == null) {
      EXTENSION_INSTANCES.putIfAbsent(clazz, clazz.newInstance());
      instance = (T) EXTENSION_INSTANCES.get(clazz);
    }
    //对属性进行注入
    injectExtension(instance);
    Set<Class<?>> wrapperClasses = cachedWrapperClasses;
    if (wrapperClasses != null && !wrapperClasses.isEmpty()) {
      for (Class<?> wrapperClass : wrapperClasses) {
        instance = injectExtension((T) wrapperClass.getConstructor(type).newInstance(instance));
      }
    }
    return instance;
  } catch (Throwable t) {
    throw new IllegalStateException("Extension instance(name: " + name + ", class: " +
                                    type + ")  could not be instantiated: " + t.getMessage(), t);
  }
}




private T injectExtension(T instance) {
  try {
    if (objectFactory != null) {
      for (Method method : instance.getClass().getMethods()) {
        if (method.getName().startsWith("set")
            && method.getParameterTypes().length == 1
            && Modifier.isPublic(method.getModifiers())) {
          Class<?> pt = method.getParameterTypes()[0];
          try {
            String property = method.getName().length() > 3 ? method.getName().substring(3, 4).toLowerCase() + method.getName().substring(4) : "";
            Object object = objectFactory.getExtension(pt, property);
            if (object != null) {
              method.invoke(instance, object);
            }
          } catch (Exception e) {
            logger.error("fail to inject via method " + method.getName()
                         + " of interface " + type.getName() + ": " + e.getMessage(), e);
          }
        }
      }
    }
  } catch (Exception e) {
    logger.error(e.getMessage(), e);
  }
  return instance;
}
```





#### 2.1.2.2、扩展点进行属性注入  

> 如果是扩展点工厂进来了则，不会注入，因为其什么属性都没有

```java
private T injectExtension(T instance) {
  try {
    if (objectFactory != null) {
      for (Method method : instance.getClass().getMethods()) {
        if (method.getName().startsWith("set")
            && method.getParameterTypes().length == 1
            && Modifier.isPublic(method.getModifiers())) {
          Class<?> pt = method.getParameterTypes()[0];
          try {
            String property = method.getName().length() > 3 ? method.getName().substring(3, 4).toLowerCase() + method.getName().substring(4) : "";
            Object object = objectFactory.getExtension(pt, property);
            if (object != null) {
              method.invoke(instance, object);
            }
          } catch (Exception e) {
            logger.error("fail to inject via method " + method.getName()
                         + " of interface " + type.getName() + ": " + e.getMessage(), e);
          }
        }
      }
    }
  } catch (Exception e) {
    logger.error(e.getMessage(), e);
  }
  return instance;
}
```





















![author](https://raw.githubusercontent.com/HealerJean/HealerJean.github.io/master/assets/img/artical_bottom.jpg)





<link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">

<script src="https://unpkg.com/gitalk@latest/dist/gitalk.min.js"></script> 
<div id="gitalk-container"></div>    
 <script type="text/javascript">
    var gitalk = new Gitalk({
		clientID: `1d164cd85549874d0e3a`,
		clientSecret: `527c3d223d1e6608953e835b547061037d140355`,
		repo: `HealerJean.github.io`,
		owner: 'HealerJean',
		admin: ['HealerJean'],
		id: 'AAAAAAAAAAAAAAA',
    });
    gitalk.render('gitalk-container');
</script> 


