---

title: Topic持久化和非持久化
date: 2019-02-20 03:33:00
tags: 
- MQ
category: 
- MQ
description: Topic持久化和非持久化
---

<!-- 

https://raw.githubusercontent.com/HealerJean/HealerJean.github.io/master/blogImages/
　　首行缩进

<font  clalss="healerColor" color="red" size="5" >     </font>

<font  clalss="healerSize"  size="5" >     </font>
-->




## 前言

#### [博主github](https://github.com/HealerJean)
#### [博主个人博客http://blog.healerjean.com](http://HealerJean.github.io)    



## 1、非持久化的topic消息：

### 解释：必须接收方在线，这个不会帮我们保存



### 1.1、创建生产者

```java
package com.hlj.activemq.d02_topic持久化和非持久化.d01_非持久化;

import com.hlj.activemq.constants.ActiveMqConstant;
import org.apache.activemq.ActiveMQConnectionFactory;

import javax.jms.*;

public class NoPersistenceProducer {

    /**
     * 非持久化topic名称
     */
    public static final String TOPIC_NAME = "no_persiterce_topic_name";
    /**
     * 发送消息的数量
     */
    private static final int SEND_NUMBER = 5;

    public static void main(String[] args) {
        ConnectionFactory connectionFactory = new ActiveMQConnectionFactory(
                ActiveMqConstant.USERNAME,
                ActiveMqConstant.PASSWORD,
                ActiveMqConstant.BROKER_URL);
        try {
            Connection connection = connectionFactory.createConnection();
            connection.start();

            Session session = connection.createSession(
                    Boolean.TRUE,
                    Session.AUTO_ACKNOWLEDGE);

            Destination destination = session.createTopic(TOPIC_NAME);
            MessageProducer producer = session.createProducer(destination);


            for (int i = 0; i < SEND_NUMBER; i++) {
                TextMessage message = session.createTextMessage("message" + i);
                producer.send(message);
            }

            session.commit();
            session.close();
            connection.close();
        } catch (Exception e) {
            e.printStackTrace();
        }

    }
}

```



### 1.2、创建消费者

```java
package com.hlj.activemq.d02_topic持久化和非持久化.d01_非持久化;

import com.hlj.activemq.constants.ActiveMqConstant;
import org.apache.activemq.ActiveMQConnectionFactory;

import javax.jms.*;

public class NoPersistenceConsumer {

    /**
     * 非持久化topic名称
     */
    public static final String TOPIC_NAME = "no_persiterce_topic_name";
    public static final Long   WITE_TIME = (100L * 1000L);

    public static void main(String[] args) {

        ConnectionFactory connectionFactory = new ActiveMQConnectionFactory(
                ActiveMqConstant.USERNAME,
                ActiveMqConstant.PASSWORD,
                ActiveMqConstant.BROKER_URL);
        try {
            Connection connection = connectionFactory.createConnection();
            connection.start();

            Session session = connection.createSession(
                    Boolean.TRUE,
                    Session.AUTO_ACKNOWLEDGE);

            Destination destination = session.createTopic(TOPIC_NAME);
            MessageConsumer consumer = session.createConsumer(destination);
            Message message = consumer.receive();
            while (message != null) {
                TextMessage txtMsg = (TextMessage) message;
                System.out.println("收到消 息：" + txtMsg.getText());
                message = consumer.receive(WITE_TIME);
            }

            session.commit();
            session.close();
            connection.close();
        } catch (JMSException e) {
            e.printStackTrace();
        }
    }

}

```



### 1.3、运行生产者，不运行消费者



#### 1.1、观察浏览器  

![1566980589040](D:\study\HealerJean.github.io\blogImages\1566980589040.png)





**可以看到没有消费者在线，但是有3条消息已入队了**



| name                     | Number Of Consumers | Messages Enqueued | Messages Dequeued |
| ------------------------ | ------------------- | ----------------- | ----------------- |
| no_persiterce_topic_name | 0                   | 5                 | 0                 |



### 1.4、运行消费者 

#### 1.4.1、观察控制台 

发现控制台一直在等待，但是没有消息能够读取  



#### 1.4.2、观察浏览器

![1566980818525](D:\study\HealerJean.github.io\blogImages\1566980818525.png)



**消费者在线了，但是消息却没有出队列，因为我们这个非持久的消息必须是消费者在线**

| name                     | Number Of Consumers | Messages Enqueued | Messages Dequeued |
| ------------------------ | ------------------- | ----------------- | ----------------- |
| no_persiterce_topic_name | 1                   | 5                 | 0                 |



### 1.5、运行生产者 

说明：这个时候消费者是在线状态，等待消息的传入  ，这个时候运行生产者，观察消费者控制台 

#### 1.5.1、消费者控制台

```java
收到消 息：message0
收到消 息：message1
收到消 息：message2
收到消 息：message3
收到消 息：message4
```



#### 1.5.2、观察浏览器

![1566981177326](D:\study\HealerJean.github.io\blogImages\1566981177326.png)



**这个时候，入队的消息一共有5+5=10条，消费者读取到了5条**

| name                     | Number Of Consumers | Messages Enqueued | Messages Dequeued |
| ------------------------ | ------------------- | ----------------- | ----------------- |
| no_persiterce_topic_name | 0                   | 10                | 5                 |







## 2、持久化的topic消息 ：

### 解释：持久化的topic，即使还没有生产消息，但一般情况下邀请消费者提前订阅，因为这样，即使不在线，下次连接，也可以接受之前从没收过的消息，而已经收到的消息，则不会重复接受



### 2.1、创建生产者



```java
 MessageProducer producer = session.createProducer(topic);
//设置持久化
producer.setDeliveryMode(DeliveryMode.PERSISTENT);
//一定要砸在上面持久化订阅设置完成之后再start这个connection，否则会有问题
connection.start();
```



```java
package com.hlj.activemq.d02_topic持久化和非持久化.D02_持久化;

import com.hlj.activemq.constants.ActiveMqConstant;
import org.apache.activemq.ActiveMQConnectionFactory;

import javax.jms.*;

public class PersistenceProducer {


    public static final String TOPIC_NAME = "persiterce_topic_name";
    /**
     * 发送消息的数量
     */
    private static final int SEND_NUMBER = 5;

    public static void main(String[] args) {

        ConnectionFactory connectionFactory = new ActiveMQConnectionFactory(
                ActiveMqConstant.USERNAME,
                ActiveMqConstant.PASSWORD,
                ActiveMqConstant.BROKER_URL);
        try {
            Connection connection = connectionFactory.createConnection();

            Session session = connection.createSession(
                    Boolean.TRUE,
                    Session.AUTO_ACKNOWLEDGE);

            Topic topic = session.createTopic(TOPIC_NAME);
            MessageProducer producer = session.createProducer(topic);
            //设置持久化
            producer.setDeliveryMode(DeliveryMode.PERSISTENT);
            //一定要砸在上面持久化订阅设置完成之后再start这个connection，否则会有问题
            connection.start();
            System.out.println("创建持久化生产者");

            for (int i = 1; i <= SEND_NUMBER; i++) {
                TextMessage message = session.createTextMessage("message" + i);
                producer.send(message);
            }

            session.commit();
            session.close();
            connection.close();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}


```



### 2.2、创建消费订阅者  name



```java
//设置连接客户端 id
connection.setClientID("HealerJean");
            
Topic topic = session.createTopic(TOPIC_NAME);
//创建持久化的订阅者，订阅者的名称 name
TopicSubscriber consumer = session.createDurableSubscriber(topic, "name");  
//一定要砸在上面持久化订阅设置（createDurableSubscriber）完成之后再start这个connection，否则会有问题
connection.start();
```



```java
package com.hlj.activemq.d02_topic持久化和非持久化.D02_持久化;

import com.hlj.activemq.constants.ActiveMqConstant;
import org.apache.activemq.ActiveMQConnectionFactory;

import javax.jms.*;

public class PersistenceConsumer {

    public static final String TOPIC_NAME = "persiterce_topic_name";
    public static final Long WITE_TIME = (1000L);


    public static void main(String[] args) {

        ConnectionFactory connectionFactory = new ActiveMQConnectionFactory(
                ActiveMqConstant.USERNAME,
                ActiveMqConstant.PASSWORD,
                ActiveMqConstant.BROKER_URL);
        try {
            Connection connection = connectionFactory.createConnection();
            //设置连接客户端 id
            connection.setClientID("HealerJean");


            Session session = connection.createSession(
                    Boolean.TRUE,
                    Session.AUTO_ACKNOWLEDGE);

            Topic topic = session.createTopic(TOPIC_NAME);
            //创建持久化的订阅者，订阅者的名称 name
            TopicSubscriber consumer = session.createDurableSubscriber(topic, "name");
            //一定要砸在上面持久化订阅设置（createDurableSubscriber）完成之后再start这个connection，否则会有问题
            connection.start();
            System.out.println("创建持久化消费者");

            Message message = consumer.receive();
            while (message != null) {
                TextMessage txtMsg = (TextMessage) message;
                System.out.println("收到消 息：" + txtMsg.getText());
                message = consumer.receive(WITE_TIME);
            }
            session.commit();
            session.close();
            connection.close();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

}


```



### 2.3、运行消费订阅者 name （这个时候消费者一直在等待消息哦）

#### 2.3.1、观察浏览器



+ **有一个订阅者出现了**

![1566984898908](D:\study\HealerJean.github.io\blogImages\1566984898908.png)



+ **即使没有发布消息，但是实际上我们已经将topic创建出来了**

![1566987970895](D:\study\HealerJean.github.io\blogImages\1566987970895.png)



### 2.4、断开消费订阅者name 控制台，观察浏览器，消费者离线了哦

会观察到，这个时候这个订阅者跑到了未在线里面去了

![1566984956078](D:\study\HealerJean.github.io\blogImages\1566984956078.png)



### 2.5、运行生产者

#### 2.5.1、观察浏览器



![1566985072703](D:\study\HealerJean.github.io\blogImages\1566985072703.png)



会观察到有一个消费者，但是事实上我们的订阅消费者已经挂掉了，不是么，上面消费者控制台都关闭了，虽然控制台关闭了，但是其实我这里认为是一个离线状态的订阅消费者。而且计算它了

| name                  | Number Of Consumers | Messages Enqueued | Messages Dequeued |
| --------------------- | ------------------- | ----------------- | ----------------- |
| persiterce_topic_name | 1                   | 5                 | 0                 |





### 2.6、修改消费者name代码，再创建一个消费订阅者name2



只讲name修改为name2，然后运行即可

```java
TopicSubscriber consumer = session.createDurableSubscriber(topic, "name2");
```



**观察控制台，会发现没有消息接收到，因为我一开始也其实说了，人家发布消息之前你还没来呢**





### 2.6、运行消费者name

#### 2.6.1、观察控制台

```java
创建持久化消费者
17:39:48.841 [main] DEBUG org.apache.activemq.TransactionContext - Begin:TX:ID:MI-201902210704-50981-1566985188565-1:1:1
收到消 息：message1
收到消 息：message2
收到消 息：message3
收到消 息：message4
收到消 息：message5
```



#### 2.6.2、观察浏览器



![1566988235828](D:\study\HealerJean.github.io\blogImages\1566988235828.png)





**会发现有2个消费者,5条入队的消息，5条被消费者消费出队的消息，**    

**这里强调一点的是，其实我们这5条出队消息真正意义上只是提示消费者接受了几条消息，而不是真正的出队。因为持久化的topic 如果有两个消费者同时在线的话，出队消息的数量 =消息数量*2。并不等于入队的消息数量**   

**不信，往下看** 



| name                  | Number Of Consumers | Messages Enqueued | Messages Dequeued |
| --------------------- | ------------------- | ----------------- | ----------------- |
| persiterce_topic_name | 2                   | 5                 | 5                 |



### 2.7、再次运行生产者

#### 2.7.1、观察控制台

![1566988589022](D:\study\HealerJean.github.io\blogImages\1566988589022.png)



没毛病，消费者不在线，肯定不能消费消息，所以入队信息为10

| name                  | Number Of Consumers | Messages Enqueued | Messages Dequeued |
| --------------------- | ------------------- | ----------------- | ----------------- |
| persiterce_topic_name | 2                   | 10                | 5                 |





### 2.8、运行消费者 name

讲代码中name2变成name即可

#### 2.8.1、观察控制台 

出现了消息，因为之前订阅过了

```
收到消 息：message1
收到消 息：message2
收到消 息：message3
收到消 息：message4
收到消 息：message5
```



#### 2.8.2、观察浏览器

![1566988839373](D:\study\HealerJean.github.io\blogImages\1566988839373.png)





| name                  | Number Of Consumers | Messages Enqueued | Messages Dequeued |
| --------------------- | ------------------- | ----------------- | ----------------- |
| persiterce_topic_name | 2                   | 10                |                   10|





### 2.9、运行消费者 name2

讲代码中name改为name

#### 2.9.1、 观察控制台

出现了消息，因为之前订阅过了

```
收到消 息：message1
收到消 息：message2
收到消 息：message3
收到消 息：message4
收到消 息：message5
```



#### 2.9.2、观察浏览器



![1566988953065](D:\study\HealerJean.github.io\blogImages\1566988953065.png)

| name                  | Number Of Consumers | Messages Enqueued | Messages Dequeued |
| --------------------- | ------------------- | ----------------- | ----------------- |
| persiterce_topic_name | 2                   | 10                | 15                |



### 3.0、总结2.8和2.9

这样就证明了2.6.2中的说法是正确的。







<font  color="red" size="5" >     
感兴趣的，欢迎添加博主微信
 </font>       

   



哈，博主很乐意和各路好友交流，如果满意，请打赏博主任意金额，感兴趣的在微信转账的时候，备注您的微信或者其他联系方式。添加博主微信哦。    

请下方留言吧。可与博主自由讨论哦

|微信 | 微信公众号|支付宝|
|:-------:|:-------:|:------:|
| ![微信](https://raw.githubusercontent.com/HealerJean/HealerJean.github.io/master/assets/img/tctip/weixin.jpg)|![微信公众号](https://raw.githubusercontent.com/HealerJean/HealerJean.github.io/master/assets/img/my/qrcode_for_gh_a23c07a2da9e_258.jpg)|![支付宝](https://raw.githubusercontent.com/HealerJean/HealerJean.github.io/master/assets/img/tctip/alpay.jpg) |



<link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">

<script src="https://unpkg.com/gitalk@latest/dist/gitalk.min.js"></script> 
<div id="gitalk-container"></div>    
 <script type="text/javascript">
    var gitalk = new Gitalk({
		clientID: `1d164cd85549874d0e3a`,
		clientSecret: `527c3d223d1e6608953e835b547061037d140355`,
		repo: `HealerJean.github.io`,
		owner: 'HealerJean',
		admin: ['HealerJean'],
		id: 'goWcq6xGLCHEF4O7',
    });
    gitalk.render('gitalk-container');
</script> 

