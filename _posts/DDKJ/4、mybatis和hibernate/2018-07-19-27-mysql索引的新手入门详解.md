---
title: mysql索引的新手入门详解
date: 2018-07-19 03:33:00
tags: 
- Database
category: 
- Database
description: mysql索引的新手入门详解
---
<!-- image url 
https://raw.githubusercontent.com/HealerJean123/HealerJean123.github.io/master/blogImages
　　首行缩进
<font color="red">  </font>
-->

## 前言

如果是小白的话，我觉得看到这篇文章一定会对博主赞赏有加，因为实在是太好了，没错，博主就是要让你喜欢上。

## 1、索引
索引是表的目录，在查找内容之前可以先在目录中查找索引位置，以此快速定位查询数据。对于索引，会保存在额外的文件中。
2、索引，是数据库中专门用于帮助用户快速查询数据的一种数据结构。类似于字典中的目录，查找字典内容时可以根据目录查找到数据的存放位置，然后直接获取即可。

## 2、索引优缺点
#### 2.1、优点

索引由数据库中一列或多列组合而成，其作用是提高对表中数据的查询速度 索引的优点是可以提高检索数据的速度
#### 2.2、缺点
 索引的缺点是创建和维护索引需要耗费时间
索引可以提高查询速度，会减慢写入速度

## 3、索引分类


### 1.普通索引，<font color="red">仅加速查询  </font>
### 2.唯一索引，<font color="red">加速查询 + 列值唯一（可以有null）</font>
### 3.全文索引，<font color="red">对文本的内容进行分词，进行搜索</font>
### 4.单列索引，<font color="red"></font>
### 5.多列索引，<font color="red"></font>
### 6.空间索引，<font color="red"></font>
### 7.主键索引，<font color="red">加速查询 + 列值唯一 +　表中只有一个（不可以有null）</font>
### 8.组合索引，<font color="red">多列值组成一个索引，专门用于组合搜索，其效率大于索引合并，</font>


索引合并，使用多个单列索引组合搜索 覆盖索引，select的数据列只用从索引中就能够取得，不必读取数据行，换句话说查询列要被所建的索引覆盖


## 1、普通索引

### 1.1.1、创建表的时候同事创建索引


```
create table healerjean (
  id   bigint(20)  NOT NULL AUTO_INCREMENT PRIMARY KEY COMMENT  '主键',
  name  VARCHAR(32) NOT NULL COMMENT '姓名',
  email VARCHAR(64) NOT NULL COMMENT  '邮箱',
  message text DEFAULT  NULL COMMENT '个人信息',
  INDEX index_name (name) COMMENT '索引name'
) COMMENT  = '索引测试表';

```

### 1.1.2、在存在的表上创建索引

```
create index index_name on healerjean(name)

```
### 1.1.3、注意：
<font color="red">对于创建索引时如果是blob 和 text 类型，必须指定length。
 </font>
```
create index ix_extra on in1(message(200));

```

### 1.2、删除索引


```
drop index_name on healerjean;

```

### 1.3、查看索引

这个时候，我们会发现其实主键id也是一个索引
```
show index from healerjean;

```

![WX20180727-155546](https://raw.githubusercontent.com/HealerJean123/HealerJean123.github.io/master/blogImages/WX20180727-155546.png)


## 2、主键索引 （我们一般都会提供主键的，默认主键就是索引）



## 3、正确使用索引

文章相当出色，请查看。主要是看explain 中出现的row有有多少行，行数越多，表示执行速度越慢

[https://www.cnblogs.com/Cheney222/articles/5876382.html](https://www.cnblogs.com/Cheney222/articles/5876382.html)


### <font color="red">如果以错误的方式使用，则即使建立索引也会不奏效。
 </font>



### 3.1、对于创建的<font color="red">多列索引,只要查询的条件中用到了最左边的列,索引一般就会被使用</font>


1、首先按 company_id,moneys 的顺序创建一个复合索引,具体如下:
```
mysql> create index ind_sales2_companyid_moneys on sales2(company_id,moneys);
Query OK, 1000 rows affected (0.03 sec)
Records: 1000 Duplicates: 0 Warnings: 0
 
```
2、然后按 company_id 进行表查询,具体如下:
```
mysql> explain select * from sales2 where company_id = 2006\G;
*************************** 1. row ***************************
id: 1
select_type: SIMPLE
table: sales2
type: ref
possible_keys: ind_sales2_companyid_moneys
208key: ind_sales2_companyid_moneys
key_len: 5
ref: const
rows: 1
Extra: Using where
1 row in set (0.00 sec)
 
```
3、可以发现即便 where 条件中不是用的 company_id 与 moneys 的组合条件,索引仍然能用到,这就是索引的前缀特性。<br/>

4、但是如果只按 moneys 条件查询表,那么索引就不会被用到,具体如下:
```

mysql> explain select * from sales2 where moneys = 1\G;
*************************** 1. row ***************************
id: 1
select_type: SIMPLE
table: sales2
type: ALL
possible_keys: NULL
key: NULL
key_len: NULL
ref: NULL
rows: 1000
Extra: Using where
1 row in set (0.00 sec)

```


### 3.2、对于使用 like 的查询,后面如果是<font color="red">常量</font>并且只有%号不在第一个字符,索引才可能会被使用：

1、 可以发现第一个例子没有使用索引,而第二例子就能够使用索引,
2、 区别就在于“%”的位置不同,前者把“%”放到第一位就不能用到索引,而后者没有放到第一位就使用了索引。

```
mysql> explain select * from company2 where name like '%3'\G;
*************************** 1. row ***************************
id: 1
select_type: SIMPLE
table: company2
type: ALL
possible_keys: NULL
key: NULL
key_len: NULL
ref: NULL
rows: 1000
Extra: Using where
1 row in set (0.00 sec)
 
```

```
 
mysql> explain select * from company2 where name like '3%'\G;
*************************** 1. row ***************************
id: 1
select_type: SIMPLE
table: company2
type: range
209possible_keys: ind_company2_name
key: ind_company2_name
key_len: 11
ref: NULL
rows: 103
Extra: Using where
1 row in set (0.00 sec)

```

### 3.3、如果列名是索引,使用 column_name is null 将使用索引。


```
mysql> explain select * from company2 where name is null\G;
*************************** 1. row ***************************
id: 1
select_type: SIMPLE
table: company2
type: ref
possible_keys: ind_company2_name
key: ind_company2_name
key_len: 11
ref: const
rows: 1
Extra: Using where
1 row in set (0.00 sec)

```

### 3.4、如果对大的文本进行搜索,使用全文索引而不用使用 like ‘%...%’。


## 4、存在索引，但是不使用

### 4.1、如果 MySQL 估计使用索引比全表扫描更慢,则不使用索引。例如，如果列key_part1 均匀分布在 1 和 100 之间,下列查询中使用索引就不是很好:

```
SELECT * FROM table_name where key_part1 > 1 and key_part1 < 90;

```


### 4.2、如果使用 MEMORY/HEAP 表并且 where 条件中不使用“=”进行索引列,那么不会用到索引。heap 表只有在“=”的条件下才会使用索引。

### 4.3、用 or 分割开的条件,如果 or 前的条件中的列有索引,而后面的列中没有索引,那么涉及到的索引都不会被用到,例如:，必须or前后都有索引才能被使用

```
mysql> show index from sales\G;
*************************** 1. row ***************************
Table: sales
Non_unique: 1
Key_name: ind_sales_year
Seq_in_index: 1
Column_name: year
210Collation: A
Cardinality: NULL
Sub_part: NULL
Packed: NULL
Null:
Index_type: BTREE
Comment:
1 row in set (0.00 sec)

```


### 4.4、如果列是字符型，，传入的是数字，则不上‘’不会使用索引

```
mysql> explain select * from company2 where name = 294\G;
*************************** 1. row ***************************
id: 1
select_type: SIMPLE
table: company2
type: ALL
possible_keys: ind_company2_name
key: NULL
key_len: NULL
ref: NULL
rows: 1000
Extra: Using where
1 row in set (0.00 sec)
 
 
mysql> explain select * from company2 where name = '294'\G;
*************************** 1. row ***************************
id: 1
select_type: SIMPLE
table: company2
type: ref
possible_keys: ind_company2_name
key: ind_company2_name
key_len: 23
ref: const
rows: 1
Extra: Using where
1 row in set (0.00 sec)

```


## 5、执行计划

explain + 查询SQL – 用于显示SQL执行信息参数，根据参考信息可以进行SQL优化

![WX20180727-181745](https://raw.githubusercontent.com/HealerJean123/HealerJean123.github.io/master/blogImages/WX20180727-181745.png)

#### 1、id,查询顺序标识
#### 2、select_type,查询类型

```
SIMPLE          简单查询
PRIMARY         最外层查询
SUBQUERY        映射为子查询
DERIVED         子查询
UNION           联合
UNION RESULT    使用联合的结果
```

#### 3、type 查询时的访问方式



```
性能：all < index < range < index_merge < ref_or_null < ref < eq_ref < system/const
	
	
1、ALL、全表扫描，对于数据表从头到尾找一遍  select * from tb1;特别的：如果有limit限制，则找到之后就不在继续向下扫描
	select * from tb1 where email = 'seven@live.com'
	select * from tb1 where email = 'seven@live.com' limit 1;
	虽然上述两个语句都会进行全表扫描，第二句使用了limit，则找到一个后就不再继续扫描。
2、INDEX 、全索引扫描，对索引从头到尾找一遍
	select nid from tb1;
	
3、RANGE 、对索引列进行范围查找
	select *  from tb1 where name < 'alex';
	PS:
	between and
	in
	>   >=  <   <=  操作
	注意：!= 和 > 符号
	
4、INDEX_MERGE、合并索引，使用多个单列索引搜索
	select *  from tb1 where name = 'alex' or nid in (11,22,33);
	
5、REF、根据索引查找一个或多个值
	select * from tb1 where name = 'seven';
	
6、EQ_REF、连接时使用primary key 或 unique类型
	select tb2.nid,tb1.name from tb2 left join tb1 on tb2.nid = tb1.nid;
	
7、CONST、常量
	表最多有一个匹配行,因为仅有一行,在这行的列值可被优化器剩余部分认为是常数,const表很快,因为它们只读取一次。
	select nid from tb1 where nid = 2 ;
	
8、SYSTEM          系统
	表仅有一行(=系统表)。这是const联接类型的一个特例。
	select * from (select nid from tb1 where nid = 1) as A;

```

#### 4、possible_keys、可能使用的索引  
#### 5、key_len、MySQL中使用索引字节长度

#### 6、rows、mysql估计为了找到所需的行而要读取的行数 ------ 只是预估值


#### 7、extra、该列包含MySQL解决查询的详细信息


```

1、“Using index”
	此值表示mysql将使用覆盖索引，以避免访问表。不要把覆盖索引和index访问类型弄混了。
	
2、“Using where”
	这意味着mysql服务器将在存储引擎检索行后再进行过滤，许多where条件里涉及索引中的列，当（并且如果）它读取索引时，就能被存储引擎检验，因此不是所有带where子句的查询都会显示“Using where”。有时“Using where”的出现就是一个暗示：查询可受益于不同的索引。
	
3、“Using temporary”
	这意味着mysql在对查询结果排序时会使用一个临时表。
	
4、“Using filesort”
	这意味着mysql会对结果使用一个外部索引排序，而不是按索引次序从表里读取行。mysql有两种文件排序算法，这两种排序方式都可以在内存或者磁盘上完成，explain不会告诉你mysql将使用哪一种文件排序，也不会告诉你排序会在内存里还是磁盘上完成。
	
5、“Range checked for each record(index map: N)”
	这个意味着没有好用的索引，新的索引将在联接的每一行上重新估算，N是显示在possible_keys列中索引的位图，并且是冗余的。

```





<br/><br/><br/>
如果满意，请打赏博主任意金额，感兴趣的在微信转账的时候，添加博主微信哦， 请下方留言吧。可与博主自由讨论哦

|支付包 | 微信|微信公众号|
|:-------:|:-------:|:------:|
|![支付宝](https://raw.githubusercontent.com/HealerJean123/HealerJean123.github.io/master/assets/img/tctip/alpay.jpg) | ![微信](https://raw.githubusercontent.com/HealerJean123/HealerJean123.github.io/master/assets/img/tctip/weixin.jpg)|![微信公众号](https://raw.githubusercontent.com/HealerJean123/HealerJean123.github.io/master/assets/img/my/qrcode_for_gh_a23c07a2da9e_258.jpg)|




<!-- Gitalk 评论 start  -->

<link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk@latest/dist/gitalk.min.js"></script> 
<div id="gitalk-container"></div>    
 <script type="text/javascript">
    var gitalk = new Gitalk({
		clientID: `1d164cd85549874d0e3a`,
		clientSecret: `527c3d223d1e6608953e835b547061037d140355`,
		repo: `HealerJean123.github.io`,
		owner: 'HealerJean123',
		admin: ['HealerJean123'],
		id: '1dv6t962CQpD2HWt',
    });
    gitalk.render('gitalk-container');
</script> 

<!-- Gitalk end -->

