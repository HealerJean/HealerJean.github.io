---
title: Mysql数据库表结构以及字段设计.md
date: 2019-04-25 03:33:00
tags: 
- Database
category: 
- Database
description: Mysql数据库表结构以及字段设计.md
---

<!-- 

https://raw.githubusercontent.com/HealerJean/HealerJean.github.io/master/blogImages\
　　首行缩进

<font  clalss="healerColor" color="red" size="5" >     </font>

<font  clalss="healerSize"  size="5" >     </font>
-->




## 前言

#### [博主github](https://github.com/HealerJean)
#### [博主个人博客http://blog.healerjean.com](http://HealerJean.github.io)    



```
create table test
(
  `id`        bigint(20) unsigned not null auto_increment comment '主键',
  uk_name     bigint(20) unsigned not null comment 'uk',
  idx_name    bigint(20) unsigned not null comment 'idx',
  ref_item_id  bigint(20) unsigned not null comment 'item表主键',
    status      varchar(32)         not null comment '产品状态 字典表 productstatus',
  create_user bigint(20) unsigned null     default 0 comment '创建人',
  create_name varchar(64)         null     default '' comment '创建人名称',
  create_time datetime            not null default current_timestamp comment '创建时间',
  update_user bigint(20) unsigned null     default 0 comment '更新人',
  update_name varchar(64)         null     default '' comment '更新人名称',
  update_time datetime            not null default current_timestamp on update current_timestamp comment '更新时间',
  unique index uk_name (uk_name) using btree comment '唯一索引',
  index idx_name (idx_name) using btree comment '索引',
  primary key (`id`) using btree
) engine = innodb comment '测试表'



```

| 类型    | 名称           | 长度             | 解释         |
| ------- | -------------- | ---------------- | ------------ |
| bigint  | 主键           | bigint(20)       |              |
| varchar | 地址           | varchar(128)     |              |
| varchar | 状态           | varchar(8)       |              |
| varchar | 附件，逗号相隔 | varchar(128)     |              |
| varchar | 备注、描述     | varchar(128/256) |              |
| varchar | 手机号         | varchar(20)      |              |
| varchar | 名字           | varchar(64)      |              |
| varchar | 邮件           | varchar(64)      |              |
| decimal | 金额           | decimal(20,0)    | 以分为单位   |
| decimal | 百分比         | decimal(7,6)     | 80% 0.800000 |
| int     | 数字           | int(10)          |              |
| tinyint | 布尔           | tinyint(1)       |              |

## 基础规范

#### 1、基础规范

+ MySQL字符集统一使用utf8，默认排序规则：utf8_general_ci 

+  使用InnoDB存储引擎，默认事务隔离级别REPEATABLE-READ(可重复读)

+  不要使用MySQL存储过程，视图，触发器，Event, InnoDB外键约束

+ 每个数据表都添加注释 comment, 每个字段也添加comment

+ 不要在数据库中存储大图片或大文件，尽量使用简单的数据类型，避免使用blob和text类型

+ 单表数据量控制在1000W行以内 ，采用合适的分库分表策略，例如十库百表

  

#### 2、字段设计

+ 表示状态字段（0-255）的使用TINYINT UNSINGED ; 0避免成为有效状态值，非负的数字类型字段，都添加上UNSINGED,
+ 时间字段使用时间日期类型，避免使用字符串类型存储，日期使用DATE类型，年使用YEAR类型，日期时间可使用DATETIME和TIMESTAMP
+ 字符串VARCHAR(N), 其中N表示字符个数，请尽量减少N的大小
+ 字段都设置为NOT NULL， 为字段提供默认值，如’’和’0’ ; 

+ 主键尽量保持增长趋势，建议使用id的生成器，避免使用表的自增列



#### 3、sql使用规范

+ 避免使用join，子查询等SQL

```
1.对于mysql，不推荐使用子查询和join是因为本身join的效率就是硬伤，一旦数据量很大效率就很难保证，强烈推荐分别根据索引单表取数据，然后在程序里面做join，merge数据，导致性能下降

2.子查询就更别用了，效率太差，执行子查询时，MYSQL需要创建临时表，查询完毕后再删除这些临时表，所以，子查询的速度会受到一定的影响，这里多了一个创建和销毁临时表的过程。

3.如果是JOIN的话，它是走嵌套查询的。小表驱动大表，且通过索引字段进行关联。如果表记录比较少的话，还是OK的。大的话业务逻辑中可以控制处理
```

+ 在线业务的update和delete的where中是唯一索引或者主键，避免一次修改多条语句的情况，而且这样锁住的是一行数据
+ 避免在MySQL数据库中进行计算操作，尽量由业务来处理运算，数据库，就应该让它做存储数据，查询数据的事情，

+ 避免使用select * , 只返回自己需要的字段，枚举出要返回的字段名称
+ SQL过滤的where条件尽量不使用OR, NOT IN , NOT EXIST
+ 使用where IN()过滤时，IN集合个数必须小于500，因为in的数据少的时候，mysql优化器会可能会使用索引，但是当数据太多以后就不一定了，可以让MySQL按照ID顺序进行查询，这可能比随机的关联要更高效






### 1、表名设计

尽量使用 项目名_模块名_表名   

原因：     
项目名，因为我们可能一个数据库对应多个项目，这样容易区分   
模块名，能够清晰明了的知道是哪个模块的表

### 2、字段名设计

使用下划线，不要使用大小写组合，原因自己理解吧，兄弟     

### 3、字段设计



### 3.0、类型长度

#### 3.0.1、数字型

| 类型        | 字节                | 范围（有符号）                                               | 范围（无符号）                                               | 用途            |
| ----------- | ------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | --------------- |
| tintint     | 1                   | (-128，127)                                                  | (0，255)                                                     | 小整数值        |
| smallint    | 2                   | (-32 768，32 767)                                            | (0，65 535)                                                  | 大整数值        |
| mediumint   | 3                   | (-8 388 608，8 388 607)                                      | (0，16 777 215)                                              | 大整数值        |
| int/integer | 4                   | (-2 147 483 648，2 147 483 647)                              | (0，4 294 967 295)                                           | 大整数值        |
| bigint      | 8                   | (-9 233 372 036 854 775 808，9 223 372 036 854 775 807)      | (0，18 446 744 073 709 551 615)                              | 极大整数值      |
| float       | 4                   | (-3.402 823 466 E+38，1.175 494 351 E-38)，0，(1.175 494 351 E-38，3.402 823 466 351 E+38) | 0，(1.175 494 351 E-38，3.402 823 466 E+38)                  | 单精度/浮点数值 |
| double      | 8                   | (1.797 693 134 862 315 7 E+308，2.225 073 858 507 201 4 E-308)，0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308) | 0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308) | 双精度/浮点数值 |
| decimal     | M>D，为M+2否则为D+2 | decimal(M,D)依赖于M和D的值                                   | 依赖于M和D的值                                               | 小数值          |



#### 3.0.2、字符类型



| 类型       | 字节                   | 用途                            |
| ---------- | ---------------------- | ------------------------------- |
| char       | 0-255字节              | 变长字符串                      |
| varchar    | 0-255字节              | 变长字符串                      |
| tinyblog   | 0-255字节              | 不超过 255 个字符的二进制字符串 |
| tinytext   | 0-255字节              | 短文本字符串                    |
| blog       | 0-65 535字节           | 二进制形式的长文本数据          |
| text       | 0-65 535字节           | 长文本数据                      |
| mediumblog | 0-16 777 215字节 16M   | 二进制形式的中等长度文本数据    |
| mediumtext | 0-16 777 215字节 16M   | 中等长度文本数据                |
| longblog   | 0-4 294 967 295字节 4G | 二进制形式的极大文本数据        |
| longtext   | 0-4 294 967 295字节 4G | 极大文本数据                    |



#### 3.0.3、时间类型



| 类型      | 字节 | 取值范围                                 |                     | 用途                     |
| --------- | ---- | ---------------------------------------- | ------------------- | ------------------------ |
| year      | 1    | 1901——2155                               | YYYY                | 日期值                   |
| date      | 4    | 1000-01-01——9999-12-31                   | YYYY-MM-DD          | 时间值或持续时间         |
| time      | 3    | -838:59:59——838:59:59                    | HH:MM:SS            | 年份值                   |
| datetime  | 8    | 1000-01-01 00:00:00——9999-12-31 23:59:59 | YYYY-MM-DD HH:MM:SS | 混合日期和时间值         |
| timestamp | 4    | 19700101080001——20380119111407           | YYYYMMDD HHMMSSsss  | 混合日期和时间值，时间戳 |





#### 设计原则

##### 1、字段尽量不能设置null，这样不方便建立索引，为了防止为null，我们可以给赋予初始值，今后建议 default '',给一个空串，空串不占内存空间，NULL是占内存空间的

##### 2、实体设计的时候，记得给初始值,防止不能直接插入数据库中数据

```java
private BigDecimal totalBalance = BigDecimal.ZERO
```



#### 3.1、日期设计

**JDBC映射**

**LocalTime** 对应 **time **只包括时间

**LocalDate** 对应 **date ** 只包括日期

**LocalDateTime** 对应 **timestamp datetime  **包括日期和时间

```java



timestamp 多个日期，如果可能为空，则建议使用datetime（默认值建议设置为）
0001-01-01 00:00:00，因为0000-00-00 00:00:00mysql不能保存，而且会报错，

普通字段不要设置为timestamp，timestamp列必须有默认值，默认值可以为“0000-00-00 00:00:00”，但不能为null。如果我们在save实体的时候，没有给相关timestamp设置值，那么他就会自动由mysql将当前时间设置进去


@Temporal(TemporalType.TIMESTAMP)
@Column(insertable = true,updatable = false)
@ApiModelProperty(hidden = true)
private Date cdate;

@UpdateTimestamp
@Temporal(TemporalType.TIMESTAMP)
@ApiModelProperty(hidden = true)
private Date udate;


```



#### 3.2、小数数字设计 decimall



```java
mysql中的decimal字段，声明语法为DECIMAL(M,D)。
DECIMAL(M,D)中D值的是小数部分的位数，若插入的值未指定小数部分或者小数部分不足D位则会自动补到D位小数，若插入的值小数部分超过了D为则会发生截断，截取前D位小数(四舍五入截取)。M值得是整数部分加小数部分的总长度，也即插入的数字整数部分不能超过M-D位，否则不能成功插入，会报超出范围的错误。

先保证小数点，再保证整数
decimal精度类型，函数完整格式DECIMAL(M,D)
M是是只的最大精度数位，1-65
D是小数点右侧数位0-30
举例说明，11615.23653234568这个数存你说的三个格式
decimal：11615
decimal(3)：999
decimal(3,2)：9.99
decimal(10,5)11615.23653
超出精度范围的数会被强制进位并只显示数据类型定义的格式


```



#### 3.3、数字设计

##### 3.3.1、mysql 类型有符号范围和无符号范围

>带符号和无符号,顾名思义,就是是否有正负之分:
>
>比如8位的二进制,
>
>如果带符号,需要用1位表示符号(1表示负数,0表示正),剩下7位表示数据.
>那么表示范围是-128—127(包括-0和+0).
>
>如果不带符号,8位全部表示数据,
>那么表示范围是 0–256
>
>最小负数二进制是1000 0000  → 减一：   0111 1111 取反： 1000 0000  = 128   所以应该为 - 128 
>最大负数二进制是1111 1111  → 减一：   1111 1110 取反： 0000 0001 = 1 所以应该为 - 1  
>如果带符号,需要用1位表示符号(1表示负数,0表示正),剩下7位表示数据. 那么表示范围是-128—127(包括-0和+0).
>
>
>
>理解下了的话，就是无符号都是正数 ，所以主键自增Id我们一般都设计为无符号的 
>
>```
>`id` bigint(16) unsigned NOT NULL AUTO_INCREMENT,
>```



##### 3.3.2、各个数据类型的长度以及默认

> float和double都是带符号    

> 整型的每一种都分无符号（unsigned）和有符号（signed）两种类型，在默认情况整型变量都是有符号的类型     



![1556179030028](https://raw.githubusercontent.com/HealerJean/HealerJean.github.io/master/blogImages/1556179030028.png)



##### 3.3.3、int(M) (用于提示开发者长度)

这个长度`M`并不代表允许存储的宽度,`int（M）`,也就是`int（3`）和`int（11）`能够存储的数据是一样的    

只有联合zerofill参数才能有意义，否则`int（3）`和`int（11）`没有任何区别。



###### 1、不加zeroffill没有区别

```sql

create table test_int
    (
      id   int(3)  unsigned  not null,
      uid  int(11) unsigned  not null,
      uuid int     unsigned  not null
    );
#插入数据 
insert into test_int
values (4294967295, 4294967295, 4294967295);

#查询数据，发现没有什么区别
select * from test_int;
+------------+------------+------------+
| id         | uid        | uuid       |
+------------+------------+------------+
| 4294967295 | 4294967295 | 4294967295 |
+------------+------------+------------+
1 row in set (0.00 sec)


```

###### 2、有了zeroffill 不足会自动补0

```sql


create table test_int1
(
      id   int(3) unsigned zerofill  not null,
      uid  int(11) unsigned zerofill not null,
      uuid int unsigned zerofill     not null
);
#插入数据
insert into test_int1
values (4294967295, 4294967295, 4294967295);

insert into test_int1
values (1, 4294967295, 110000);

#查询数据 发现前面的不足长度的右0了，当然不能使用idea测试，idea没有显示0
mysql> select * from test_int1;
+------------+-------------+------------+
| id         | uid         | uuid       |
+------------+-------------+------------+
| 4294967295 | 04294967295 | 4294967295 |
|        001 | 04294967295 | 0000110000 |
+------------+-------------+------------+
2 rows in set (0.02 sec)

```

###### 3、当使用zerofill 时，默认会自动加unsigned（无符号），zerofill默认为int(10)

```sql
create table test_int2
(
      id   int(3) unsigned zerofill  not null,
      uid  int  zerofill not null,
      uuid int unsigned zerofill     not null
);

# 下面的不能执行成功，以为无符号的都是正数
insert into test_int2
values (1, -4294967295, 110000);

insert into test_int2
values (1, 12345678, 110000);

mysql> select * from test_int2;
+-----+------------+------------+
| id  | uid        | uuid       |
+-----+------------+------------+
| 001 | 0012345678 | 0000110000 |
+-----+------------+------------+

```



##### 3.3.4、char(M),varcahr(M)



char是一种固定长度的类型，varchar则是一种可变长度的类型，它们的区别是：     

  char(M)类型的数据列里，每个值都占用M个字节，如果某个长度小于M，`MySQL就会在它的右边用空格字符补足`．（在检索操作中那些填补出来的空格字符将被去掉）    

varchar(M)类型的数据列里，每个值只占用刚好够用的字节再加上一个用来记录其长度的字节（**即总长度为L+1字节**）





##### 3.3.5、boolean

boolean值用1代表TRUE，0代表FALSE。boolean在mysql里的类型为tinyint(1)。mysql里有四个常量：true,false,TRUE,FALSE分别代表1,0,1,0。    

```java
private Boolean loan;
	
tinyint(1) NOT NULL COMMENT '是否借款 true/false 1/0',
 
```



#### 3.4、索引设计

- 普通索引前缀：idx_索引字段名，唯一索引前缀：uk_索引字段名
- 每个表必须显示指定主键，主键尽量为一个字段，且为数字类型,避免使用字符串 
- 主键尽量保持增长趋势，建议使用id的生成器，而不使用数据库自增
- 重要的SQL或调用频率高的SQL

```java
update/select/delete的where条件列字段都要添加索引
order by , group by, distinct的字段都要添加索引
```

+ 组合索引创建时，把区分度(选择性)高的字段放在前面；根据SQL的特性，调整组合索引的顺序
+ 禁止对索引列进行函数运算和数学运算

+ 每个表的索引个数尽量少于5个，避免创建重复冗余索引；每个组合索引尽量避免超过3个字段













<br/>
<br/>

<font  color="red" size="5" >     
感兴趣的，欢迎添加博主微信
 </font>

<br/>



哈，博主很乐意和各路好友交流，如果满意，请打赏博主任意金额，感兴趣的在微信转账的时候，备注您的微信或者其他联系方式。添加博主微信哦。    

请下方留言吧。可与博主自由讨论哦

|微信 | 微信公众号|支付宝|
|:-------:|:-------:|:------:|
| ![微信](https://raw.githubusercontent.com/HealerJean/HealerJean.github.io/master/assets/img/tctip/weixin.jpg)|![微信公众号](https://raw.githubusercontent.com/HealerJean/HealerJean.github.io/master/assets/img/my/qrcode_for_gh_a23c07a2da9e_258.jpg)|![支付宝](https://raw.githubusercontent.com/HealerJean/HealerJean.github.io/master/assets/img/tctip/alpay.jpg) |



<!-- Gitalk 评论 start  -->

<link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">

<script src="https://unpkg.com/gitalk@latest/dist/gitalk.min.js"></script> 
<div id="gitalk-container"></div>    
 <script type="text/javascript">
    var gitalk = new Gitalk({
		clientID: `1d164cd85549874d0e3a`,
		clientSecret: `527c3d223d1e6608953e835b547061037d140355`,
		repo: `HealerJean.github.io`,
		owner: 'HealerJean',
		admin: ['HealerJean'],
		id: 'jhzCK5p6gBt9nkIU',
    });
    gitalk.render('gitalk-container');
</script> 


<!-- Gitalk end -->

