---
title: SpringBoot独立事物控制以及异常问题
date: 2018-06-28 03:33:00
tags: 
- Database
category: 
- Database
description: SpringBoot独立事物控制以及异常问题
---
<!-- image url 
https://raw.githubusercontent.com/HealerJean/HealerJean.github.io/master/blogImages
　　首行缩进
<font color="red">  </font>
-->

## 前言

再myfalse github中有spring控制的独立事物，这里是springBoot我们用下注解采用的独立事物


## 1、新开启一个事物

```java
@Transactional(propagation = Propagation.REQUIRES_NEW, rollbackFor = Exception.class)
public void keyTransactional(CouponItemGood couponItemGood) {

}
```

## 2、解释

###  REQUIRED，注意，这是默认值，也即不进行该参数配置等于配置成REQUIRED。

#### 2.1、REQUIRED的含义是，支持当前已经存在的事务，如果还没有事务，就创建一个新事务。

　　A调用B，假设调用aMethod前不存在任何事务，那么执行aMethod时会自动开启一个事务，而由aMethod调用bMethod时，由于事务已经存在，因此会使用已经存在的事务（也就是执行aMethod之前创建的那个事务）。
　　对于这样的配置，如果bMethod过程中发生异常需要回滚，那么aMethod中所进行的所有数据库操作也将同时被回滚，因为这两个方法使用了同一个事务。



#### 2.2、REQUIRES_NEW的含义是，挂起当前事务，创建一个新事务，如果还没有事务，就简单地创建一个新事务。
　　
　　首先，REQUIRES_NEW会创建一个与原事务无关的新事务，尽管是由一个事务调用了另一个事务，但却没有父子关系。
　　如果bMethod的传播性是REQUIRES_NEW，而抛出了一个异常，则bMethod一定会被回滚，而如果aMethod捕获并处理了这个bMethod抛出的异常，那么aMethod仍有可能成功提交。当然，如果aMethod没有处理这个异常，那么aMethod也会被回滚。
　　如果aMethod在bMethod完成后出现了异常，那么bMethod已经提交而无法回滚，只有aMethod被回滚了。
　　
#### 2.3、NOT_SUPPORTED：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。不启用事物





### 3、关于使用事物中嵌套REQUIRES_NEW 事物中出现的异常

比如使用了上面的注解出现了空指针异常，但是因为上面注解的关系异常会抛出为TransactionSystemException，正常情况下，如果REQUIRES_NEW 中出现了异常，自己的事物中可以捕获，而且在它事物外，也就是包含它的大事物中国也会进行二次捕获。也就是说会捕获两次异常





```java
Could not commit JPA transaction; nested exception is javax.persistence.RollbackException: Transaction marked as rollbackOnlyException 


外面的大事物中进行捕获为TransactionSystemException
try {
    keyTransactional.keyTransactional(couponItemGood);
    log.info(couponItemGood.getId().toString()+"已经检测");
}catch (AppException e){
    log.info(e.getMessage())
    continue;
}catch (TransactionSystemException e){
    log.info("小当优惠券中没有优惠券信息导致的，无须处理-多个事物开启了异常");
}catch (Exception e){
}

```

### 2.4、事物的使用

#### PROPAGATION_REQUIRED 

-- 支持当前事务，如果当前没有事务，就新建一个事务。这是最常见的选择。

#### PROPAGATION_SUPPORTS 

-- 支持当前事务，如果当前没有事务，就以非事务方式执行。

#### PROPAGATION_MANDATORY （抛出异常）

-- 支持当前事务，如果当前没有事务，就抛出异常。

#### PROPAGATION_REQUIRES_NEW 

-- 新建事务，如果当前存在事务，把当前事务挂起。

#### PROPAGATION_NOT_SUPPORTED 

-- 以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。

#### PROPAGATION_NEVER （抛出异常）

-- 以非事务方式执行，如果当前存在事务，则抛出异常。
    
#### PROPAGATION_NESTED 
-- 如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则进行与PROPAGATION_REQUIRED类似的操作。


<font color="red"> 
## 4、方法中事物的使用

一般情况下，我们的事物开启的时间不要太早，不然，如果数据量大，开启事物的时间过长，很容易卡死，所以当我们在进行增删改查的时候再讲数据开启（所以使用下面用了全局配置，那么关于一些不使用事物的方法，写到controll中或者新建一个没有事物的目录，将方法在这个目录下面）

 </font>

### 4.1、项目中全局事物的配置（不全，具体看代码吧）

可以观察到下面只要是service中都使用了事物，其实这种不建议采用，正常我们写方法的时候，再指定其实是最好的。因为写一个具体的方法我们才知道是不是要开启一个事物以及开启事物的时间

```xml
    <aop:config proxy-target-class="true">
        <aop:advisor pointcut="execution(* com.duodian.youhui.admin..service..*.*(..))" advice-ref="txAdvice" />
    </aop:config>
    
    <!--开启事物 ,如果是controller中查询其实是不需要使用事物的，所以controller中添加或者删除不可以，但是是可以查询的-->
    <!--  transaction start  -->
    <tx:advice id="txAdvice" transaction-manager="duodianTM">
        <tx:attributes>
            <tx:method name="*" propagation="REQUIRED" rollback-for="Exception" />
            <tx:method name="query*" propagation="SUPPORTS" rollback-for="Exception" />
            <tx:method name="find*" propagation="SUPPORTS" read-only="true" />
            <tx:method name="select*" propagation="SUPPORTS" read-only="true" />
            <tx:method name="get*" propagation="SUPPORTS" read-only="true" />
            <tx:method name="query*" propagation="SUPPORTS" read-only="true" />
        </tx:attributes>
    </tx:advice>
    

```


### 4.2、方法中开始事物（建议使用）


```java
readOnly =true，默认是false，只读事物true__保证数据的一致性
没有事物有事物的区别：
没有事务的时候，在执行一条sql语句看到执行前点的数据状态，不能保证一致性
只读事务，在执行多条sql语句看到执行前点的数据状态，保证数据一致性


    @Transactional(transactionManager = "duodianTM", propagation = Propagation.REQUIRED, rollbackFor = Exception.class)
    @Override
    public void process(UserOrderData data) {
        process(data, null);
    }
    
```

### 4.3、事物使用的错误

@Transactional注解的方法之间调用，事务是否生效的问题


####  1. 不同类之间的方法调用，如类A的方法a()调用类B的方法b()，这种情况事务是正常起作用的。只要方法a()或b()配置了事务，运行中就会开启事务，产生代理。若两个方法都配置了事务，两个事务具体以何种方式传播，取决于设置的事务传播特性。<br/>

#### 2. 同一个类内方法调用：重点来了，同一个类内的方法调用就没那么简单了，假定类A的方法a()调用方法b()，同一类内方法调用，无论被调用的b()方法是否配置了事务，此事务在被调用时都将不生效。

1、方法a没有使用事物，方法b使用了事物

```java


@Service
public class UserServiceImpl implements UserService {
 
    @Autowired
    private UserDao userDao;
    
    public int insertUser(User user) {
        // 调用同类方法
        this.selectUser(user.getId());
        return 1;
        
    }
    @Transactional
    public String selectUser(int id) {
        throw new RuntimeException();
        //return userDao.selectUser(id);
    }
 
    public int updateUser(User user) {
        return userDao.updateUser(0, user);
    }
 
}


service层中，insertUser()方法没有配置事务，selectUser()配置了事务，在insertUser()中调用selectUser()时，查看日志如下： 可见没有开启事务，因此selectUser()的事务配置没有生效，抛异常后也不会回滚。



[DEBUG][2018-02-22 11:00:32] org.hibernate.engine.jdbc.spi.SqlStatementLogger.logStatement(SqlStatementLogger.java:104) drop table if exists user 
    Hibernate: drop table if exists user
[DEBUG][2018-02-22 11:00:32] org.hibernate.engine.jdbc.spi.SqlStatementLogger.logStatement(SqlStatementLogger.java:104) create table user (id integer not null auto_increment, createdDate datetime, email varchar(255), name varchar(20) not null, password varchar(255), phone varchar(255), updatedDate datetime, primary key (id)) 
    Hibernate: create table user (id integer not null auto_increment, createdDate datetime, email varchar(255), name varchar(20) not null, password varchar(255), phone varchar(255), updatedDate datetime, primary key (id))
[INFO][2018-02-22 11:00:32] org.hibernate.tool.hbm2ddl.SchemaExport.execute(SchemaExport.java:406) HHH000230: Schema export complete 
    [DEBUG][2018-02-22 11:00:32] org.hibernate.internal.SessionFactoryImpl.checkNamedQueries(SessionFactoryImpl.java:1073) Checking 0 named HQL queries 
    [DEBUG][2018-02-22 11:00:32] org.hibernate.internal.SessionFactoryImpl.checkNamedQueries(SessionFactoryImpl.java:1096) Checking 0 named SQL queries 
    [DEBUG][2018-02-22 11:00:32] org.hibernate.stat.internal.StatisticsInitiator.initiateServiceInternal(StatisticsInitiator.java:110) Statistics initialized [enabled=false] 
    [INFO][2018-02-22 11:00:33] org.springframework.orm.hibernate4.HibernateTransactionManager.afterPropertiesSet(HibernateTransactionManager.java:360) Using DataSource [com.mchange.v2.c3p0.ComboPooledDataSource[ identityToken -> 1hge15x9t1g0fr98s704x1|72d1ad2e, dataSourceName -> 1hge15x9t1g0fr98s704x1|72d1ad2e ]] of Hibernate SessionFactory for HibernateTransactionManager 
    [DEBUG][2018-02-22 11:00:33] org.hibernate.engine.spi.ActionQueue.addResolvedEntityInsertAction(ActionQueue.java:228) Executing identity-insert immediately 
    [DEBUG][2018-02-22 11:00:33] org.hibernate.engine.jdbc.spi.SqlStatementLogger.logStatement(SqlStatementLogger.java:104) insert into user (createdDate, email, name, password, phone, updatedDate) values (?, ?, ?, ?, ?, ?) 
    Hibernate: insert into user (createdDate, email, name, password, phone, updatedDate) values (?, ?, ?, ?, ?, ?)
[DEBUG][2018-02-22 11:00:33] org.hibernate.engine.jdbc.internal.LogicalConnectionImpl.obtainConnection(LogicalConnectionImpl.java:212) Obtaining JDBC connection 
    [DEBUG][2018-02-22 11:00:33] org.hibernate.engine.jdbc.internal.LogicalConnectionImpl.obtainConnection(LogicalConnectionImpl.java:218) Obtained JDBC connection 
    [DEBUG][2018-02-22 11:00:33] org.hibernate.id.IdentifierGeneratorHelper.getGeneratedIdentity(IdentifierGeneratorHelper.java:93) Natively generated identity: 1 
    [DEBUG][2018-02-22 11:00:33] org.hibernate.hql.internal.ast.QueryTranslatorImpl.parse(QueryTranslatorImpl.java:267) parse() - HQL: select name from com.wcl.pojo.User u where u.id = ? 
    [DEBUG][2018-02-22 11:00:33] org.hibernate.hql.internal.ast.QueryTranslatorImpl.showHqlAst(QueryTranslatorImpl.java:285) --- HQL AST ---
--------------------- 
```


2、方法a和方法b都使用了事物

另一个例子：方法a()配置了事务，此时b()的事务不生效，但a()的事务生效，对于b()中抛出的异常也会回滚。也就是说b的事物没生效，其实b使用的是a的事物。

#### 总结:当从类外调用方法a()时，从spring容器获取到的serviceImpl对象实际是包装好的proxy对象，因此调用a()方法的对象是动态代理对象。而在类内部a()调用b()的过程中，实质执行的代码是this.b()，此处this对象是实际的serviceImpl对象而不是本该生成的代理对象，因此直接调用了b()方法。


## 代码看瞬时态_持久太_游离态文件夹

　
　
<br/><br/><br/>
如果满意，请打赏博主任意金额，感兴趣的在微信转账的时候，添加博主微信哦， 请下方留言吧。可与博主自由讨论哦

|支付包 | 微信|微信公众号|
|:-------:|:-------:|:------:|
|![支付宝](https://raw.githubusercontent.com/HealerJean/HealerJean.github.io/master/assets/img/tctip/alpay.jpg) | ![微信](https://raw.githubusercontent.com/HealerJean/HealerJean.github.io/master/assets/img/tctip/weixin.jpg)|![微信公众号](https://raw.githubusercontent.com/HealerJean/HealerJean.github.io/master/assets/img/my/qrcode_for_gh_a23c07a2da9e_258.jpg)|




<!-- Gitalk 评论 start  -->

<link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk@latest/dist/gitalk.min.js"></script> 
<div id="gitalk-container"></div>    
 <script type="text/javascript">
    var gitalk = new Gitalk({
		clientID: `1d164cd85549874d0e3a`,
		clientSecret: `527c3d223d1e6608953e835b547061037d140355`,
		repo: `HealerJean.github.io`,
		owner: 'HealerJean',
		admin: ['HealerJean'],
		id: '5jzqDO0cthpRMXQb',
    });
    gitalk.render('gitalk-container');
</script> 

<!-- Gitalk end -->

