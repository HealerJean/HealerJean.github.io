---
title: SpringBoot独立事物控制以及异常问题
date: 2018-06-28 03:33:00
tags: 
- Database
category: 
- Database
description: SpringBoot独立事物控制以及异常问题
---
<!-- image url 
https://raw.githubusercontent.com/HealerJean/HealerJean.github.io/master/blogImages
　　首行缩进
<font color="red">  </font>
-->

## 前言

再myfalse github中有spring控制的独立事物，这里是springBoot我们用下注解采用的独立事物


## 1、新开启一个事物

```java
@Transactional(propagation = Propagation.REQUIRES_NEW, rollbackFor = Exception.class)
public void keyTransactional(CouponItemGood couponItemGood) {

}
```

## 2、解释

###  REQUIRED，注意，这是默认值，也即不进行该参数配置等于配置成REQUIRED。

#### 2.1、REQUIRED的含义是，支持当前已经存在的事务，如果还没有事务，就创建一个新事务。

　　A调用B，假设调用aMethod前不存在任何事务，那么执行aMethod时会自动开启一个事务，而由aMethod调用bMethod时，由于事务已经存在，因此会使用已经存在的事务（也就是执行aMethod之前创建的那个事务）。
　　对于这样的配置，如果bMethod过程中发生异常需要回滚，那么aMethod中所进行的所有数据库操作也将同时被回滚，因为这两个方法使用了同一个事务。



#### 2.2、REQUIRES_NEW的含义是，挂起当前事务，创建一个新事务，如果还没有事务，就简单地创建一个新事务。

　　首先，REQUIRES_NEW会创建一个与原事务无关的新事务，尽管是由一个事务调用了另一个事务，但却没有父子关系。
　　如果bMethod的传播性是REQUIRES_NEW，而抛出了一个异常，则bMethod一定会被回滚，而如果aMethod捕获并处理了这个bMethod抛出的异常，那么aMethod仍有可能成功提交。当然，如果aMethod没有处理这个异常，那么aMethod也会被回滚。
　　如果aMethod在bMethod完成后出现了异常，那么bMethod已经提交而无法回滚，只有aMethod被回滚了。
　　
#### 2.3、NOT_SUPPORTED：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。不启用事物





### 3、关于使用事物中嵌套REQUIRES_NEW 事物中出现的异常

比如使用了上面的注解出现了空指针异常，但是因为上面注解的关系异常会抛出为TransactionSystemException，正常情况下，如果REQUIRES_NEW 中出现了异常，自己的事物中可以捕获，而且在它事物外，也就是包含它的大事物中国也会进行二次捕获。也就是说会捕获两次异常





```java
Could not commit JPA transaction; nested exception is javax.persistence.RollbackException: Transaction marked as rollbackOnlyException 


外面的大事物中进行捕获为TransactionSystemException
try {
    keyTransactional.keyTransactional(couponItemGood);
    log.info(couponItemGood.getId().toString()+"已经检测");
}catch (AppException e){
    log.info(e.getMessage())
    continue;
}catch (TransactionSystemException e){
    log.info("小当优惠券中没有优惠券信息导致的，无须处理-多个事物开启了异常");
}catch (Exception e){
}

```

### 2.4、事物的使用

#### PROPAGATION_REQUIRED 

-- 支持当前事务，如果当前没有事务，就新建一个事务。这是最常见的选择。

#### PROPAGATION_SUPPORTS 

-- 支持当前事务，如果当前没有事务，就以非事务方式执行。

#### PROPAGATION_MANDATORY （抛出异常）

-- 支持当前事务，如果当前没有事务，就抛出异常。

#### PROPAGATION_REQUIRES_NEW 

-- 新建事务，如果当前存在事务，把当前事务挂起。

#### PROPAGATION_NOT_SUPPORTED 

-- 以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。

#### PROPAGATION_NEVER （抛出异常）

-- 以非事务方式执行，如果当前存在事务，则抛出异常。
    
#### PROPAGATION_NESTED 
-- 如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则进行与PROPAGATION_REQUIRED类似的操作。


<font color="red"> 
## 4、方法中事物的使用



### 4.1、事务的配置

#### 4.1.1、项目中全局事物的配置（不全，具体看代码吧）

可以观察到下面只要是service中都使用了事物，其实这种不建议采用，正常我们写方法的时候，再指定其实是最好的。因为写一个具体的方法我们才知道是不是要开启一个事物以及开启事物的时间

```xml
    <aop:config proxy-target-class="true">
        <aop:advisor pointcut="execution(* com.duodian.youhui.admin..service..*.*(..))" advice-ref="txAdvice" />
    </aop:config>
    
    <!--开启事物 ,如果是controller中查询其实是不需要使用事物的，所以controller中添加或者删除不可以，但是是可以查询的-->
    <!--  transaction start  -->
    <tx:advice id="txAdvice" transaction-manager="duodianTM">
        <tx:attributes>
            <tx:method name="*" propagation="REQUIRED" rollback-for="Exception" />
            <tx:method name="query*" propagation="SUPPORTS" rollback-for="Exception" />
            <tx:method name="find*" propagation="SUPPORTS" read-only="true" />
            <tx:method name="select*" propagation="SUPPORTS" read-only="true" />
            <tx:method name="get*" propagation="SUPPORTS" read-only="true" />
            <tx:method name="query*" propagation="SUPPORTS" read-only="true" />
        </tx:attributes>
    </tx:advice>
    

```


#### 4.1.2、方法中使用注解开始事物（建议使用）


```java
readOnly =true，默认是false，只读事物true__保证数据的一致性
没有事物有事物的区别：
没有事务的时候，在执行一条sql语句看到执行前点的数据状态，不能保证一致性
只读事务，在执行多条sql语句看到执行前点的数据状态，保证数据一致性

（rollbackFor = Exception.class）
1、如果类加了这个注解，那么这个类里面的方法抛出异常，就会回滚，数据库里面的数据也会回滚。
2、如果不配置rollbackFor属性,那么事物只会在遇到RuntimeException的时候才会回滚,加上rollbackFor=Exception.class,可以让事物在遇到非运行时异常（比如：我们自己抛出的异常）时也回滚

    @Transactional(transactionManager = "duodianTM", propagation = Propagation.REQUIRED, rollbackFor = Exception.class)
    @Override
    public void process(UserOrderData data) {
        process(data, null);
    }
    
```



### 4.2、事务的使用建议

**一般情况下，我们的事物开启的时间不要太早，不然，如果数据量大，开启事物的时间过长，很容易卡死    **



**1、所以当我们在进行增删改查的时候再讲数据开启（所以用了全局配置，那么关于一些不使用事物的方法，写到controll方法的前面，一定得是前面，因为如果controller中间调用了事务的方法，那么后面事务执行后错误不会回滚）**                



**2、尽量使用注解的方法，这样选择开启的时间，因为比较灵活**



#### 4.2.1、测试

如下：使用了4.1中的全局事务，只在service中使用了事务  ，那么debug观察的时候，只要语句`addDemoEntity`执行，那么事务就会执行，直接入库，即使controller后面有了异常，因为事务已经执行了，就不会回滚，所以尽量使用注解开始事务，这样比较灵活



```java
 @ApiOperation(value = "添加demo实体",
                  notes = "添加demo实体",
                  consumes = MediaType.APPLICATION_FORM_URLENCODED_VALUE,
                  produces = MediaType.APPLICATION_JSON_VALUE,
                  response = DemoEntity.class)
    @GetMapping(value = "addDemoEntity",produces = "application/json; charset=utf-8")
    @ResponseBody
    public ResponseBean insert(DemoEntity demoEntity){
        try {

            demoEntityService.addDemoEntity(demoEntity); //入库

            DemoEntity demo2 = new DemoEntity() ;
            demo2.setName("2");
            demo2.setAge(2L);
            demoEntityService.addDemoEntity(demo2);//入库

            DemoEntity demo3 = new DemoEntity() ;
            demo3.setName("3");
            demo3.setAge(3L);
            threeDemoEntityService.addDemoEntity(demo3);//入库

            return  ResponseBean.buildSuccess();
        }catch (AppException e){
            ExceptionLogUtils.log(e,this.getClass() );
            return  ResponseBean.buildFailure(e.getCode(),e.getMessage());
        }catch (Exception e){
            ExceptionLogUtils.log(e,this.getClass() );
            return  ResponseBean.buildFailure(e.getMessage());
        }
    }

```









### 4.3、多个事物使用的错误



**@Transactional注解的方法之间调用，事务是否生效的问题**

#### 4.3、解释：

+ 1. 不同类之间的方法调用，**如类A的方法a()调用类B的方法b()，这种情况事务是正常起作用的**。只要方法a()或b()配置了事务，运行中就会开启事务，产生代理。若两个方法都配置了事务，两个事务具体以何种方式传播，取决于设置的事务传播特性。<br/>

+ 2. 同一个类内方法调用：重点来了，同一个类内的方法调用就没那么简单了，假定类A的方法a()调用方法b()，**同一类内方法调用，无论被调用的b()方法是否配置了事务，此事务在被调用时都将不生效。**

#### 4.3、测试 第二种情况

##### 4.3.1、方法a没有使用事物，方法b使用了事物**

那么如果baseDao.saveObject(detail)异常，方法B不能全部回滚   

（也就是说虽然baseDao.saveObject(detail)没有保存成功，但是baseDao.saveObject(user)保存成功了） ,因为没有使用事务

```java


public class MyEntry implements IBaseService{
	public String A(String jsonStr) throws Exception{
		UserInfo user = null;
		UserDetail userDetail = null;
		this.getUserMsg(user,userDetail ,jsonStr);
		if(null!= user){
			this.B（user,userDetail）;
		}
		return "";
	}
	//此处需要事务
	private String B(UserInfo user, UserDetail detail) throws DBException{
		baseDao.saveObject(user);
		baseDao.saveObject(detail);
	}
}



```

##### **4.3.2、方法a和方法b都使用了事物**

另一个例子：方法a()配置了事务，此时b()的事务不生效，但a()的事务生效，对于b()中抛出的异常也会回滚。也就是说b的事物没生效，其实b使用的是a的事物。

#### 原理总结:
当从类外调用方法a()时，从spring容器获取到的serviceImpl对象实际是包装好的proxy对象，因此调用a()方法的对象是动态代理对象。而在类内部a()调用b()的过程中，实质执行的代码是this.b()，此处this对象是实际的serviceImpl对象而不是本该生成的代理对象，因此直接调用了b()方法。



### 4.4、异步线程事务是怎么回事的

异步线程，事务传播失效，也就是说不会使用事务，即使使用独立事务，即使后面有异常信息，照样会入库，但是需要等方法全部走完才能入库，而不是像之前的独立事务一样直接在数据库中显示了     

不会影响主线程的哦

```java
  @Override
    public DemoEntity addDemoEntity(DemoEntity demoEntity) {
        new Thread(()->{ //异步线程，事务传播失效，也就是说不会使用事务，即使使用独立事务，即使后面有异常信息，照样会入库，但是需要等方法全部走完，而不是像之前的独立事务一样直接在数据库中显示了
            demoEntityRepository.save(new DemoEntity().setName(demoEntity+"1"));
//          demoNewTransactional.addDemoEntity(new DemoEntity().setName(demoEntity+"1")) ;
            int i = 1/0 ;
        }).start();
        demoEntityRepository.save(demoEntity) ;
        int i = 1/0 ;
        return demoEntity;
    }
```


　





<br/><br/><br/>
如果满意，请打赏博主任意金额，感兴趣的在微信转账的时候，添加博主微信哦， 请下方留言吧。可与博主自由讨论哦

|支付包 | 微信|微信公众号|
|:-------:|:-------:|:------:|
|![支付宝](https://raw.githubusercontent.com/HealerJean/HealerJean.github.io/master/assets/img/tctip/alpay.jpg) | ![微信](https://raw.githubusercontent.com/HealerJean/HealerJean.github.io/master/assets/img/tctip/weixin.jpg)|![微信公众号](https://raw.githubusercontent.com/HealerJean/HealerJean.github.io/master/assets/img/my/qrcode_for_gh_a23c07a2da9e_258.jpg)|




<!-- Gitalk 评论 start  -->

<link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk@latest/dist/gitalk.min.js"></script> 
<div id="gitalk-container"></div>    
 <script type="text/javascript">
    var gitalk = new Gitalk({
		clientID: `1d164cd85549874d0e3a`,
		clientSecret: `527c3d223d1e6608953e835b547061037d140355`,
		repo: `HealerJean.github.io`,
		owner: 'HealerJean',
		admin: ['HealerJean'],
		id: '5jzqDO0cthpRMXQb',
    });
    gitalk.render('gitalk-container');
</script> 

<!-- Gitalk end -->

