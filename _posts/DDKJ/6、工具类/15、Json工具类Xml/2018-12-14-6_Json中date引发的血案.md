---
title: Json中date引发的血案
date: 2018-12-14 03:33:00
tags: 
- Json
category: 
- Json
description: Json中date引发的血案
---
<!-- image url 
https://raw.githubusercontent.com/HealerJean/HealerJean.github.io/master/blogImages
　　首行缩进
<font color="red">  </font>

<font  color="red" size="4">   </font>


<font size="4">   </font>
-->

## 前言


### 1、包含集合的测试bean

```java

package com.hlj.data.res.test;

import io.swagger.annotations.ApiModel;
import lombok.Data;
import lombok.experimental.Accessors;

import java.math.BigDecimal;
import java.util.Date;
import java.util.List;

/**
 * @Desc: json测试实体
 * @Author HealerJean
 * @Date 2018/9/25  上午11:10.
 *
 */
@Data
@Accessors(chain = true)
@ApiModel (description = "json测试实体")
public class TsJsonData {


    /**
     {"error":"0","msg":"操作成功","data":[{"n_long":"3923600074","n_string":"小当","n_bigDecimal":"5.9000","n_date":"2018-12-13 20:31:04","n_integer":1},{"n_long":"3923600074","n_string":"小当","n_bigDecimal":"5.9000","n_date":"2018-12-13 20:31:04","n_integer":1}]}
     * error : 0
     * msg : 操作成功
     * data : [{"n_long":"3923600074","n_string":"小当","n_bigDecimal":"5.9000","n_date":"2018-12-13 20:31:04","n_integer":1},{"n_long":"3923600074","n_string":"小当","n_bigDecimal":"5.9000","n_date":"2018-12-13 20:31:04","n_integer":1}]
     */

    private String error;
    private String msg;
    private List<DataBean> data;

    @Data
    @Accessors(chain = true)
    public static class DataBean {
        /**
         * n_long : 3923600074
         * n_string : name
         * n_bigDecimal : 5.9000
         * n_date : 2018-12-13 20:31:04
         * income_rate : 0.9000
         * n_integer : 1
         */

        private Long n_long;
        private String n_string;
        private BigDecimal n_bigDecimal;
        private Date n_date;
        private Integer n_integer;


    }
}

```



### 2、普通Bean

```java

package com.hlj.data.res.test;

import lombok.Data;
import lombok.experimental.Accessors;

import java.io.Serializable;
import java.math.BigDecimal;
import java.util.Date;

/**
 * 作者 ：HealerJean
 * 日期 ：2018/12/14  下午7:56.
 * 类描述：
 */
@Data
@Accessors(chain = true)
public class JavaBean implements Serializable {

    private Long n_long;
    private String n_string;
    private BigDecimal n_bigDecimal;
    private Date n_date;
    private Integer n_integer;

}


```


### 3、开始正儿八经测试


```java
package com.hlj.moudle.demo.service;

import com.hlj.data.res.test.JavaBean;
import com.hlj.data.res.test.TsJsonData;
import com.hlj.utils.JsonUtils;
import lombok.extern.slf4j.Slf4j;
import net.sf.json.JSONArray;
import net.sf.json.JSONObject;
import org.junit.jupiter.api.Test;
import org.springframework.beans.BeanUtils;

import java.math.BigDecimal;
import java.util.*;

/**
 * 作者 ：HealerJean
 * 日期 ：2018/12/14  下午8:00.
 *  1、只要是经过多层Json的处理对象或者是Map处理， date就会走样，然后这样的 string类型就不会被封装，
 *  所以一般情况下，我们从Json变成对象就可以了，没事别老来回折腾，而且我们的对象到了前端之后，就会帮我们变成long类型
 */
@Slf4j
public class TestService {

    /**
     * json 转 JavaBean
     * 1、 date类型的Json转化为对象，必须是Long类型的，不可以是String类型的'2018-12-13 20:31:04'
     */
    @Test
    public void josnToBean() {

//  错误的   String jsonStr = "{\"error\":\"0\",\"msg\":\"操作成功\",\"data\":[{\"n_long\":\"3923600074\",\"n_string\":\"小当\",\"n_bigDecimal\":\"5.9000\",\"n_date\":\"2018-12-13 20:31:04\",\"n_integer\":1},{\"n_long\":\"3923600074\",\"n_string\":\"小当\",\"n_bigDecimal\":\"5.9000\",\"n_date\":\"2018-12-13 20:31:04\",\"n_integer\":1}]}";
        String jsonDataStr = "{\"error\":\"0\",\"msg\":\"操作成功\",\"data\":[{\"n_long\":\"3923600074\",\"n_string\":\"小当\",\"n_bigDecimal\":\"5.9000\",\"n_date\":\"1544782308409\",\"n_integer\":1},{\"n_long\":\"3923600074\",\"n_string\":\"小当\",\"n_bigDecimal\":\"5.9000\",\"n_date\":\"1544782308409\",\"n_integer\":1}]}";
        TsJsonData tsJsonData =   JsonUtils.toObject(jsonDataStr, TsJsonData.class );

        log.info(JSONObject.fromObject(tsJsonData).toString());
//        {"data":[{"n_bigDecimal":5.9,"n_date":{"date":14,"day":5,"hours":18,"minutes":11,"month":11,"seconds":48,"time":1544782308409,"timezoneOffset":-480,"year":118},"n_integer":1,"n_long":3923600074,"n_string":"小当"},{"n_bigDecimal":5.9,"n_date":{"date":14,"day":5,"hours":18,"minutes":11,"month":11,"seconds":48,"time":1544782308409,"timezoneOffset":-480,"year":118},"n_integer":1,"n_long":3923600074,"n_string":"小当"}],"error":"0","msg":"操作成功"}

        JavaBean javaBean1 = getJavaBean();
        log.info(JsonUtils.toJson(javaBean1));
//        {"n_long":10045456456,"n_string":"张宇晋","n_bigDecimal":12.12245,"n_date":1544791847711,"n_integer":100}

    }



    /**
     * JavaBean转 json
     * 1、 JavaBean转内部包含集合
     */
    @Test
    public void beanToJson() {

        TsJsonData tsJsonData = new TsJsonData().setError("0").setMsg("success");
        TsJsonData.DataBean dataBean = new TsJsonData.DataBean();
        dataBean.setN_long(10045456456L);
        dataBean.setN_bigDecimal(new BigDecimal("12.12245"));
        dataBean.setN_date(new Date());
        dataBean.setN_integer(100);
        dataBean.setN_string("张宇晋");


        TsJsonData.DataBean dataBean2 = new TsJsonData.DataBean();
        String []jgnore = {"n_long","n_string"};
        BeanUtils.copyProperties(dataBean,dataBean2,jgnore );
        dataBean2.setN_long(45456L);
        dataBean2.setN_string("HealerJean");

        List< TsJsonData.DataBean> dataBeans = new ArrayList<>();
        dataBeans.add(dataBean);
        dataBeans.add(dataBean2);
        tsJsonData.setData(dataBeans);

        log.info(JSONObject.fromObject(tsJsonData).toString());
        //只要是经过多层Json的处理 date就会走样
        //{"data":[{"n_bigDecimal":12.12245,"n_date":{"date":14,"day":5,"hours":20,"minutes":48,"month":11,"seconds":17,"time":1544791697252,"timezoneOffset":-480,"year":118},"n_integer":100,"n_long":10045456456,"n_string":"张宇晋"},{"n_bigDecimal":12.12245,"n_date":{"date":14,"day":5,"hours":20,"minutes":48,"month":11,"seconds":17,"time":1544791697252,"timezoneOffset":-480,"year":118},"n_integer":100,"n_long":45456,"n_string":"HealerJean"}],"error":"0","msg":"success"}


    }

    /**
     * JavaBean转Map
     * Map<String, Object> map = (Map<String, Object>)JSONObject.fromObject(javaBean);
     * 用法：可以用于Http map传参
     */
    @Test
    public void baenToMap() {

        JavaBean javaBean = getJavaBean();

        Map<String, Object> map = (Map<String, Object>)JSONObject.fromObject(javaBean);

        log.info(map.toString());//打印出来默认是Json类型的
        //下面这里发现date 编制了，它自己变成了一个数组
        //{"n_bigDecimal":12.12245,"n_date":{"date":14,"day":5,"hours":20,"minutes":0,"month":11,"seconds":31,"time":1544788831913,"timezoneOffset":-480,"year":118},"n_integer":100,"n_long":10045456456,"n_string":"张宇晋"}

    }



    /**
     * Map转JavaBean
     */
    @Test
    public void MapTobaen() {

        Map<String, Object> map = getJavaBeanMap();
        String mapStr = JSONObject.fromObject(map).toString();
        log.info(mapStr);
        //{"n_date":{"date":14,"day":5,"hours":20,"minutes":57,"month":11,"seconds":0,"time":1544792220857,"timezoneOffset":-480,"year":118},"n_integer":100,"n_bigDecimal":12.12245,"n_string":"张宇晋","n_long":10045456456}
    }

  
  
  
    @Test
    public void JsonToList(){

        List<JavaBean> javaBeans = new ArrayList<>();
        JavaBean javaBean1 = getJavaBean();

        JavaBean javaBean2 = getJavaBean();
        javaBeans.add(javaBean1);
        javaBeans.add(javaBean2);
        JSONArray jsonArray = JSONArray.fromObject(javaBeans);
//      Json数组打印出来 date就变成了下面这种玩意，和上面的map一球样，经过了多层处理
//      log.info(jsonArray.toString());
//      [{"n_bigDecimal":12.12245,"n_date":{"date":14,"day":5,"hours":20,"minutes":44,"month":11,"seconds":0,"time":1544791440208,"timezoneOffset":-480,"year":118},"n_integer":100,"n_long":10045456456,"n_string":"张宇晋"},{"n_bigDecimal":12.12245,"n_date":{"date":14,"day":5,"hours":20,"minutes":44,"month":11,"seconds":0,"time":1544791440208,"timezoneOffset":-480,"year":118},"n_integer":100,"n_long":10045456456,"n_string":"张宇晋"}]


        //第一种方式，只针对没有使用lombok注解的情况 ，这种方式不论有没有 date类型 使用了@Data注解 就会出现下面的问题，有了date那也肯定的会是这种结局
//      使用的时候，我们还是尽量使用这种方式，不要用@Data注解，jsonArray来源需要是原生的
//  javaBeans = JSONArray.toList(jsonArray,new JavaBean() ,new JsonConfig());
//        net.sf.json.JSONObject - Property 'n_bigDecimal' of class com.hlj.data.res.test.JavaBean has no write method. SKIPPED.
//        2018-12-14 20:27:08.129 [main] INFO  net.sf.json.JSONObject - Property 'n_date' of class com.hlj.data.res.test.JavaBean has no write method. SKIPPED.
//        2018-12-14 20:27:08.130 [main] INFO  net.sf.json.JSONObject - Property 'n_integer' of class com.hlj.data.res.test.JavaBean has no write method. SKIPPED.
//        2018-12-14 20:27:08.130 [main] INFO  net.sf.json.JSONObject - Property 'n_long' of class com.hlj.data.res.test.JavaBean has no write method. SKIPPED.
//        2018-12-14 20:27:08.130 [main] INFO  net.sf.json.JSONObject - Property 'n_string' of class com.hlj.data.res.test.JavaBean has no write method. SKIPPED.
//        2018-12-14 20:27:08.130 [main] INFO  net.sf.json.JSONObject - Property 'n_bigDecimal' of class com.hlj.data.res.test.JavaBean has no write method. SKIPPED.
//        2018-12-14 20:27:08.130 [main] INFO  net.sf.json.JSONObject - Property 'n_date' of class com.hlj.data.res.test.JavaBean has no write method. SKIPPED.
//        2018-12-14 20:27:08.131 [main] INFO  net.sf.json.JSONObject - Property 'n_integer' of class com.hlj.data.res.test.JavaBean has no write method. SKIPPED.
//        2018-12-14 20:27:08.131 [main] INFO  net.sf.json.JSONObject - Property 'n_long' of class com.hlj.data.res.test.JavaBean has no write method. SKIPPED.
//        2018-12-14 20:27:08.131 [main] INFO  net.sf.json.JSONObject - Property 'n_string' of class com.hlj.data.res.test.JavaBean has no write method. SKIPPED.
//        log.info(JsonUtils.toJson(javaBeans));
//打印结果 [{"n_long":null,"n_string":null,"n_bigDecimal":null,"n_date":null,"n_integer":null},{"n_long":null,"n_string":null,"n_bigDecimal":null,"n_date":null,"n_integer":null}]


        //2、自己封装的
        //使用下面的没有Date类型的时候没有问题，有了Date类型就会报错，所以我尝试将date变成null
        // 因为这里的date不是Long类型的，明白了吧，上面我们就说了必须是Long类型的才可以哦
//        javaBeans =(List<JavaBean>) JsonUtils.toObjectOrList(jsonArray.toString(),JavaBean.class );
//        log.info(JsonUtils.toJson(javaBeans));
        //[{"n_long":10045456456,"n_string":"张宇晋","n_bigDecimal":12.12245,"n_date":null,"n_integer":100},{"n_long":10045456456,"n_string":"张宇晋","n_bigDecimal":12.12245,"n_date":null,"n_integer":100}]

        //下面这种也一样，有了date就是不好使，明白了么，臭小子
        String jsonArrayStr = "[{\"n_long\":10045456456,\"n_string\":\"张宇晋\",\"n_bigDecimal\":12.12245,\"n_date\":1544791022000,\"n_integer\":100},{\"n_long\":10045456456,\"n_string\":\"张宇晋\",\"n_bigDecimal\":12.12245,\"n_date\":1544791022000,\"n_integer\":100}]";
        javaBeans =(List<JavaBean>) JsonUtils.toObjectOrList(jsonArrayStr,JavaBean.class );
        log.info(JsonUtils.toJson(javaBeans));
        //下面这种也不行，因为还是经过了多层处理，date又出来了
//        javaBeans =JSONArray.toList(JSONArray.fromObject(jsonArrayStr),new JavaBean() ,new JsonConfig());
//        log.info(JsonUtils.toJson(javaBeans));


    }

  
  
  
  
    /**
     * 假数据JavaBean
     * @return
     */
    private JavaBean getJavaBean() {
        JavaBean javaBean = new JavaBean();
        javaBean.setN_long(10045456456L);
        javaBean.setN_bigDecimal(new BigDecimal("12.12245"));
        javaBean.setN_date(new Date());
        javaBean.setN_integer(100);
        javaBean.setN_string("张宇晋");
        return javaBean;
    }


    /**
     * 假数据JavaBean 对应的 Map
     * @return
     */
    private Map<String, Object> getJavaBeanMap() {
        Map<String, Object> map = new HashMap<>();
        map.put("n_long", 10045456456L);
        map.put("n_string", "张宇晋");
        map.put("n_bigDecimal",new BigDecimal("12.12245") );
        map.put("n_date",new Date() );
        map.put("n_integer",100 );
        return map;
    }

}


```


### 2、json工具类


```java

package com.hlj.utils;

import com.fasterxml.jackson.core.JsonGenerationException;
import com.fasterxml.jackson.core.JsonParseException;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.*;
import com.fasterxml.jackson.databind.type.TypeFactory;
import net.sf.json.JSONArray;
import net.sf.json.JSONObject;
import net.sf.json.util.JSONTokener;
import org.springframework.util.Assert;

import java.io.IOException;
import java.io.Writer;
import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.List;

/**
 * Utils - JSON
 */
public final class JsonUtils {

    /**
     * ObjectMapper
     */
    private static final ObjectMapper OBJECT_MAPPER = new ObjectMapper();

    static {
        // jackson 1.9 and before
        //objectMapper.configure(DeserializationConfig.Feature.FAIL_ON_UNKNOWN_PROPERTIES, false);
        // or jackson 2.0
        OBJECT_MAPPER.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);
    }

    public static ObjectMapper getObjectMapper() {
        return OBJECT_MAPPER;
    }

    /**
     * 不可实例化
     */
    private JsonUtils() {
    }

    /**
     * 将对象转换为JSON字符串
     *
     * @param value 对象
     * @return JSON字符串
     */
    public static String toJson(Object value) {
        Assert.notNull(value, "json 不允许为空");
        try {
            return OBJECT_MAPPER.writeValueAsString(value);
        } catch (JsonProcessingException e) {
            throw new RuntimeException(e.getMessage(), e);
        }
    }

    /**
     * 将JSON字符串转换为对象
     *
     * @param json      JSON字符串
     * @param valueType 类型
     * @return 对象
     */
    public static <T> T toObject(String json, Class<T> valueType) {
        Assert.hasText(json, "json 不允许为空");
        Assert.notNull(valueType, "valueType 不允许为空");
        try {
            return OBJECT_MAPPER.readValue(json, valueType);
        } catch (JsonParseException e) {
            throw new RuntimeException(e.getMessage(), e);
        } catch (JsonMappingException e) {
            throw new RuntimeException(e.getMessage(), e);
        } catch (IOException e) {
            throw new RuntimeException(e.getMessage(), e);
        }
    }

    /**
     * 将JSON字符串转换为对象
     *
     * @param json          JSON字符串
     * @param typeReference 类型
     * @return 对象
     */
    public static <T> T toObject(String json, TypeReference<?> typeReference) {
        Assert.hasText(json, "json 不允许为空");
        Assert.notNull(typeReference, "typeReference 不允许为空");
        try {
            return OBJECT_MAPPER.readValue(json, typeReference);
        } catch (JsonParseException e) {
            throw new RuntimeException(e.getMessage(), e);
        } catch (JsonMappingException e) {
            throw new RuntimeException(e.getMessage(), e);
        } catch (IOException e) {
            throw new RuntimeException(e.getMessage(), e);
        }
    }

    /**
     * 将JSON字符串转换为对象
     *
     * @param json     JSON字符串
     * @param javaType 类型
     * @return 对象
     */
    public static <T> T toObject(String json, JavaType javaType) {
        Assert.hasText(json, "json 不允许为空");
        Assert.notNull(javaType, "javaType 不允许为空");
        try {
            return OBJECT_MAPPER.readValue(json, javaType);
        } catch (JsonParseException e) {
            throw new RuntimeException(e.getMessage(), e);
        } catch (JsonMappingException e) {
            throw new RuntimeException(e.getMessage(), e);
        } catch (IOException e) {
            throw new RuntimeException(e.getMessage(), e);
        }
    }


 /**
     * 将JSON字符串(数组或者Json) 转换为对象 用到下面这种情况的时候往往是因为使用了lombok 注解二引起
     * 报错 例如
     15:54:00.944 [main] INFO net.sf.json.JSONObject - Property 'code' of class com.duodian.youhui.admin.utils.json.data.Person has no write method. SKIPPED.
     *
     * @param json     JSON字符串
     * @param javaType 类型
     * @return 对象
     */
    public static Object toObjectOrList(String json,Class javaType) {
        Assert.hasText(json, "json 不允许为空");
        Assert.notNull(javaType, "javaType 不允许为空");
        try {
            Object jsonT = new JSONTokener(json).nextValue();
            if(jsonT instanceof JSONObject){
                return OBJECT_MAPPER.readValue(json,javaType);
            }else if (jsonT instanceof JSONArray) {
                JSONArray jsonArray = (JSONArray) jsonT;
                List objects = new ArrayList<>();
                for(int i = 0 ;i <jsonArray.size() ;i++){
                    objects.add(new ObjectMapper().readValue(jsonArray.get(i).toString(),javaType));
                }
                return objects ;
            }
            return  OBJECT_MAPPER.readValue(json,javaType);
        } catch (JsonParseException e) {
            throw new RuntimeException(e.getMessage(), e);
        } catch (JsonMappingException e) {
            throw new RuntimeException(e.getMessage(), e);
        } catch (IOException e) {
            throw new RuntimeException(e.getMessage(), e);
        }
    }


    /**
     * 将JSON字符串转换为树
     *
     * @param json JSON字符串
     * @return 树
     */
    public static JsonNode toTree(String json) {
        Assert.hasText(json, "json 不允许为空");
        try {
            return OBJECT_MAPPER.readTree(json);
        } catch (JsonProcessingException e) {
            throw new RuntimeException(e.getMessage(), e);
        } catch (IOException e) {
            throw new RuntimeException(e.getMessage(), e);
        }
    }

    /**
     * 将对象转换为JSON流
     *
     * @param writer Writer
     * @param value  对象
     */
    public static void writeValue(Writer writer, Object value) {
        Assert.notNull(writer, "writer 不允许为空");
        Assert.notNull(value, "value 不允许为空");
        try {
            OBJECT_MAPPER.writeValue(writer, value);
        } catch (JsonGenerationException e) {
            throw new RuntimeException(e.getMessage(), e);
        } catch (JsonMappingException e) {
            throw new RuntimeException(e.getMessage(), e);
        } catch (IOException e) {
            throw new RuntimeException(e.getMessage(), e);
        }
    }

    /**
     * 构造类型
     *
     * @param type 类型
     * @return 类型
     */
    public static JavaType constructType(Type type) {
        Assert.notNull(type, "type 不允许为空");
        return TypeFactory.defaultInstance().constructType(type);
    }

    /**
     * 构造类型
     *
     * @param typeReference 类型
     * @return 类型
     */
    public static JavaType constructType(TypeReference<?> typeReference) {
        Assert.notNull(typeReference, "typeReference 不允许为空");
        return TypeFactory.defaultInstance().constructType(typeReference);
    }

}
```









<br/><br/><br/>
<font color="red"> 感兴趣的，欢迎添加博主微信， </font><br/>
哈，博主很乐意和各路好友交流，如果满意，请打赏博主任意金额，感兴趣的在微信转账的时候，备注您的微信或者其他联系方式。添加博主微信哦。
<br/>
请下方留言吧。可与博主自由讨论哦

|微信 | 微信公众号|支付宝|
|:-------:|:-------:|:------:|
| ![微信](https://raw.githubusercontent.com/HealerJean/HealerJean.github.io/master/assets/img/tctip/weixin.jpg)|![微信公众号](https://raw.githubusercontent.com/HealerJean/HealerJean.github.io/master/assets/img/my/qrcode_for_gh_a23c07a2da9e_258.jpg)|![支付宝](https://raw.githubusercontent.com/HealerJean/HealerJean.github.io/master/assets/img/tctip/alpay.jpg) |




<!-- Gitalk 评论 start  -->

<link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk@latest/dist/gitalk.min.js"></script> 
<div id="gitalk-container"></div>    
 <script type="text/javascript">
    var gitalk = new Gitalk({
		clientID: `1d164cd85549874d0e3a`,
		clientSecret: `527c3d223d1e6608953e835b547061037d140355`,
		repo: `HealerJean.github.io`,
		owner: 'HealerJean',
		admin: ['HealerJean'],
		id: 'zaCZviR43AWdTIH7**',
    });
    gitalk.render('gitalk-container');
</script> 

<!-- Gitalk end -->

