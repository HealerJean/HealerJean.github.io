---
title: Iterator-一个一个遍历
date: 2019-05-22 03:33:00
tags: 
- DisignPattern
category: 
- DisignPattern
description: Iterator-一个一个遍历
---

<!-- 

https://raw.githubusercontent.com/HealerJean/HealerJean.github.io/master/blogImages/
　　首行缩进

<font  clalss="healerColor" color="red" size="5" >     </font>

<font  clalss="healerSize"  size="5" >     </font>
-->




## 前言

#### [博主github](https://github.com/HealerJean)
#### [博主个人博客http://blog.healerjean.com](http://HealerJean.github.io)    



标题上已经写明了，就是一个一个遍历



## 1、示例程序



#### 1.1、场景 

讲书放到书架上，然后使用iterator遍历讲书的信息打印出来

#### 1.2、UML图



![1558680180085](https://raw.githubusercontent.com/HealerJean/HealerJean.github.io/master/blogImages/1558680180085.png)



#### 1.3、程序代码设计

##### 1.3.1、`Aggregate` 接口： 集合接口（类似于List）

```java
/**
 * 表示集合的接口
 * 实现该接口的类将会成一个可以保存多个元素的集合（书架） 、然后书架需要被遍历，则会实现下面的方法
 */
public interface Aggregate {
     Iterator iterator();
}

```



##### 1.3.2、`Iterator   ` 接口 ：迭代器

```java

/**
 * 遍历集合的迭代器
 */
public interface Iterator {
    boolean hasNext();
    Object next();
}

```



##### 1.3.3、`Book` 类： 书

```java


import lombok.AllArgsConstructor;
import lombok.Data;

/**
 * 表示书的类
 */
@Data
@AllArgsConstructor
public class Book {
    private String name;

}


```

##### 1.3.4、：`BookShelf `：类：书架（实现了集合接口`Aggregate` 相当于ArrayList）

```java
package com.hlj.moudle.design.D02_适应者设计模式.D01_Iterator模式.Sample;


import java.util.ArrayList;
import java.util.List;

/**
 * 表示书架的类
 */
public class BookShelf implements Aggregate {

    private List<Book> books;
    private int last = 0; //书架的长度，从开始

    public BookShelf(){
        books = new ArrayList<>() ;
    }

    /**
     * 获取某一个位置index 的书
     * @param index
     * @return
     */
    public Book getBookAt(int index) {
        return books.get(index);
    }

    /**
     * 书架上放书
     * @param book
     */
    public void appendBook(Book book) {
        this.books.add(book);
        last++;
    }

    /**
     * 获取目前书架长度
     * @return
     */
    public int getLength() {
        return last;
    }

    /**
     * 获取遍历该书架的迭代器
     * @return
     */
    public Iterator iterator() {
        return new BookShelfIterator(this);
    }
}


```

##### 1.3.5、`BookShelfIterator`  类： 迭代器`Iterator   ` 实现类  

```java
package com.hlj.moudle.design.D02_适应者设计模式.D01_Iterator模式.Sample;


/**
 * 遍历书架的迭代器 类
 * 迭代器需要的参数
 * 1、要迭代的对象 bookShelf书架
 * 2、迭代到哪里了index
 */
public class BookShelfIterator implements Iterator {
    private BookShelf bookShelf;
    private int index;

    /**
     * 初始化迭代器，从 0 开始准备迭代
     * @param bookShelf
     */
    public BookShelfIterator(BookShelf bookShelf) {
        this.bookShelf = bookShelf;
        this.index = 0;
    }

    /**
     * 判断书架是否还有书
     * @return
     */
    public boolean hasNext() {
        if (index < bookShelf.getLength()) {
            return true;
        } else {
            return false;
        }
    }

    /**
     * 依次遍历 书架上的书
     * @return
     */
    public Object next() {
        Book book = bookShelf.getBookAt(index);
        index++;
        return book;
    }
}


```



##### 1.3.6、测试Main

```java
package com.hlj.moudle.design.D02_适应者设计模式.D01_Iterator模式.Sample;



public class Main {
    public static void main(String[] args) {
        BookShelf bookShelf = new BookShelf();
        bookShelf.appendBook(new Book("Around the World in 80 Days"));
        bookShelf.appendBook(new Book("Bible"));
        bookShelf.appendBook(new Book("Cinderella"));
        bookShelf.appendBook(new Book("Daddy-Long-Legs"));
        Iterator it = bookShelf.iterator();
        while (it.hasNext()) {
            Book book = (Book)it.next();
            System.out.println(book.getName());
        }
    }
}


Around the World in 80 Days
Bible
Cinderella
Daddy-Long-Legs
```



### 2、`Iterator`模式中的各种角色

#### 2.1、`Aggregate`  (接口 集合 类似于List)

该角色负责创建Iterator接口   



#### 2.2、`Iterator`（接口 迭代器 ）

iterator接口负责定义了两个方法，`next`和`hashNext`方法    

1、`next` 用于获取集合中某个索引的下一个元素   

2、`hasNext`用于判断是否存在下一个元素 



#### 2.3、ConcreteAggregate(具体的集合,类似于ArrayList)

该角色会实现`Aggregate` 角色所以定义的接口，它会创建出具体的Iterator角色，即	`ConcreteIterator`角色 ，**示例程序中 `BookShelf`扮演这个角色**





#### 2.4、`Concretelterator`( 具体的迭代器)

 该角色负责实现`iterator`所定义的接口，也就是我们上面的`BookShelfIterator`  ，**示例程序中，该角色包含了遍历集合所必须的信息 ，也就是说包含集合  `BookShelf**`

1、BookShelf  书架   

2、遍历的下标index  





### 2.5、迭代模式的类图

![1558683119564](https://raw.githubusercontent.com/HealerJean/HealerJean.github.io/master/blogImages/1558683119564.png)

### 3、扩展思路

Book数组我们直接for循环打印出来不久好了，为啥还要使用Iterator这个东西呢   ，

**原因：引入Iterator后可以讲遍历与实现分离开来      ，不管实现如何变化，都可以使用Iterator，这里只使用了Iterator的hasNext方法和next方法，并没有调用BookShelf方法，也就是说While循环不依赖BookShelf的实现**   

```java
Iterator it = bookShelf.iterator();
while (it.hasNext()) {
    Book book = (Book)it.next();
    System.out.println(book.getName());
}
```













<br/>
<br/>

<font  color="red" size="5" >     
感兴趣的，欢迎添加博主微信
 </font>

<br/>



哈，博主很乐意和各路好友交流，如果满意，请打赏博主任意金额，感兴趣的在微信转账的时候，备注您的微信或者其他联系方式。添加博主微信哦。    

请下方留言吧。可与博主自由讨论哦

|微信 | 微信公众号|支付宝|
|:-------:|:-------:|:------:|
| ![微信](https://raw.githubusercontent.com/HealerJean/HealerJean.github.io/master/assets/img/tctip/weixin.jpg)|![微信公众号](https://raw.githubusercontent.com/HealerJean/HealerJean.github.io/master/assets/img/my/qrcode_for_gh_a23c07a2da9e_258.jpg)|![支付宝](https://raw.githubusercontent.com/HealerJean/HealerJean.github.io/master/assets/img/tctip/alpay.jpg) |



<!-- Gitalk 评论 start  -->

<link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk@latest/dist/gitalk.min.js"></script> 
<div id="gitalk-container"></div>    
 <script type="text/javascript">
    var gitalk = new Gitalk({
		clientID: `1d164cd85549874d0e3a`,
		clientSecret: `527c3d223d1e6608953e835b547061037d140355`,
		repo: `HealerJean.github.io`,
		owner: 'HealerJean',
		admin: ['HealerJean'],
		id: 'AAAAAAAAAAAAAAA',
    });
    gitalk.render('gitalk-container');
</script> 

<!-- Gitalk end -->

