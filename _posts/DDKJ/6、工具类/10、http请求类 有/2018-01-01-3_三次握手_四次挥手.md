---
title: 三次握手_四次挥手+http
date: 2018-01-01 03:33:00
tags: 
- Docker
category: 
- Docker
description: 三次握手_四次挥手快下载速度
---
<!-- image url 
https://raw.githubusercontent.com/HealerJean/HealerJean.github.io/master/blogImages
　　首行缩进
<font color="red">  </font>
-->

## 前言


## 1、HTTP连接

     HTTP协议即超文本传送协议(Hypertext Transfer Protocol )，是Web联网的基础，也是手机联网常用的协议之一，HTTP协议是建立在TCP协议之上的一种应用。<br/>
     
     HTTP连接最显著的特点是客户端发送的每次请求都需要服务器回送响应，在请求结束后，会主动释放连接。从建立连接到关闭连接的过程称为“一次连接”。<br/>
     
     1）在HTTP 1.0中，客户端的每次请求都要求建立一次单独的连接，在处理完本次请求后，就自动释放连接。<br/>

     2）在HTTP 1.1中则可以在一次连接中处理多个请求，并且多个请求可以重叠进行，不需要等待一个请求结束后再发送下一个请求。<br/>

     由于HTTP在每次请求结束后都会主动释放连接，因此HTTP连接是一种“短连接”，要保持客户端程序的在线状态，需要不断地向服务器发起连接请求。通常的 做法是即时不需要获得任何数据，客户端也保持每隔一段固定的时间向服务器发送一次“保持连接”的请求，服务器在收到该请求后对客户端进行回复，表明知道客 户端“在线”。若服务器长时间无法收到客户端的请求，则认为客户端“下线”，若客户端长时间无法收到服务器的回复，则认为网络已经断开。

## 在浏览器中输入www.baidu.com

#### A）解析Web页面的URL，得到Web服务器的域名，查询本地的DNS缓存，当用户在浏览器中输入一个需要登录的网址时，系统会首先自动从Hosts文件中寻找对应的IP地址，以找到域名对应的主机IP地址（若有，则跳到4）查询远程域名根DNS，找到IP地址

#### B）通过DNS服务器获得Web服务器的IP地址

#### C）与Web服务器建立TCP连接

#### D）与Web服务器建立HTTP连接

向远程IP地址的服务器发送请求（若请求失败且未经过2，则返回2，若再再次失败，返回错误代码）

#### E）从Web服务器获得URL指定的文档

#### F）浏览器解释页面文档，并显示在屏幕



## TCP三次握手

所谓三次握手(Three-way Handshake)，是指建立一个TCP连接时，需要客户端和服务器总共发送3个包。<br/>


```
1、一开始，建立连接之前服务器和客户端的状态都为CLOSED； 
2、服务器创建socket后开始监听，变为LISTEN状态； 
3、客户端请求建立连接，向服务器发送SYN报文，客户端的状态变味SYN_SENT； 
4、服务器收到客户端的报文后向客户端发送ACK和SYN报文，此时服务器的状态变为SYN_RCVD； 
5、然后，客户端收到ACK、SYN，就向服务器发送ACK，客户端状态变为ESTABLISHED； 
6、服务器端收到客户端的ACK后变为ESTABLISHED。此时3次握手完成，连接建立！

```


![WX20190208-213200@2x](https://raw.githubusercontent.com/HealerJean/HealerJean.github.io/master/blogImages/WX20190208-213200@2x.png)


```
SYN: (同步序列编号,Synchronize Sequence Numbers)

ACK: (确认编号,Acknowledgement Number)

FIN: (结束标志,FINish)

```
### 第一次捂手：客户端发起  SYN=1，Seq=x

1、由客户端发送建立TCP连接的请求报文，其中报文中包含seq序列号，是由发送端随机生成的，并且将报文中的SYN字段置为1，表示需要建立TCP连接。（SYN=1，seq=x，x为随机生成数值）

### 第二次捂手 ：服务端发起 SYN=1，ACK=x+1，seq=y

SYN=1，ACK=x+1，seq=y ，此时服务端处于一个Syn_RECV

```
SYN=1 ：将SYN置为1

ACK=x+1 ACK字段数值是在客户端发送过来的序列号seq的基础上加1进行回复，以便客户端收到信息时，知晓自己的TCP建立请求已得到验证。ck加1可以理解为是确认和谁建立连接。

seq=y seq序列号，是由回复端随机生成的


```

### 第三次握手：客户端发起  SYN=1，ACK=y+1，seq=x+1

这个时候服务端状态为 服务器转入ESTABLISHED状态.

```
客户端收到服务端发送的TCP建立验证请求后，会使自己的序列号加1表示，

并且再次回复ACK验证请求，

在服务端发过来的seq上加1进行回复。（SYN=1，ACK=y+1，seq=x+1）
```
### SYN攻击

#### 1、攻击原理 


1 、Client伪造大量的虚假ip,向Server发送SYN包 <br/>

2、Server在接收到SYN包后,会返回响应,并进入SYN_RECV状态,等待客户端的确认<br/>

、但是伪造的ip肯定不会给予响应,于是Server以为数据包丢失,不断重发,直到超时<br/>

#### 2、危害


这些伪造的SYN包会长期占用未连接队列,导致后来真实的ip无法加入队列,从而被丢弃,引起网络拥堵甚至网络瘫痪

#### 3、如何确认是SYN攻击

    
当服务器上有大量的半连接且ip为随机的,可以确认是SYN攻击


```java
netstat -nap | grep SYN_RECV


```

#### 4、阻止

修改tcp协议实现。主要方法有SynAttackProtect保护机制、SYN cookies技术、增加最大半连接和缩短超时时间等


## 四次挥手


```
由于TCP连接是全双工的，断开连接会比建立连接麻烦一点点。 
1、客户端先向服务器发送FIN报文，请求断开连接，其状态变为FIN_WAIT1； 
2、服务器收到FIN后向客户端发送ACK，服务器的状态围边CLOSE_WAIT； 
3、客户端收到ACK后就进入FIN_WAIT2状态，此时连接已经断开了一半了。如果服务器还有数据要发送给客户端，就会继续发送； 
4、直到发完数据，就会发送FIN报文，此时服务器进入LAST_ACK状态； 
5、客户端收到服务器的FIN后，马上发送ACK给服务器，此时客户端进入TIME_WAIT状态； 
6、再过了2MSL长的时间后进入CLOSED状态。服务器收到客户端的ACK就进入CLOSED状态。 
至此，还有一个状态没有出来：CLOSING状态。 
CLOSING状态表示： 
客户端发送了FIN，但是没有收到服务器的ACK，却收到了服务器的FIN，这种情况发生在服务器发送的ACK丢包的时候，因为网络传输有时会有意外。
```

### 第一次挥手 客户端发起 FIN=1，seq=x

1、客户端发送断开TCP连接请求的报文，其中报文中包含seq序列号，是由发送端随机生成的，并且还将报文中的FIN字段置为1，表示需要断开TCP连接。（FIN=1，seq=x，x由客户端随机生成）

### 第二次挥手 服务端发起  FIN=1，ACK=x+1，seq=y

2、服务端会回复客户端发送的TCP断开请求报文，其包含seq序列号，是由回复端随机生成的，而且会产生ACK字段，ACK字段数值是在客户端发过来的seq序列号基础上加1进行回复，以便客户端收到信息时，知晓自己的TCP断开请求已经得到验证。（FIN=1，ACK=x+1，seq=y，y由服务端随机生成）

### 第三次挥手 服务端发起  FIN=1，ACK=x+1，seq=z

<font color="red">
服务端在回复完客户端的TCP断开请求后，不会马上进行TCP连接的断开，服务端会先确保断开前，所有传输到A的数据是否已经传输完毕
</font>

一旦确认传输数据完毕就会将回复报文的FIN字段置1，并且产生随机seq序列号。（FIN=1，ACK=x+1，seq=z，z由服务端随机生成）


### 第四次挥手 可发货的发起 FIN=1，ACK=z+1，seq=h

4、客户端收到服务端的TCP断开请求后，会回复服务端的断开请求，包含随机生成的seq字段和ACK字段，ACK字段会在服务端的TCP断开请求的seq基础上加1，从而完成服务端请求的验证回复。（FIN=1，ACK=z+1，seq=h，h为客户端随机生成） 


## 状态解释


```
LISTEN：等待从任何远端TCP 和端口的连接请求。

SYN_SENT：发送完一个连接请求后等待一个匹配的连接请求。

SYN_RECEIVED：发送连接请求并且接收到匹配的连接请求以后等待连接请求确认。

ESTABLISHED：表示一个打开的连接，接收到的数据可以被投递给用户。连接的数据传输阶段的正常状态。

FIN_WAIT_1：等待远端TCP 的连接终止请求，或者等待之前发送的连接终止请求的确认。

FIN_WAIT_2：等待远端TCP 的连接终止请求。

CLOSE_WAIT：等待本地用户的连接终止请求。

CLOSING：等待远端TCP 的连接终止请求确认。

LAST_ACK：等待先前发送给远端TCP 的连接终止请求的确认（包括它字节的连接终止请求的确认）

TIME_WAIT：等待足够的时间过去以确保远端TCP 接收到它的连接终止请求的确认。
TIME_WAIT 两个存在的理由：
          1.可靠的实现tcp全双工连接的终止；
          2.允许老的重复分节在网络中消逝。

CLOSED：不在连接状态（这是为方便描述假想的状态，实际不存在）
```


<br/><br/><br/>
如果满意，请打赏博主任意金额，感兴趣的请下方留言吧。可与博主自由讨论哦

|支付包 | 微信|微信公众号|
|:-------:|:-------:|:------:|
|![支付宝](https://raw.githubusercontent.com/HealerJean123/HealerJean123.github.io/master/assets/img/tctip/alpay.jpg) | ![微信](https://raw.githubusercontent.com/HealerJean123/HealerJean123.github.io/master/assets/img/tctip/weixin.jpg)|![微信公众号](https://raw.githubusercontent.com/HealerJean123/HealerJean123.github.io/master/assets/img/my/qrcode_for_gh_a23c07a2da9e_258.jpg)|




<!-- Gitalk 评论 start  -->

<link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk@latest/dist/gitalk.min.js"></script> 
<div id="gitalk-container"></div>    
 <script type="text/javascript">
    var gitalk = new Gitalk({
		clientID: `1d164cd85549874d0e3a`,
		clientSecret: `527c3d223d1e6608953e835b547061037d140355`,
		repo: `HealerJean.github.io`,
		owner: 'HealerJean',
		admin: ['HealerJean'],
		id: 'RcYBeOWix07doZIu',
    });
    gitalk.render('gitalk-container');
</script> 

<!-- Gitalk end -->

