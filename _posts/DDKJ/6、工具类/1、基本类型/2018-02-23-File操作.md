---
title: File操作
date: 2018-02-23 03:33:00
tags: 
- Io
category: 
- Io
description: File操作
---
<!-- image url 
https://raw.githubusercontent.com/HealerJean/HealerJean.github.io/master/blogImages
　　首行缩进


<font  clalss="healerColor" color="red" size="5" >     

</font>

<font  clalss="healerSize"  size="5" >     </font>

-->

## 前言

#### [博主github](https://github.com/HealerJean)
#### [博主个人博客http://blog.healerjean.com](HealerJean.github.io)    





## 1、普通文件

### 1、创建文件

```java

	/**
	 * 1、路径不存在，fileNameTxt.createNewFile() 会抛出异常
	 * 2、只有路径，不会创建出文件，也不会报错，无法创建，但是不会报错
	 * 3、路径存在，文件不存在，创建成功
	 * 4、没有路径，只有文件文件，和src一个级别，创建成功
	 * @throws IOException 
	 */
	private  void createFile(String filePath) throws IOException {
		
			File fileNameTxt = new File(filePath);
			
			if(!fileNameTxt.exists()){
				fileNameTxt.createNewFile();
			}
			System.out.println("创建成功");
	}

	@Test
	public void createFile(){
		try {
//			1、路径不存在，fileNameTxt.createNewFile() 会抛出异常
//			createFile("D:/test/file/d01_createFile/d01_no_exist");
//			2、只有路径，不会创建出文件，也不会报错，无法创建，但是不会报错
//			createFile("D:/test/file/d01_createFile/d01_exist");
//			3、路径存在，文件不存在，创建成功
//			createFile("D:/test/file/d01_createFile/d01_exist/newFile.txt");
//			4、没有路径，只有文件文件，和src一个级别，创建成功
			createFile("newFile.txt");
		} catch (IOException e) {
			e.printStackTrace();
		}
	}
```



### 2、创建有目录的文件

```java
	/**
	 * 2、创建有目录的文件
	 *  通过父的目录引入文件   directoryName 是父类
	 */
	private  void createHavaDirectoryFile(String directoryName ,String fileName) throws IOException {
		File directoryNameTxt = new File(directoryName,"directoryName.txt");
		if(!directoryNameTxt.exists()){
			directoryNameTxt.createNewFile();
		}
		System.out.println("创建有目录的文件成功");
	}

	@Test
	public void testCreateHavaDirectoryFile(){
		try {
			createHavaDirectoryFile("D:/test/file/d02_createHavaDirectoryFile","directoryName.txt");
		} catch (IOException e) {
			e.printStackTrace();
		}
	}
```



### 3、判断是文件或者目录

```java


	private  void judgeFileOrDirectory(File path) {
			System.out.println("测试开始");
			if(path.isFile()){
				System.out.println(path.getPath()+"是一个文件");
			}
			else if(path.isDirectory()){
				System.out.println(path.getPath()+"是一个目录");
			}else {
				System.out.println(path.getPath()+"不是文件也不是目录");

			}
	}
```



### 4、创建目录



```java
	

	/**
	 * 判断是不是目录
	 * 创建目录，即使路径不存在，也会创建相关路径，因为是mkdirs
	 */
	private  void createDirectory() {
		//引入目录
				File directoryName = new File("D:/test/healerjean/file");  
				if(!directoryName.exists()){
					directoryName.mkdirs();
					System.out.println(directoryName.getPath()+"创建目录成功"); 
				}
	}
```



### 5、复制文件

+ 第一个文件以及路径必须存在， 否则fileInputStream会报错
+  第二个文件可以不存在,但是路径必须存在，如果路径不存在则`new FileOutputStream`会报错



```java

	/**
	 * 4、复制文件

	 */
	 public  void copyFile(String inFilePath,String outFilePath) throws IOException{
	        FileInputStream ins = new FileInputStream(inFilePath);
	        FileOutputStream out = new FileOutputStream(outFilePath);
	        byte[] b = new byte[1024];
	        int n=0;
	        while((n=ins.read(b))!=-1){
	            out.write(b, 0, n); 
	        }
	        ins.close();
	        out.close();
	        System.out.println("复制文件成功");
	    }

	    @Test
		public void testCopyFile(){
	 	String inFilePath = "D:/test/file/d03_copyFile/exist/file.txt" ;
//	 	1、路径不存在 /FileOutputStream out = new FileOutputStream(outFilePath); FileNotFoundException 异常
			String outFilePath = "D:/test/file/d03_copyFile/no_exist/newfile.txt" ;
//		2、路径存在，文件不存在，复制成功
//			String outFilePath = "D:/test/file/d03_copyFile/exist/new.txt" ;
			try {
				copyFile(inFilePath,outFilePath);
			} catch (IOException e) {
				e.printStackTrace();
			}
		}
```



### 6、递归删除多个目录

```java

	    public  void  delteFiles(File file){
	    	//file.listFiles()是获取file这个对象也就是file这个目录下面的文件和文件夹的集合
	        File[] files=file.listFiles(); 
	        for(File f:files)
	        {
	            if(f.isDirectory())//递归调用
	            {
	                delteFiles(f);
	            }
	            else {
	                f.delete();
	            }
	        }
	        file.delete();
	        System.out.println("删除目录成功");
	    }
	    
```

### 7、递归目录下读取文件内容进行匹配



```
	private  void getFileValue(File file,String content) throws Exception {
			
	        File[] files=file.listFiles(); 
	        for(File f:files)
	        {
	            if(f.isDirectory())//递归调用
	            {
	            	getFileValue(f,content);
	            }
	            else {  
	            	String path = f.getPath();
					FileInputStream fInputStream = new FileInputStream(f);
					ByteArrayOutputStream outStream = new ByteArrayOutputStream();
					byte[] buffer = new byte[1024];
					int len = 0;
					while((len=fInputStream.read(buffer))!=-1){
						outStream.write(buffer, 0, len);
					}
					String str = new String(outStream.toByteArray(),"utf-8");
					if(str.contains(content)){
						System.out.println("第"+i+"个文件名为\n"+f.getPath());
						System.out.println("内容为\n"+str);
						i++;
					}
	            }
	        }
		}
```



### 8、获取txt文件内容 `OutputStream.toByteArray()`

```
	private  String getFileTextValue(String filePath) throws Exception {
			//  
			 FileInputStream fileInputStream = new FileInputStream(filePath);
			 ByteArrayOutputStream byteOutputStream = new ByteArrayOutputStream();
			 int len  = 0;
			 byte[] buffer = new byte[1024];
			 while((len = fileInputStream.read(buffer))!=-1){
				 OutputStream.write(buffer, 0, len);
			 }
			 String txtValue = new String(OutputStream.toByteArray());
			 System.out.println(txtValue);
			 return txtValue;
		}

```



### 9、一行一行读取

```java
# 输出流转化成字节数组
byte[] txtByteArray = byteOutputStream.toByteArray();
# 字节数组转化成字节读流
ByteArrayInputStream byteInputStream =(new ByteArrayInputStream(txtByteArray,"utf-8")
# 读流转化为 文本流                                       
InputStreamReader inputStreamReader = new InputStreamReader(byteInputStream)
# 文件开始读取                                       
BufferedReader reader = new BufferedReader(inputStreamReader);
```



```java
private  void getFileReadLineTextValue(String filePath) throws Exception {
		
			 FileInputStream fileInputStream = new FileInputStream(filePath);
			 ByteArrayOutputStream byteOutputStream = new ByteArrayOutputStream();
			 int len  = 0;
			 byte[] buffer = new byte[1024];
			 while((len = fileInputStream.read(buffer))!=-1){
				 byteOutputStream.write(buffer, 0, len);
			 }
			 byte[] txtByteArray = (byteOutputStream.toByteArray());
			 
			BufferedReader reader = new BufferedReader(new InputStreamReader(new ByteArrayInputStream(txtByteArray),"utf-8"));
	     	String lineVal =null ;
	     	int flagLength = 0;
			while((lineVal = reader.readLine()) != null ){
				flagLength++;
			 if(flagLength==1){
				 System.out.println("第"+flagLength+"行的内容为"+lineVal);
				 System.out.println(lineVal.substring(0,7));
				 System.out.println(lineVal.substring(0,8));
			 }
			 else{
				 System.out.println("第"+flagLength+"行的内容为"+lineVal);			 
			 }
			
	     	
		}

```





### 10、根据字符串生成内容

```java
	public  void getTxtByTextContent(String textContext,String fileName,String path){
		try {
				File fileDirectory = new File(path);
				if(!fileDirectory.exists()){
					fileDirectory.mkdirs();
				}
				FileOutputStream outputStream = new FileOutputStream(path+"/"+fileName);
				byte[] buffer = textContext.getBytes("utf-8");
				outputStream.write(buffer);
			    System.out.println("成功"+path+"/"+fileName);
				
			} catch (FileNotFoundException e) {
				e.printStackTrace();
			}catch (UnsupportedEncodingException e) {
				e.printStackTrace();
			} catch (IOException e) {
				e.printStackTrace();
			} 
			
		}
```



### 11、文件系统、路径

```java
		public  void testSeparator(){
			/**
			 * 1、判断哪个系统
			 */
			File directoryName	  = new File("D:"+File.separator+"test/txt.txt");
			System.out.println(directoryName.getPath()); 
			String os = System.getProperty("os.name");
			if(os.startsWith("Win")){
				System.out.printf("This system is windows");
				System.out.println(":::"+os);

			}else { //linux
				
			}
            
            
			/**
			 * 2、系统路径的代表符号 
			 * / linux 
			 * \ windows
			 */
			String fileSeparator = System.getProperty("file.separator");
			System.out.println(fileSeparator); 
			
			System.out.println(""+File.separator); 
			
			
		
```



### 12、循环调用文件

```java
/**
 * 作者 ：HealerJean
 * 日期 ：2019/3/13  下午2:34.
 * 类描述：给定一个根目录，要求遍历其中的文件及子文件夹，返回所有后缀是.txt的文件List
 *  * 要求：
 *  * 1. 不能使用递归
 */
public class Solution {

    @Test
    public void test(){
        File root = new File("/Users/healerjean/Desktop/faceFile");
        System.out.println(findTxt(root).toString());
    }

    /**
     *
     * @param root 为一个文件夹根目录
     */
    public List<File> findTxt(File root) {

        List<File> listTxtFiles = new ArrayList<>() ;

        if (root.exists()) {
            //创建一个目录集合，用于存放跟目录下面的文件夹
            LinkedList<File> directorys = new LinkedList<>();

            //获取根目录下面的子目录文件夹（如果本目录下面包含txt文件，则直接加入listTxtFiles集合中）
            File[] files = root.listFiles();
            for (File file : files) {
                //判断是否为目录，然后
                if (file.isDirectory()) {
                    directorys.add(file);
                } else if(file.getName().endsWith(".txt"))  {
                    listTxtFiles.add(new File(file.getAbsolutePath()) ) ;
                }
            }

            //创建一个临时目录，用于遍历directorys 集合中一个文件夹，如果是我们需要的txt文件，则直接加入集合中，如果该目录下包含子目录，则继续添加到directorys 集合中
            File temp_file;
            while (!directorys.isEmpty()) {
                temp_file = directorys.removeFirst();//每次遍历directorys 中的第一个目录，遍历之前将它作废
                files = temp_file.listFiles();
                for (File file : files) {
                    if (file.isDirectory()) {
                        directorys.add(file);
                    } else if(file.getName().endsWith(".txt"))  {
                        listTxtFiles.add(new File(file.getAbsolutePath()) ) ;
                    }
                }
            }
        }
        return  listTxtFiles ;

    }

}
```



## 2、流相关

### 2.1、文件url转inputStream

```java
URL url = new URL(StringEscapeUtils.unescapeHtml(netUrl));

HttpURLConnection conn = (HttpURLConnection)url.openConnection();
conn.setConnectTimeout(30*1000);
conn.setRequestProperty("User-Agent", "Mozilla/4.0 (compatible; MSIE 5.0; Windows NT; DigExt)");

InputStream  stream = conn.getInputStream();
```

### 2.2、图片url转outStream

```
URL urlStr = new URL(url);
BufferedImage bufferedImage = ImageIO.read(urlStr);

ImageIO.write(bufferedImage, "jpg", response.getOutputStream());
```



### 2.3、.MultipartFile  getBytes() getInputStream()



#### 2.3.1 `file.getInputStream() ` `FileUtils.copyInputStreamToFile`

+ 用于文件上传保存到本地文件

```java

File localFile = new File(tempFile,fileName);
FileUtils.copyInputStreamToFile(file.getInputStream(),localFile);

```



#### 2.3.2、 file.getBytes();

+ 用于文件上传保存到本地文件

```java

File localFile = new File(tempFile,fileName);
byte[] bytes = file.getBytes();
BufferedOutputStream stream = new BufferedOutputStream(new FileOutputStream(localFile));
stream.write(bytes);
```



#### 2.3.3、file.transferTo

+ 用于文件上传保存到本地文件

```
<dependency>
    	<groupId>commons-fileupload</groupId>
    	<artifactId>commons-fileupload</artifactId>
    	<version>1.3.1</version>
</dependency>



File localFile = new File(tempFile,fileName);
file.transferTo(localFile);
```



#### 2.3.4、 IOUtils.copy(inputStream, outputStream);

+ 用于我们读取本地文件、传输到 response.getOutputStream();

```java
 IOUtils.copy(inputStream, outputStream);
```


    
 



<br><br>    
<font  color="red" size="5" >     
感兴趣的，欢迎添加博主微信
 </font>
<br>
哈，博主很乐意和各路好友交流，如果满意，请打赏博主任意金额，感兴趣的在微信转账的时候，备注您的微信或者其他联系方式。添加博主微信哦。    

请下方留言吧。可与博主自由讨论哦

|微信 | 微信公众号|支付宝|
|:-------:|:-------:|:------:|
| ![微信](https://raw.githubusercontent.com/HealerJean/HealerJean.github.io/master/assets/img/tctip/weixin.jpg)|![微信公众号](https://raw.githubusercontent.com/HealerJean/HealerJean.github.io/master/assets/img/my/qrcode_for_gh_a23c07a2da9e_258.jpg)|![支付宝](https://raw.githubusercontent.com/HealerJean/HealerJean.github.io/master/assets/img/tctip/alpay.jpg) |



<!-- Gitalk 评论 start  -->

<link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk@latest/dist/gitalk.min.js"></script> 
<div id="gitalk-container"></div>    
 <script type="text/javascript">
    var gitalk = new Gitalk({
		clientID: `1d164cd85549874d0e3a`,
		clientSecret: `527c3d223d1e6608953e835b547061037d140355`,
		repo: `HealerJean.github.io`,
		owner: 'HealerJean',
		admin: ['HealerJean'],
		id: '1wLfAtRkbWX2NiQO',
    });
    gitalk.render('gitalk-container');
</script> 

<!-- Gitalk end -->

