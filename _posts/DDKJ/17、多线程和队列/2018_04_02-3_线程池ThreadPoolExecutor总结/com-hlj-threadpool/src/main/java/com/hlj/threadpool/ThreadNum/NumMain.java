package com.hlj.threadpool.ThreadNum;

/**
 * @Description
 * @Author HealerJean
 * @Date 2018/4/3  下午2:48.
excel打入几十万条数据的时候，先放到队列中，再保存到数据库中，其中开启两个线程池，每个线程池提供给NCPU。一遍读取一遍（读取队列中的）写入

 */
public class NumMain {
    public static void main(String[] args) {
        //返回可用处理器的Java虚拟机的数量。
        //这个值可以在虚拟机中的某个调用过程中改变。应用程序是可用的处理器数量敏感，因此应该偶尔查询该属性，并适当调整自己的资源使用情况。

        //如果是CPU密集型任务，就需要尽量压榨CPU，参考值可以设为 NCPU+1
        //如果是IO密集型任务，参考值可以设置为2*NCPU
        //   一般情况下,CPU核心数 == 最大同时执行线程数.在这种情况下(设CPU核心数为n),大量客户端会发送请求到服务器,
        // 但是服务器最多只能同时执行n个线程.

        //设线程池工作队列长度为m,且m>>n,则此时会导致CPU频繁切换线程来执行(如果CPU使用的是FCFS,则不会频繁切换,
        // 如使用的是其他CPU调度算法,如时间片轮转法,最短时间优先,则可能会导致频繁的线程切换).

        //        1.1: CPU密集型:
        //
        //                例如,一般我们系统的静态资源,比如js,css等,会存在一个版本号,如 main.js?v0,每当用户访问这个资源的时候,会发送一个比对请求到服务端,比对本地静态文件版本和服务端的文件版本是否一致,不一致则更新.这种任务一般不占用大量IO,所以后台服务器可以快速处理,压力落在CPU上.
        //
        //        1.2: I/O密集型:
        //
        //                比方说近期我们做的万科CRM系统,常有大数据量的查询和批量插入操作,此时的压力主要在I/O上.
        System.out.println(Runtime.getRuntime().availableProcessors());


    }
}
