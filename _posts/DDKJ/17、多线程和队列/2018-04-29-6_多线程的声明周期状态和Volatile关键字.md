---
title: 6、多线程的声明周期状态
date: 2018-03-06 03:33:00
tags: 
- Thread
category: 
- Thread
description: docker的安装和配置国内镜像加快下载速度
---
<!-- image url 
https://raw.githubusercontent.com/HealerJean123/HealerJean123.github.io/master/blogImages
　　首行缩进
<font color="red">  </font>
-->

## 前言

## 1、线程的几种状态

之前我们说过线程的状态有新建、就绪、运行、阻塞、死亡。但是这是不全面的。一般概况就是 新建状态、运行状态、、阻塞、无限等待状态、、有限等待状态、死亡、


```
/**
 * @Description
 * @Author HealerJean
 * @Date 2018/4/28  上午11:25.
 */
public class ThreadStatus {

    @Test
    public void threadStatus(){

        for(Thread.State state:Thread.State.values()){
            System.out.println(state.name());
        }
    }
}


NEW //新建状态
RUNNABLE //运行状态
BLOCKED //阻塞状态
WAITING //调用object.wait(),object.join() ，如果将它变成RUNNABLE状态调用Object.notify()
TIMED_WAITING  //这个和wainting有点类似，但是这个是有时间限制的。如果超过了时间，自动变成RUNNABLE
TERMINATED //terminated 当抛出异常或者是正常结束就会变成这个状态

```

## 2、Java 内存模型中的可见性、原子性和有序性。

可见性：
　　可见性是一种复杂的属性，因为可见性中的错误总是会违背我们的直觉。通常，我们无法确保执行读操作的线程能适时地看到其他线程写入的值，有时甚至是根本不可能的事情。为了确保多个线程之间对内存写入操作的可见性，必须使用同步机制。
　　可见性，是指线程之间的可见性，一个线程修改的状态对另一个线程是可见的。也就是一个线程修改的结果。另一个线程马上就能看到。比如：用volatile修饰的变量，就会具有可见性。volatile修饰的变量不允许线程内部缓存和重排序，即直接修改内存。所以对其他线程是可见的。但是这里需要注意一个问题，volatile只能让被他修饰内容具有可见性，但不能保证它具有原子性。比如 volatile int a = 0；之后有一个操作 a++；这个变量a具有可见性，但是a++ 依然是一个非原子操作，也就是这个操作同样存在线程安全问题。
　　在 Java 中 volatile、synchronized 和 final 实现可见性。
原子性：
　　原子是世界上的最小单位，具有不可分割性。比如 a=0；（a非long和double类型） 这个操作是不可分割的，那么我们说这个操作时原子操作。再比如：a++； 这个操作实际是a = a + 1；是可分割的，所以他不是一个原子操作。非原子操作都会存在线程安全问题，需要我们使用同步技术（sychronized）来让它变成一个原子操作。一个操作是原子操作，那么我们称它具有原子性。java的concurrent包下提供了一些原子类，我们可以通过阅读API来了解这些原子类的用法。比如：AtomicInteger、AtomicLong、AtomicReference等。
　　在 Java 中 synchronized 和在 lock、unlock 中操作保证原子性。
有序性：
　　Java 语言提供了 volatile 和 synchronized 两个关键字来保证线程之间操作的有序性，volatile 是因为其本身包含“禁止指令重排序”的语义，synchronized 是由“一个变量在同一个时刻只允许一条线程对其进行 lock 操作”这条规则获得的，此规则决定了持有同一个对象锁的两个同步块只能串行执行。




## 2、Volatile关键字

Volatile字面有有易挥发的意思，说明就是不稳定的意思，<font color="red"> volatile关键字用于修饰共享可变变量，即，没有使用final关键字修饰的实例变量或者静态变量（说白了就是全局变量中的实例变量和静态变量)，相应的变量就是volatile变量 </font>

```
private volatile int a; 
```
<br/>由于它的不稳定的性质，所以读取和写操作都必须从高速缓存或者是主内存中读取，因此volatile变量不会被编译器分配到寄存器中存储，对volatile变量都是内存访问。







```
/**
 * @Description
 * @Author HealerJean
 * @Date 2018/4/28  下午3:19.
 */
public class VolitateAndStatic {
    static int i = 1;   
     int j = 1; 

}


public class Main {
    public static void main(String[] args) {

        VolitateAndStatic one = new VolitateAndStatic();
        System.out.println("one"+one.j++); //1
        System.out.println("one"+one.j++); //2

        VolitateAndStatic two = new VolitateAndStatic();
        System.out.println("two"+two.j++); // 1

        System.out.println(VolitateAndStatic.i++);//1
        System.out.println(VolitateAndStatic.i++);//2

    }
}


```



### 2.1、作用:
保障可见性，有序性，保障long/double型变量读写操作的原子性。

对于volatile变量，java虚拟机在写操作之前会插入一个释放屏障，并在写操作之后插入一个存储屏障。这样就保证了有序性和可见性。






<br/><br/><br/>
如果满意，请打赏博主任意金额，感兴趣的请下方留言吧。可与博主自由讨论哦

|支付包 | 微信|微信公众号|
|:-------:|:-------:|:------:|
|![支付宝](https://raw.githubusercontent.com/HealerJean123/HealerJean123.github.io/master/assets/img/tctip/alpay.jpg) | ![微信](https://raw.githubusercontent.com/HealerJean123/HealerJean123.github.io/master/assets/img/tctip/weixin.jpg)|![微信公众号](https://raw.githubusercontent.com/HealerJean123/HealerJean123.github.io/master/assets/img/my/qrcode_for_gh_a23c07a2da9e_258.jpg)|




<!-- Gitalk 评论 start  -->

<link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk@latest/dist/gitalk.min.js"></script> 
<div id="gitalk-container"></div>    
 <script type="text/javascript">
    var gitalk = new Gitalk({
		clientID: `1d164cd85549874d0e3a`,
		clientSecret: `527c3d223d1e6608953e835b547061037d140355`,
		repo: `HealerJean123.github.io`,
		owner: 'HealerJean123',
		admin: ['HealerJean123'],
		id: 'c3tNKgjDaTAKn5EF',
    });
    gitalk.render('gitalk-container');
</script> 

<!-- Gitalk end -->

