---
title: AI之_1_大模型基础
date: 2025-11-14 00:00:00
tags: 
- AI
category: 
- AI
description: AI之_1_大模型基础
---

**前言**     

 Github：[https://github.com/HealerJean](https://github.com/HealerJean)         

 博客：[http://blog.healerjean.com](http://HealerJean.github.io)          



# 一、机器学习基础

## 1、引言：机器学习的时代

### 1）什么是机器学习？

> > 机器学习是让计算机从经验中学习，而不是通过显式编程。" — Arthur Samuel, 1959
>
> **机器学习定义**：机器学习是人工智能的一个分支，研究如何使计算机系统利用经验（数据）改善性能，而无需显式编程具体规则。



### 2） 为什么机器学习重要？

- **数据爆炸**：全球数据量呈指数级增长，传统方法无法处理
  - 假设一家电商平台（如淘宝或亚马逊）每天产生数亿条用户行为记录（点击、浏览、购买、评价等）。如果用人工或传统数据库查询方式分析这些数据，不仅效率极低，而且难以实时响应。而机器学习模型可以自动处理这些海量数据，从中提取有用信息，比如预测用户可能喜欢的商品（推荐系统），这在传统方法下几乎不可能高效实现。
- **模式识别**：人类无法在海量数据中发现复杂模式
  - 在医学影像诊断中，医生肉眼观察 `CT` 或 `MRI` 图像可能会遗漏微小的肿瘤病灶。而训练好的深度学习模型（如卷积神经网络）可以从成千上万张标注过的医学图像中学习到人眼难以察觉的细微特征，从而辅助甚至超越人类专家的诊断准确率。这种高维、非线性的模式识别能力是人类难以企及的。
- **自动化决策**：在速度、规模和一致性上超越人类
  - 信用卡公司需要在毫秒内判断一笔交易是否为欺诈。每天有数千万笔交易，不可能靠人工审核。机器学习模型可以在交易发生的瞬间，结合用户历史行为、地理位置、消费习惯等上百个特征，自动做出是否拦截的决策，既快速又一致，大幅降低欺诈损失。
- **商业价值**：麦肯锡报告指出，到 `2030` 年 `AI` 可为全球经济贡献13万亿美元
  - 制造业企业利用机器学习优化供应链，预测零部件需求、减少库存积压；物流公司（如UPS、顺丰）用AI规划最优配送路线，每年节省数亿美元燃油和人力成本；金融公司通过算法交易在毫秒间捕捉市场机会。这些应用直接转化为利润增长和效率提升，正是AI/ML驱动经济价值的具体体现。



### 3）机器学习与传统编程的区别

**传统编程 = 教学生解题步骤**： 老师说：“遇到这种题，先用公式 `A`，再代入`B……`”

**机器学习 = 给学生看1000道例题和答案，让他自己总结解法**：学生通过大量练习，摸索出规律，甚至可能发现老师没教过的技巧！

| 传统编程          | 机器学习                   |
| ----------------- | -------------------------- |
| 输入：规则 + 数据 | 输入：数据 + 答案          |
| 输出：答案        | 输出：规则                 |
| 人类定义逻辑      | 系统从数据学习逻辑         |
| 适合确定性问题    | 适合不确定性、复杂模式问题 |







## 2、机器学习分类

> 监督学习靠“答案”学预测，无监督学习靠“数据”找规律，半监督学习则巧妙结合两者，在现实世界中最具实用价值。

| 类型           | 是否需要标签 | 数据特点              | 典型目标     | 适用场景             |
| -------------- | ------------ | --------------------- | ------------ | -------------------- |
| **监督学习**   | ✅ 完全需要   | 输入 + 标签           | 预测准确输出 | 分类、回归等明确任务 |
| **半监督学习** | ⚠️ 少量需要   | 少量标签 + 大量无标签 | 提升泛化能力 | 标注成本高、数据量大 |
| **无监督学习** | ❌ 不需要     | 仅有输入              | 发现隐藏结构 | 探索分析、预处理     |



### 1）**监督学习（Supervised Learning）**

> “有老师教” —— 每个样本都有标准答案。

- **核心思想**：从带标签的数据中学习输入 → 输出的映射函数。
- **训练数据形式**：每个样本由 **输入特征**（如邮件文本、房屋面积）和 **对应标签**（如“垃圾/正常”、“价格”）组成。
- **学习目标**：从带标签的数据中自动学习一个 **输入 → 输出的映射函数**，使得对新数据也能做出准确预测。
- **优势**：
  - 训练过程较为清晰，容易理解。
  - 在有足够标注数据的情况下，模型可以非常准确地进行预测。
- **挑战**：
  - 依赖大量标注数据：标注数据需要人工进行，尤其在某些领域（如医学、法律等）标注成本很高。
  - 过拟合风险：模型可能会在训练数据上表现很好，但在新数据上表现不佳，尤其是在训练数据不足或质量不高时。

- **典型任务与应用举例**
  - **分类任务（离散的标签）**：例如垃圾邮件检测、情感分析、手写数字识别（MNIST数据集）。
  - **回归任务（连续的数值）**：例如房价预测、股票市场预测、天气预测。



### 2）非监督学习（Unsupervised Learning）

> **“自学成才”——没有标准答案，自己找规律**

- **核心思想**：
  - **不依赖于标注数据**。训练数据没有标签，目标是从数据中发现潜在的结构、模式或规律，而**不是预测具体的输出标签**。
  - 非监督学习的关键在于通过不同的算法来**揭示数据内部的潜在关系**。
  - **命名过程是“解释”，不是“预测”**。模型本身并不知道“标签”是什么意思。
- **训练数据形式**：仅有输入数据，**没有任何标签**。
  - 识别数据中的内在结构或规律，如聚类、降维、异常检测等。
  - 示例：一堆用户浏览记录，但不知道他们属于哪类人群。
- **学习目标**：发现数据内部的**隐藏结构、分布模式或简化表示**，帮助人类理解或为后续任务做准备。
- **优势**：无需标注，适用于探索性数据分析。
- **挑战**：结果难以评估，解释性较弱。



- **典型任务与应用举例**
  - **聚类（Clustering）**：将相似对象分组
    - 客户细分（高价值客户 / 价格敏感型客户）
    - 新闻文章自动归类（体育 / 财经 / 娱乐）
    - 社交网络中的社区发现
  - **降维（Dimensionality Reduction）**：压缩特征数量，保留关键信息
    - 将1000维人脸图像压缩到50维用于可视化（如 t-SNE）
    - 去除冗余特征以加速模型训练（如 PCA）
  - **异常检测（Anomaly Detection）**：识别罕见或异常点
    - 信用卡欺诈交易检测
    - 工业设备传感器异常预警
    - 网络入侵行为识别



### 3）半监督学习（Semi-supervised Learning）

> **“少量老师 + 大量自学”——现实中最常用的折中方案**

- **核心思想**：
  - 假设相似输入应有相似输出（平滑性假设）
  - 数据往往集中在低维流形上（流形假设）
- **训练数据形式**：**少量带标签数据 + 大量无标签数据**。
  - 示例：1000 张医学影像中，只有 50 张由专家标注了病变区域，其余 950 张未标注。
- **学习目标**：利用无标签数据的分布信息，**提升模型在有限标注下的泛化能力**，降低对人工标注的依赖。
- **优势**：在标注稀缺场景下显著提升性能，贴近真实业务需求。



- **典型应用场景**：
  - **医疗影像分析**：医生标注成本极高，但医院有大量历史影像。
  - **语音识别**：标注语音转文字耗时，但可收集海量未标注语音。
  - **网页分类**：互联网上有无数网页，但人工打标签只能覆盖极小部分。



## 3、监督学习算法与应用场景

**定义**：利用**带标签的数据集**（输入 + 正确输出）训练模型，使其能对新输入做出准确预测。

**两大任务类型**：

- **分类（Classification）**：预测离散类别（如“是/否”、“猫/狗/鸟”）
  - 输入是数据（如文本、图像），输出是一个**类别标签**（比如“垃圾/非垃圾”、“正向/负向”、“0~9 的数字”）。
  - 标签是**离散的、有限的**，不是连续值。
- **回归（Regression）**：预测连续数值（如价格、温度、概率）
  - 输出是一个**连续的数值**，而不是类别。
  - 模型要预测的是“多少”、“多大”、“多高”。

| 算法     | 类型        | 核心思想                                                     | 人设             | 典型台词                        |
| -------- | ----------- | ------------------------------------------------------------ | ---------------- | ------------------------------- |
| 线性回归 | 回归        | “咱俩关系是条直线——你变多少，我就跟着变多少！” → 用直线拟合数值关系 | 精算师           | “根据数据，房价应该是428万。”   |
| 逻辑回归 | 分类        | “我算你‘像坏人的概率’，超过80%就拉黑！” → 用概率判断类别归属 | 银行风控员       | “你的违约风险太高，不能贷款。”  |
| 决策树   | 分类 & 回归 | “先问是不是？再问有没有？一步步问到底！” → 像医生问诊一样层层判断 | 老中医           | “先看有没有发烧，再看舌苔……”    |
| 随机森林 | 分类 & 回归 | “别信一个人，叫100个专家投票说了算！” → 多棵树集体决策防翻车 | 专家评审团       | “100个专家，92个说你是羊毛党！” |
| `SVM`    | 分类        | “你是谁？看你站在哪条‘警戒线’的哪一边！” → 靠全局划出最宽安全边界 | 高维空间划线大师 | “这条分界线，必须最宽最安全！”  |
| `KNN`    | 分类 & 回归 | “你是谁？看看你身边的朋友是谁！” → 靠邻居投票定身份          | 社交达人         | “跟你玩得好的人都喜欢这首歌！”  |
| 神经网络 | 分类 & 回归 | “我不告诉你规则，但我看几百万遍就会了！” → 从海量数据中自动挖复杂规律 | AI全能选手       | “照片、语音、文字？统统拿下！”  |



### 1）**线性回归（Linear Regression）**

- **类型**：回归

- **原理**：假设输入特征与输出之间存在线性关系，通过最小化预测误差拟合直线（或超平面）。

- **优点**：简单、可解释性强、计算高效。

- **应用场景**：

  - 房价预测（基于面积、地段、房龄等）
  - 销售额预测（基于广告投入、季节因素）
  - 能耗估计（如工厂电力消耗）

- 举例：预测一个连续数字

  - ```
    例子：房产中介小李的“房价计算器”
    
    小李想开发一个小程序，输入房子信息就能估算价格。他收集了过去一年的数据：
    
    房屋面积（80㎡）
    楼层（12层）
    距地铁距离（500米）
    建造年份（2015年）
    他用线性回归训练模型，发现：
    
    “每多10㎡，房价涨30万；离地铁每远1公里，房价降8万……”
    
    现在客户问：“这套90㎡、离地铁300米的房子值多少？”
    
    模型立刻输出：428万元 
    ```

![image-20251124194309555](/Users/zhangyujin1/Desktop/HealerJean/HCode/HealerJean.github.io/blogImages/image-20251124194309555.png)



### 2）逻辑回归（Logistic Regression）

> 判断“是 or 否”

- **类型**：分类（主要用于二分类，也可扩展至多分类）虽叫“回归”，但本质是**分类算法**！

- **原理**：用 Sigmoid 函数将线性组合映射到 [0,1] 区间，表示属于某类的概率。

- **优点**：输出具有概率意义，训练快，适合基线模型。

- **应用场景**：

  - 垃圾邮件识别（是/否）
  - 客户流失预测（是否会取消订阅）
  - 信用评分（是否可能违约）

- 举例：判断“是 or 否”

  - ```
    例子：银行风控系统自动拒贷
    
    某银行每天收到上万笔贷款申请。系统要快速判断：“这个人会不会还不上钱？”
    
    输入特征：
    
    月收入（¥15,000）
    信用卡逾期次数（2次）
    工作年限（3年）
    逻辑回归模型计算后输出：
    
    “违约概率 = 78%” → 系统自动标记为高风险，拒绝放款。
    
    虽然叫“回归”，但它干的是分类的活儿！
    ```

    

### 3）**决策树（Decision Tree）**

- **类型**：分类 & 回归
- **原理**：通过一系列 if-else 规则对数据进行分层划分，形成树状结构。
- **优点**：直观、可解释、无需特征缩放、能处理非线性关系。
- **应用场景**：
  - 医疗诊断辅助（根据症状判断疾病）
  - 贷款审批规则（收入 > X 且 信用分 > Y → 批准）
  - 游戏AI中的行为决策树

- 举例：像医生问诊一样层层判断

  - ```
    你输入症状：“发烧 + 咳嗽 + 无味觉”
    
    决策树这样推理：
    
    text
    编辑
    是否有味觉丧失？
     ├─ 是 → 可能是新冠（建议做核酸）
     └─ 否 → 是否有黄痰？
          ├─ 是 → 可能是细菌感染（建议看呼吸科）
          └─ 否 → 普通感冒（多喝水休息）
    整个过程像一棵“判断树”，规则清晰，普通人也能看懂。
    ```



### 4）随机森林（Random Forest）

- **类型**：分类 & 回归（集成学习）

- **原理**：构建多个决策树，每棵树在随机样本和随机特征上训练，最终投票或平均结果。

- **优点**：抗过拟合强、鲁棒性好、自动评估特征重要性。

- **应用场景**：

  - 金融风控（欺诈检测）
  - 生物信息学（基因表达数据分析）
  - 推荐系统（用户偏好预测）

- 举例： 多个专家投票，结果更靠谱

  - ```
    例子：电商平台识别“羊毛党”
    
    有些用户专门注册小号抢优惠券，薅平台羊毛。
    
    平台用随机森林分析用户行为：
    
    账号注册时间（刚注册1小时）
    下单频率（5分钟下3单）
    收货地址（全是同一个快递柜）
    支付方式（全是同一张银行卡）
    每棵“决策树”给出判断（是/否羊毛党），最后100棵树投票：
    
    92票认为是 → 系统自动冻结账号！
    
    因为融合了多个视角，比单棵树更准、更稳。
    ```



### 5）**支持向量机（SVM, Support Vector Machine）**

> **SVM 就是在两类东西之间，找一条“最安全、最宽敞”的分界线，让以后来的新东西不容易站错队。**

- **类型**：分类（也可用于回归，称 SVR）

- **原理**：寻找一个最优超平面，最大化不同类别之间的间隔（margin）。

- **优点**：在高维空间表现优异，适合小样本。

- **应用场景**：

  - 文本分类（新闻主题识别）
  - 图像识别（早期人脸识别）
  - 生物序列分析（蛋白质结构预测）

- **举例：**在高维空间划一条“最宽的分界线”

  - ```
    例子：新闻网站自动分类文章
    
    编辑收到一篇新文章，标题《美联储加息影响全球股市》。
    
    SVM 把文章转成几千维的词向量（比如“加息”“股市”“美元”权重高），然后在高维空间中：
    
    找到一条“边界”，把财经类和体育类新闻尽可能分开，且边界最宽。
    
    结果：这篇文章被准确归入 “财经”频道，无需人工干预。
    
    特别适合文本、基因等高维稀疏数据。
    ```



### 6）**K近邻算法（K-Nearest Neighbors, KNN）**

- **类型**：分类 & 回归

- **原理**：对新样本，找训练集中最相似的 K 个邻居，按多数投票（分类）或平均（回归）决定输出。

- **优点**：无需训练过程（懒惰学习），适合局部模式。

- **应用场景**：

  - 推荐系统（“喜欢这个商品的人也喜欢…”）
  - 地理位置服务（附近相似用户的行为）
  - 手写字符识别（早期 OCR）

- 举例：“物以类聚”——看邻居是谁

  - ```
    例子：音乐App推荐歌单
    
    你刚听了周杰伦的《七里香》，App怎么知道你可能喜欢《晴天》？
    
    它用 KNN 找出和你听歌习惯最像的10个用户（邻居），发现他们也都喜欢：
    
    《晴天》
    《稻香》
    《夜曲》
    于是系统推荐：“这些歌你可能也爱听！” 🎵
    
    核心思想：相似的人，喜欢相似的东西。
    ```



### 7）**神经网络 / 深度学习（Neural Networks）**

- **类型**：分类 & 回归（尤其擅长复杂非线性问题）

- **原理**：模拟人脑神经元，通过多层非线性变换自动提取特征。

- **常见架构**：

  - **`MLP`（多层感知机）**：通用前馈网络
  - **`CNN`（卷积神经网络）**：图像处理
  - **`RNN` / `Transformer`**：序列数据（文本、语音）

- **应用场景**：

  - 图像识别（人脸识别、自动驾驶视觉）
  - 语音识别（Siri、智能音箱）
  - 机器翻译（Google Translate）
  - 股票趋势预测（结合时序模型）

- 举例：**自动从原始数据中“挖”出复杂规律**

  - 图像场景：手机人脸解锁

    - ```
      你刷脸解锁手机时，背后的卷积神经网络（CNN） 正在工作：
      
      输入：你前置摄像头拍的照片
      网络自动识别：眼睛间距、鼻梁高度、下巴轮廓……
      输出：匹配你本人的概率 = 99.6% → 解锁成功！
      ```

    - 语音场景：智能音箱听懂方言

      - ```
        你说：“小爱同学，播放邓丽君的歌。”
        
        即使带点四川口音，RNN 或 Transformer 模型也能：
        
        把声音转成文字
        理解“邓丽君”是歌手名
        自动播放《甜蜜蜜》
        ```

    - 文本场景：AI写周报

      - ```
        你输入：“本周完成了用户登录模块开发，修复了3个bug。”
        ```





## 4、非监督学习

| 算法      | 类型            | 大白话总结                       |
| --------- | --------------- | -------------------------------- |
| `K-means` | 聚类            | “谁跟谁像，就放一块儿”           |
| 层次聚类  | 聚类            | “从小团合并成大树”               |
| `PCA`     | 降维            | “抓住重点，删掉废话”             |
| 自编码器  | 降维 + 特征提取 | “压缩+还原，学会记要点”          |
| 孤立森林  | 异常检测        | “谁容易被单独圈出来，谁就是异类” |

### 1）**K-Means 聚类**

> **`K-Means` 没有预测标签，但它帮人类发现了隐藏的用户结构。**

- **类型**：聚类（`Clustering`）

- **原理**：将数据划分为 `K` 个簇，使得每个簇内的样本彼此相似（距离近），而不同簇之间差异较大。通过迭代优化簇中心（质心）位置，最小化簇内平方和（`WCSS`）。

  - 先随便选 `K` 个“中心点”，然后把每个数据点分给离它最近的中心；
    - 接着根据新分好的组，重新算出每组的中心；
    - 反复这样“分组 → 更新中心”，直到分组不再变化。

- **优点**：简单高效、易于实现、适用于大规模数据集。

- **应用场景**：

  - 客户分群（如高价值客户 vs 价格敏感型客户）
  - 图像压缩（将颜色聚类减少色数）
  - 新闻主题自动归类

- **举例**：把用户自动分成几类

  - ```
    例子：电商平台的用户画像分群
    
    某电商收集了10万用户的以下行为数据：
    - 月均消费金额
    - 浏览商品次数
    - 是否经常使用优惠券
    
    使用 K-Means（K=3）后，系统自动发现三类用户：
    1. “高消费+少用券” → 品牌忠诚型
    2. “低消费+高频浏览” → 潜在转化型
    3. “中等消费+大量用券” → 价格敏感型
    
    运营团队据此推送不同促销策略，转化率提升20%。
    ```

![image-20251124195427307](/Users/zhangyujin1/Desktop/HealerJean/HCode/HealerJean.github.io/blogImages/image-20251124195427307.png)

### 2）**层次聚类（`Hierarchical Clustering`）**

- **类型**：聚类（`Clustering`）

- **原理**：通过构建树状图（`Dendrogram`）逐步合并或分裂样本，形成一个“嵌套”的聚类结构。可以是“自底向上”（凝聚式）或“自顶向下”（分裂式）。

  - 核心思想：**从小到大，层层合并，像建族谱一样。**
  - **大白话解释**： 想象你在整理一堆乱七八糟的玩具。 一开始每个玩具都是独立的“小团伙”。 然后你发现：两个小汽车很像 → 合成一个“车族”； 两个毛绒熊也像 → 合成“熊族”；再发现“车族”和“熊族”都不太像，但“车族”和“积木”有点像 → 继续合并……最后所有玩具变成一棵“家族树”。

- **优点**：能展示数据的层级关系、无需预先指定簇数、适合小到中等规模数据。

- **应用场景**：

  - 生物分类（如物种进化树）
  - 文件系统组织（文档自动归档）
  - 社交网络社区发现

- **举例**：从基因数据构建进化树

  - ```
    例子：生物学家研究鸟类亲缘关系
    
    收集了 10 种鸟的 DNA 序列，计算它们之间的相似度。
    使用层次聚类后，生成一棵树形图：
    - 麻雀和燕子先聚在一起 → 同属“鸣禽”
    - 鸵鸟和企鹅再聚 → 同属“不会飞的鸟”
    - 最后所有鸟汇聚成一个大分支
    
    科学家据此推测：这些鸟可能来自共同祖先，
    并验证了现有分类系统的合理性。
    ```



### 3）**主成分分析（`PCA`, Principal Component Analysis）**

- **类型**：降维（`Dimensionality Reduction`）

- **原理**：通过线性变换将高维数据投影到低维空间，保留数据中方差最大的方向（主成分），从而在尽可能保留信息的前提下减少特征数量。

  - 核心思想：**抓住数据里最“变化大”的部分，其他都忽略。**
  - **大白话解释**： 假如你拍了一张照片，但相机是3D的，有上万个像素点。 你想把这张图压缩成一张2D小图，还能认出是谁。PCA 就是帮你找出“最关键的方向”——比如脸朝哪边、眼睛在哪、鼻子多高。 只保留这些最重要的信息，扔掉那些不重要的细节（比如衣服上的花纹），让图像变小但依然能认人。

- **优点**：去除冗余特征、降低计算复杂度、缓解维度灾难、便于可视化。

- **应用场景**：

  - 高维数据可视化（如将100维数据降到2D绘图）
  - 人脸识别中的特征压缩
  - 基因表达数据分析

- **举例**：把100个指标压缩成2个看趋势

  - ```
    例子：金融风控中的多维指标简化
    
    银行对每位客户有80个风险指标（收入、负债、逾期次数、社交网络评分等）。
    直接建模太复杂，且很多指标高度相关。
    
    使用 PCA 将80维数据压缩为2个主成分：
    - 主成分1：综合“偿债能力”
    - 主成分2：综合“行为稳定性”
    
    在二维平面上画出所有客户，一眼看出哪些是高风险群体，
    同时模型训练速度提升5倍。
    ```



### 4）**自编码器（Autoencoders）**

> 自编码器就像“照镜子”——它不关心你是谁，只关心能不能把你“复刻”出来。

- **类型**：降维 + 特征提取（深度学习方法）

- **原理**：一种神经网络，由“编码器”和“解码器”组成。编码器将输入压缩成低维表示（隐层），解码器尝试从该表示还原原始输入。目标是让重构误差最小。

  - 核心思想：**学会“压缩+还原”，过程中记住核心特征。**
  - **大白话解释**： 就像你有一个“记事本”，要记住一段很长的话，但只能写一句话。你得先把它浓缩成一句话（编码），然后再用这句话还原出原话（解码）。最开始你还原得很差，但练多了，就能记住关键信息，比如“今天下雨了，我没带伞”。 这样你不仅能压缩信息，还能判断“这段话是不是胡说八道”（如果还原不出来就是异常）。

- **优点**：能学习非线性特征、可用于异常检测、图像去噪、生成新数据。

- **应用场景**：

  - 图像去噪（如模糊照片修复）
  - 异常检测（如设备传感器突变）
  - 生成对抗网络（`GANs`）的基础组件

- **举例**：让AI学会“看懂”一张脸的核心特征

  - ```
    例子：人脸识别系统的预处理模块
    
    输入：一张含噪声的人脸图像（像素点混乱）
    编码器将其压缩成一个 128 维向量（隐藏表征）
    解码器尝试还原图像 → 输出清晰人脸
    
    当某张图无法被准确还原（重构误差 > 阈值），
    系统判断为“异常图像”（可能是伪造或遮挡）。
    
    此外，这个 128 维向量可作为后续识别任务的特征输入。
    ```



### 5）**孤立森林（`Isolation Forest`）**

- **类型**：异常检测（`Anomaly Detection`）

- **原理**：基于“异常点更容易被孤立”的思想。通过随机选择特征和分割点，反复划分数据，异常点通常会在更少的步骤中被隔离出来。

  - 核心思想：**异常点容易被快速隔离，正常点难分。**
  - 大白话：想象你在操场上找“怪人”。大家都穿着校服站成一堆，只有一个人穿泳装站在角落。你随便划几条线，就能把他单独圈出来。而正常人扎堆在一起，要划很多次才能分开。所以，**谁更容易被“孤立”出来，谁就是异常**。

- **优点**：速度快、适合高维数据、对噪声鲁棒、不需要标注异常样本。

- **应用场景**：

  - 信用卡欺诈检测
  - 工业设备故障预警
  - 网络入侵检测

- **举例**：找出“不合群”的交易记录

  - ```
    例子：信用卡欺诈检测
    
    银行监控每笔交易的两个特征：
    - 交易金额
    - 交易地点与持卡人常用地的距离
    
    正常交易集中在“小额+本地”区域，形成高密度簇。
    某笔交易：“5万元 + 刚果（金）”，远离所有正常点。
    
    孤立森林算法快速将其标记为“异常”：
    - 因为它只需几次划分就能被孤立
    - 而正常交易需要更多次才能分离
    
    系统立即冻结卡片并短信验证，成功拦截盗刷。
    ```



## 5、半监督学习

| 算法名称         | 一句话             | 适合啥数据？                                 | 特点                                 |
| ---------------- | ------------------ | -------------------------------------------- | ------------------------------------ |
| **标签传播**     | 靠关系传标签       | 数据之间有“连接”或“相似度”（如社交网络、图） | 依赖结构，不适用于孤立数据           |
| **生成模型**     | 猜数据怎么生成的   | 图像、文本等能建模分布的数据                 | 能给出“属于某类的概率”，但假设强     |
| **半监督`SVM`**  | 画一条聪明的分界线 | 特征清晰、两类分明的问题（如医疗影像）       | 边界硬、怕噪声，小样本效果好         |
| **伪标签**       | 靠自己给自己打标   | 任何任务（图像、语音、文本都行）             | 简单粗暴、容易上手，但可能“越错越偏” |
| **一致性正则化** | 变形不变答案       | 图像、语音等可做数据增强的任务               | 深度学习专用，效果强，训练稍复杂     |
| **对比学习**     | 拉近自己、推开别人 | 图像、多模态（图文）                         | 自监督也能用，适合预训练             |



### 1）**标签传播（`Label Propagation, LP`）**

- **类型**：基于图的方法（`Graph-based`）

- **原理**：假设数据点之间存在关系（如社交网络中的好友），如果两个点很相似或相连，那么它们的标签也应该是相近的。通过构建一个“图”，让已标注节点的标签像“病毒”一样传播给未标注邻居。

  - **大白话解释**：就像你在朋友圈里看到一个人说“这电影真好看”，他和你的好友是同学，那你也会觉得这部电影不错。标签传播就是让“我知道答案的人”去影响“不知道的人”。

- **优点**：直观、适合关系型数据（如社交网络）、能利用样本间的拓扑结构。

- **应用场景**：

  - 社交网络用户分类（谁是骗子？谁是营销号？）
  - 推荐系统中预测用户兴趣
  - 知识图谱补全

- **举例**：在微博上识别“营销号”

  - ```
    例子：某平台想自动识别“营销号”
    
    已知部分账号是“营销号”（人工标注），其他未知。
    构建图：每个账号是一个节点，关注/被关注是边。
    使用 Label Propagation：
      - “已知营销号”会把标签传给它关注的账号
      - 如果多个“营销号”都关注某个账号 → 它很可能也是营销号
      - 最终所有账号都被打上“营销概率”
    
    结果：成功识别出大量隐藏的营销号，无需全部人工标注。
    ```



### 2）**生成模型（`GMM + EM`, `VAE`）**

- **类型**：生成模型（`Generative Models`）

- **原理**：假设数据是由某些潜在分布生成的（比如多个高斯分布混合）。使用 EM 算法估计这些分布参数，并对未标注数据进行概率分配。变分自编码器（`VAE`）则用神经网络学习数据的潜在空间分布。

  - **大白话解释**：就像你有一堆水果，有些是苹果、有些是香蕉，但没贴标签。你可以先猜：“苹果可能是红色+圆形，香蕉是黄色+弯的”。然后不断调整猜测，直到所有水果都能被合理归类。

- **优点**：概率解释性强、能处理不确定性、适合文本和图像聚类。

- **应用场景**：

  - 文本聚类（如新闻自动分类）
  - 图像聚类（如无标签图片分组）
  - 异常检测（偏离分布的数据即异常）

- **举例**：对未标注新闻做主题聚类

  - ```
    例子：媒体公司有10万篇新闻，只有500篇打了标签（如“科技”、“体育”）
    
    使用 GMM + EM：
      - 假设新闻来自3个主题分布
      - 用已标注数据初始化模型
      - 对未标注新闻计算属于每个主题的概率
      - 得到每篇文章的“主题软标签”
    
    结果：系统自动将99500篇文章分为“科技”、“体育”、“娱乐”三类，
    准确率接近全监督模型。
    ```



### 3）**半监督支持向量机（`S3VM`）**

- **类型**：低密度分离（`Low-Density Separation`）

- **原理**：在传统 `SVM` 的基础上引入未标注数据，要求决策边界尽可能穿过数据稀疏区域（即“低密度区”），从而避免将噪声或异常点误判为一类。

  - **大白话解释**：就像你要画一条线把狗和猫分开。如果有大量没标标签的动物，你会尽量让这条线穿过“没人”的地方，而不是穿过一堆混在一起的动物。

- **优点**：边界清晰、抗噪声能力强、适合小样本+大量未标注数据。

- **应用场景**：

  - 医疗诊断（如肿瘤识别，医生只标注少数病例）
  - 异常检测（如设备故障预警）
  - 生物医学图像分析

- **举例**：医疗影像中识别肺癌结节

  - ```
    例子：医院有1万张肺部CT图像，其中只有200张由专家标注了“是否含结节”
    
    使用 S3VM：
      - 用200张标注数据训练初始模型
      - 加入9800张未标注图像，优化决策边界
      - 要求边界穿过“正常组织密集区”，避开模糊区域
    
    结果：模型在新数据上的准确率比纯监督提升15%，
    并能有效过滤掉边缘模糊的假阳性。
    ```



### 4）**一致性正则化（`Mean Teacher`, `FixMatch`）**

- **类型**：一致性正则化（`Consistency Regularization`）

- **原理**：对同一张输入图像（或文本）做轻微扰动（如加噪、旋转），然后要求模型在不同版本上给出一致的预测。通过这种方式“强迫”模型学会鲁棒的特征表示。

  - **大白话解释**：就像你教孩子认猫：给他看一张猫的照片，再把照片翻转、模糊、放大，问他是不是猫。如果每次都说“是”，说明他真的学会了“猫”的本质，而不是记住了某张图。

- **优点**：适合深度学习、鲁棒性强、可大幅提升模型泛化能力。

- **应用场景**：

  - 图像分类（如医学图像、自动驾驶）
  - 语音识别（抗背景噪音）
  - `NLP`（如文本分类、情感分析）

- **举例**：提升人脸识别精度

  - 

    ```
    例子：人脸识别系统需要在光照变化下仍能识别
    
    使用 Mean Teacher：
      - 输入一张人脸，做随机裁剪、亮度调整等增强
      - 让学生模型和教师模型分别预测
      - 要求两者输出一致（即使输入略有不同）
    
    结果：在光线昏暗、角度倾斜的情况下，识别准确率从85%提升到93%，
    且对遮挡（如戴口罩）更鲁棒。
    ```



### 5）**伪标签（`Self-Training`, `Noisy Student`）**

- **类型**：伪标签（`Pseudo-labeling`）

- **原理**：先用少量标注数据训练一个初步模型，然后用这个模型去预测未标注数据，把置信度高的预测结果当作“伪标签”，再把这些伪标签数据加入训练集重新训练模型。

  - **大白话解释**：就像老师先教学生基础知识，让学生自己写作业；老师批改后发现“这道题答得准”，就把它当成标准答案继续教别人。

- **优点**：简单易实现、效果显著、适合大规模数据。

- **应用场景**：

  - 语音识别（如 ASR）
  - 自然语言处理（如情感分析、命名实体识别）
  - 图像分类（如工业质检）

- **举例**：提升语音识别准确率

  - 

    ```
    例子：语音助手公司有10万小时语音，但只有1千小时标注过
    
    使用 Self-Training：
      - 第一轮：用1千小时训练模型A
      - 第二轮：用A预测剩余9.9万小时，选置信度>0.9的作为伪标签
      - 第三轮：合并原始标注 + 伪标签，训练模型B
      - 重复多轮，最终模型性能逼近全监督水平
    
    结果：在测试集上准确率提升8%，且成本降低90%。
    ```

------

### 6）**对比学习（`SimCLR`）**

- **类型**：对比学习（`Contrastive Learning`）

- **原理**：通过构造“正样本对”（同一数据的不同增强版本）和“负样本对”（不同数据），训练模型让正样本在嵌入空间中靠近，负样本远离。从而学习到有意义的特征表示。

  - **大白话解释**：就像你教AI认猫：给它看一张猫的照片，再看同一张猫的模糊版、旋转版，告诉它“这是同一个东西”；再给它看一张狗的照片，说“这不是猫”。`AI` 就会学会“猫”的核心特征。

- **优点**：无需负样本、高效表征学习、适合多模态数据。

- **应用场景**：

  - 多模态数据融合（图像+文本）
  - 自监督预训练（如 CLIP、DALL·E）
  - 视频理解、跨模态检索

- **举例**：图文匹配系统

  - 

    ```
    例子：电商平台想让用户用文字搜索图片
    
    使用 SimCLR：
      - 对每张商品图做多种增强（裁剪、颜色抖动、旋转）
      - 把原图和增强版当作“正样本对”
      - 其他图片当作“负样本”
      - 训练模型让相同商品的图像在特征空间中靠拢
    
    结果：用户输入“红色连衣裙”，系统能精准匹配出对应图片，
    即使图片没有标注，也能靠视觉特征关联。
    ```



## 6、 神经网络与深度学习

> **感知机 → 浅层神经网络 → 深度神经网络（深度学习）**

- **深度学习 是 神经网络 的一种**
- **神经网络 是 机器学习 的一种方法**
- **机器学习 是 实现人工智能 的主流方式之一**

```
人工智能（AI）
│
└── 机器学习（ML）
    │
    ├── 传统算法
    │   ├── 线性回归
    │   ├── 决策树
    │   ├── SVM
    │   └── K-Means
    │
    └── 神经网络（NN）
        │
        ├── 浅层神经网络（1~2个隐藏层）
        │
        └── 深度学习（Deep Learning）
            ├── CNN（图像）
            ├── RNN / LSTM（文本、语音）
            └── Transformer（大模型、ChatGPT）
```

| 概念               | 核心定义                                                 |
| ------------------ | -------------------------------------------------------- |
| **人工智能（AI）** | 让机器模拟人类智能行为（如看、听、说、决策）             |
| **机器学习（ML）** | `A`· 的一种实现方式：让机器从数据中自动学习规律          |
| **神经网络（NN）** | `ML` 中的一种模型，模仿人脑神经元连接                    |
| **深度学习（DL）** | 使用**深层神经网络**的机器学习方法，擅长处理高维复杂数据 |



### 1）感知机

> **感知机是“单个神经元”的模型，而神经网络是“多个神经元连成的网”**。感知机只能做简单判断，神经网络能解决复杂问题。

#### **a、什么是感知机？**

- 是人工神经网络的**最早雏形**，由 Frank Rosenblatt 在 1957 年提出。
- 它是一个**单层、单个神经元**的模型，用来做**二分类任务**（比如：是/否、垃圾邮件/正常邮件）。



#### **b、工作原理（大白话）**

就像你决定要不要买一件衣服：把这些因素加权后总分 > 60 → 买（输出1）总分 ≤ 60 → 不买（输出0）

- 看价格（x₁）→ 便宜就加分
- 看品牌（x₂）→ 大牌就加分
- 看颜色（x₃）→ 喜欢就加分



#### **c、局限性**

- 只能处理**线性可分**的问题（比如：用一条直线就能分开两类数据）
- 不能解决异或（`XOR`）这种非线性问题
- 没有隐藏层，无法学习复杂模式



#### **d、举个例子：判断“是否为猫”**

感知机（不行）因为它只看线性组合，无法捕捉“整体像猫”的复杂模式。

- 输入：耳朵形状、尾巴长度、毛色
- 输出：是猫 / 不是猫
- 问题：如果猫的耳朵短、尾巴长，但其他特征像猫 → 感知机可能误判



### 2）神经网络

#### **a、什么是神经网络？**

**神经网络**：是一种模仿生物神经系统工作原理的计算模型，用于估计或近似函数。它由大量的节点（或称“神经元”）组成，这些节点分布在多个层次上，包括输入层、隐藏层和输出层。每个节点通过连接权重与其他节点相连，这些权重在训练过程中被调整，以使网络能够学习数据中的模式。

```
输入层：3个特征（如糖、盐、醋）
        ↓
隐藏层1：64个神经元 ← 这是一层，由64个“小处理器”组成
        ↓
隐藏层2：32个神经元 ← 这是第二层，由32个神经元组成
        ↓
输出层：1个神经元（预测“好喝吗？”）
```

- 是**多个感知机连接在一起**形成的多层结构。
- 能够学习复杂的非线性关系，处理图像、语音、文本等高维数据。
- 包含输入层、一个或多个隐藏层、输出层。
  - **输入层**：接收外部数据。
  - **隐藏层**：位于输入层和输出层之间，负责处理信息，学习更复杂的函数。
    - **隐藏层是由多个神经元组成的“一层处理单元”；**
    - **神经元是隐藏层的“基本零件”，多个神经元排成一行 → 就是一层隐藏层。。**
  - **输出层**：产生最终结果。



#### **b、工作原理（大白话）**

就像你判断一个人是不是“好人”：每一层都在提取不同层次的特征，最终做出更准确的判断

- 第一层：看外貌、穿着 → 判断“看起来靠谱吗？”
- 第二层：听他说的话、行为 → 判断“言行一致吗？”
- 第三层：综合所有信息 → 判断“他是好人还是坏人？”



#### **c、举个例子：判断“是否为猫”**

神经网络（可以）

- 第一层：识别局部特征 → “三角耳”、“条纹毛”、“圆眼睛”
- 第二层：组合特征 → “有三角耳+条纹毛=可能是猫”
- 第三层：综合判断 → “这是一只猫”



#### d、感知机 和 神经网络

| 对比项           | 感知机（Perceptron）       | 神经网络（Neural Network）                 |
| ---------------- | -------------------------- | ------------------------------------------ |
| **结构**         | 单个神经元                 | 多层神经元（输入层 + 隐藏层 + 输出层）     |
| **层数**         | 1 层（无隐藏层）           | ≥2 层（至少有一个隐藏层）                  |
| **能力**         | 只能做线性分类             | 能做非线性分类、回归、聚类等               |
| **激活函数**     | 通常用阶跃函数（0/1）      | 用 Sigmoid、ReLU、Tanh 等平滑函数          |
| **训练方法**     | 梯度下降法（简单更新权重） | 反向传播 + 梯度下降（自动调参）            |
| **应用范围**     | 简单二分类                 | 图像识别、语音识别、自然语言处理等复杂任务 |
| **能否解决 XOR** | 不能                       | 能                                         |



#### e、神经网络中的基础概念

| 术语       | 含义                           | 类比           | 例子                     |
| ---------- | ------------------------------ | -------------- | ------------------------ |
| **输入层** | 接收原始数据                   | 原材料入口     | 784个像素点              |
| **隐藏层** | 处理和学习信息                 | 加工车间       | 3层 × 128神经元          |
| **输出层** | 生成最终结果                   | 成品出口       | 1个（回归）或2个（分类） |
| **全连接** | 上层每个神经元连下层所有神经元 | 全部互通       | Dense layer              |
| **深度**   | 隐藏层数量                     | 工序层数       | 深度=4 → 4个加工环节     |
| **宽度**   | 每层神经元数量                 | 每道工序的人数 | 宽度=256 → 256个“小工”   |



### 3）深度学习

**深度学习**是机器学习的一个子集，专门指使用深层神经网络进行学习的方法。这里的“深度”指的是网络中含有多层隐藏层，从而可以学习到数据更加复杂的表示。深度学习模型能够在大量数据上自动提取特征，而不需要手工设计特征提取步骤，这使得它们特别适用于图像识别、语音识别、自然语言处理等领域。   

深度学习的成功得益于大数据集的可用性、计算能力的提升以及算法的进步。尽管如此，深度学习也面临挑战，比如对数据量的需求较高、解释性差等问题。



#### **a、深度学习是什么？**

- 是**具有多个隐藏层**（通常 ≥3 层，实际中常达几十甚至上百层）的神经网络。
- “深度” = **层数深**，不是“学得深”。
- 能自动从原始数据中逐层提取**从简单到复杂的特征**。



#### **b、举个例子（图像识别）：**

- 输入：一张猫的照片（像素）
- 第1层：识别边缘、线条
- 第2层：组合成眼睛、耳朵等局部特征
- 第3层：识别“猫脸”
- 第4~10层：判断品种、姿态、背景等
- 输出：这是“一只橘猫，在沙发上”



#### **c、神经网络和深度学习**

- **神经网络 = 家族总称**（包括浅层和深层）
- **深度学习 = 这个家族里“层数特别多”的那一支精英**

```
神经网络（浅层）：
输入 → [隐藏层] → 输出  
（1层隐藏层，像三明治）

深度学习（深层）：
输入 → [隐藏层1] → [隐藏层2] → [隐藏层3] → ... → [隐藏层N] → 输出  
（像千层蛋糕，每一层提炼更高级的信息）
```



| 对比项       | 神经网络（广义）                    | 深度学习                                 |
| ------------ | ----------------------------------- | ---------------------------------------- |
| **定义**     | 由神经元组成的计算模型              | **多层**（深层）神经网络                 |
| **隐藏层数** | 可以是 0 层（感知机）、1 层、2 层…… | **通常 ≥3 层**，常见 10~1000+ 层         |
| **特征提取** | 需要人工设计部分特征                | **自动逐层提取特征**（端到端学习）       |
| **数据需求** | 中小数据集也能用                    | **依赖大量数据**（否则容易过拟合）       |
| **计算资源** | `CPU` 就能跑                        | 通常需要 GPU/TPU 加速                    |
| **典型模型** | MLP（多层感知机）                   | CNN、RNN、Transformer、ResNet 等         |
| **应用场景** | 简单分类、回归                      | 图像识别、语音识别、大语言模型、自动驾驶 |



## 7、神经元与激活函数

> **神经元是一个计算单元的整体概念，而“激活函数”只是这个单元里的一个组成部分**。
>
> **神经元是一个完整的计算单元，激活函数是它“做决策”的那一步。**

| 概念          | 作用                         | 类比                             |
| ------------- | ---------------------------- | -------------------------------- |
| **神经元**    | 接收输入、加权求和、输出信号 | 工厂里的一个工人                 |
| **权重（w）** | 决定每个输入的重要性         | 工人对不同原料的重视程度         |
| **偏置（b）** | 调整激活门槛                 | 工人的“最低工作意愿”             |
| **激活函数**  | 引入非线性，决定是否“激活”   | 工人的“心情开关”——今天干不干活？ |



### 1）神经元：神经网络的“基本计算单元”

> 神经元是神经网络中最基本的处理单元，**模仿人脑神经细胞的工作方式**。 它接收输入，做加权求和，再通过一个“开关”决定是否输出信号。

- 数学表达 `输出 = 激活函数(w₁·x₁ + w₂·x₂ + ... + wₙ·xₙ + b )`

  - `x₁, x₂, ..., xₙ`：输入（比如像素值、年龄、收入）

  - `w₁, w₂, ..., wₙ`：权重（表示每个输入的重要性）

  - `b`：偏置（`bias`，相当于“门槛”）

  - **激活函数**：决定“这个结果要不要传下去”

生活化例子：你决定要不要约会

| 输入（x）            | 权重（w） | 说明                         |
| -------------------- | --------- | ---------------------------- |
| 对方颜值（8分）      | × 0.5     | 颜值重要，但不是全部         |
| 对方收入（1万）      | × 0.3     | 有点在意                     |
| 是否有幽默感（是=1） | × 0.7     | 特别看重！                   |
| 偏置 b = -2          | ——        | “我比较挑剔，总分得够高才行” |

```
z = 0.5×8 + 0.3×10 + 0.7×1 - 2 = 4 + 3 + 0.7 - 2 = **5.7**
```

然后交给**激活函数**判断：“5.7 够不够让我心动？”



### 2）激活函数：神经元的“决策开关”

#### a、为什么需要激活函数？

**重要性：**：没有激活函数，神经网络就是一堆线性公式，连“异或”都搞不定！ 有了激活函数，它才能学会“猫不是狗”、“垃圾邮件很可疑”这种复杂判断。

激活函数的作用：引入非线性！让神经网络能拟合任意复杂函数。



#### b、常见激活函数（大白话解释）

| 激活函数             | 公式 / 行为         | 特点                  | 大白话比喻                             |
| -------------------- | ------------------- | --------------------- | -------------------------------------- |
| **阶跃函数（Step）** | z > 0 → 1；否则 0   | 简单但不可导          | “过了60分就及格，否则挂科”             |
| **Sigmoid**          | 输出 0~1 的平滑曲线 | 可导、适合概率输出    | “分数越高，越可能答应，但不会100%确定” |
| **Tanh**             | 输出 -1~1，中心在0  | 比 Sigmoid 更好归一化 | “态度可正可负，中间是犹豫”             |
| **`ReLU`（最常用）** | z > 0 → z；否则 0   | 计算快、缓解梯度消失  | “没达到底线就不干，达到了就全力干！”   |
| **Leaky ReLU**       | 负数部分给个小斜率  | 防止“神经元死亡”      | “即使没达标，也保留一点积极性”         |



#### c、图形对比（想象一下）：

```
阶跃函数： ───────┐
                │
                └─────── （硬开关）

Sigmoid：   ＿＿＿
          ／     ＼      （软开关，平滑过渡）

ReLU：     │
           │
           └───────    （“死了就躺平，活了就冲”）
```

------



#### d、为什么 ReLU 成为主流？

1. **计算简单**：就是 `max(0, z)`，没有指数运算。
2. **缓解梯度消失**：正区间梯度恒为1，反向传播时信号不容易衰减。
3. **稀疏激活**：约50%神经元输出为0，模型更高效。

 缺点：负数部分梯度为0 → 有些神经元可能“永远不激活”（称为“神经元死亡”），所以有时用 **Leaky ReLU** 或 **ELU** 改进。



#### e、举个完整小例子

假设一个神经元用于判断“是否推荐电影”：

- 输入：
  - 用户评分历史平均分：7.5（x₁）
  - 电影类型匹配度：0.9（x₂）
- 权重：w₁=0.6, w₂=0.8
- 偏置：b = -3

- 计算：`z = 0.6×7.5 + 0.8×0.9 - 3 = 4.5 + 0.72 - 3 = 2.22`

- 用 `ReLU` 激活：
  - `output = ReLU(2.22) = 2.22 → 推荐！`
  - 如果 z = -0.5 → output = 0 → 不推荐。



## 8、前向与反向传播机制

> **反向传播是深度学习的“发动机”** —— 它让百万级参数能自动优化，而不是靠人手动调。

1. **前向传播 = 推理过程**，用于预测（试做一道题）
2. **反向传播 = 学习过程**，用于训练（老师批改+订正）
3. **没有反向传播，神经网络就无法自动调整参数**
4. **两者必须配合使用**：先前向得结果，再反向改错误



### 1）基本比较

| 项目             | 前向传播                 | 反向传播                           |
| ---------------- | ------------------------ | ---------------------------------- |
| **方向**         | 输入 → 输出（从前到后）  | 输出 → 输入（从后到前）            |
| **目的**         | 得到预测结果             | 计算梯度，用于更新参数             |
| **是否需要标签** | 不需要（推理阶段也能用） | **需要真实标签 y**（训练阶段专用） |
| **计算内容**     | 矩阵乘法 + 激活函数      | 求导（链式法则） + 梯度计算        |
| **类比**         | 学生写作业               | 老师批改 + 圈出错题                |
| **频率**         | 每次预测都用             | **只在训练时用**                   |



### 2）前向传播—— 试做一道题

- 目的：把输入数据送进神经网络，**从前往后逐层计算，最终输出预测值**。

- 流程：
  - **向前（前向传播）—— 试做一碗汤**
    - 输入原料：糖、盐、醋
    - 初级工 → 中级师 → 主厨，一层层加工
    - 最后主厨说：“这汤有 66% 可能好喝”（预测值 ŷ）



### 3）反向传播—— 老师批改+订正

- 目的：**计算每个权重对错误的“贡献度”（梯度）**，然后用梯度下降更新权重，让下次预测更准。

- 流程：改参数，让下次预测更准
  - 顾客尝了说：“太咸了！难喝！”（真实标签 y = 0）
  - 主厨立刻喊：
    - “中级师，你是不是太信那个爱放盐的工人了？”
    - “初级工，下次少给盐打高分！”
  - 于是大家**调整自己的偏好（权重 W）**，比如：
    - 盐的权重从 +0.5 改成 -0.3
    - 糖的权重提高



## 9、深度学习框架生态与实践

### 1）什么是深度学习框架？

> **深度学习框架 = 一套用于快速构建、训练和部署神经网络的软件工具包**        
>
> 它让你不用手动实现梯度计算、内存管理、`GPU` 加速等底层细节，**专注于模型设计**。    

问题：先问一个问题：没有框架，能做深度学习吗？

**能，但太痛苦了！**

想象你要盖一栋楼：

- 没有框架 = 你得自己烧砖、炼钢、拉电线、装水管……
- 有框架 = 你直接买预制墙板、电梯、空调，拼起来就行

**深度学习也一样**：

- 没有框架：你要手写矩阵乘法、手动算梯度、自己调 GPU……
- 有框架：一行代码定义神经网络，自动帮你训练！

类比：建房子 vs 自己造砖



### 2）主流框架有哪些？怎么选？

- **如果你刚开始学 → 选 `PyTorch`**（简单直观，社区教程多）
- **如果你要做 `App` 或上线服务 → 了解 `TensorFlow`**
- **别纠结！学会一个，其他很快就能上手**

| 框架             | 谁家的              | 特点                           | 适合谁                 |
| ---------------- | ------------------- | ------------------------------ | ---------------------- |
| **`PyTorch`**    | Meta（原 Facebook） | 像写 Python 一样自然，调试方便 | **初学者、研究员首选** |
| **`TensorFlow`** | Google              | 部署强、生态大，适合上线       | 企业工程师             |
| **`JAX`**        | Google              | 极致性能，函数式编程           | 科研前沿玩家           |



### 3）深度学习时代

> **深度学习时代 = 计算机靠“看大量例子”自动学会复杂任务的时代**
>
> - **以前（规则时代）**：“如果邮件里有‘免费’‘中奖’，就是垃圾邮件” → 骗子换个词就失效。
> - **现在（深度学习时代）**：给 AI 看 100 万封邮件，它自己总结出：“‘限时领取+银行账户’组合出现 99% 是诈骗”。

- **起始年份**：2012 年：AlexNet 在 ImageNet 比赛中横扫全场 → 标志着深度学习正式崛起
- **结束年份**：GPT-3（2020）、Transformer 成为主流 → 进入“大模型时代”
- **未来：**从“深度学习”走向“通用人工智能”

👉 这个阶段是**从“小模型探索”到“大模型爆发”的过渡期**。

| 年份          | 里程碑                  | 能力突破                           |
| ------------- | ----------------------- | ---------------------------------- |
| **2012**      | AlexNet                 | 准确识别图像中的物体               |
| **2015**      | ResNet                  | 解决“越深越难训”问题，模型可超百层 |
| **2016**      | AlphaGo                 | 在复杂策略游戏击败人类冠军         |
| **2017**      | `Transformer`           | 让机器真正理解语言上下文           |
| **2018**      | BERT                    | 阅读理解能力接近人类               |
| **2020**      | **GPT-3**               | **能写文章、编代码、回答问题，**   |
| **2022–2024** | ChatGPT / Qwen / Gemini | 多轮对话、逻辑推理、多模态（图文音 |



# 二、大模型法阵前景与关键技术

## 1、`Transformer` 架构的诞生与应用

> **`Transformer`** 是一种**深度学习模型架构**，它让 `AI` 不再靠顺序一步步读句子，而是像人一样“一眼看全篇”。于 **2017 年**由 Google 团队在论文《Attention Is All You Need》中首次提出。它彻底改变了自然语言处理（`NLP`）领域，并成为当今大语言模型（如 `GPT`、BERT、Qwen、LLaMA 等）的**核心基础架构**。

核心特点：

- **完全基于注意力机制（Attention）**，不再依赖 `RNN` 或 `CNN`。
- 能有效捕捉**长距离依赖关系**（比如一句话开头和结尾的词之间的联系）。

- 支持**高度并行计算**，训练速度远超传统序列模型。



### 1）注意力模型（`Attention Model`）：捕捉长距离依赖

>  注意力解决了 **“长距离依赖”问题** —— 即使两个词相隔很远，也能建立联系。

- **传统 `RNN/LSTM`**：必须按顺序读完前面所有词才能知道“它”指谁 → 慢，且容易“忘事”
- **注意力机制**：**直接计算每个词和其他词的相关性 → 一步到位**！

 **类比**：

- `RNN` = 一个慢吞吞的老师，逐字讲解课文
- `Attention` = 一个聪明的学生，一眼看出“猫”和“它”的关系

**举个例子：输入：我 喜欢 吃 苹果。**

- “吃” 和 “苹果” 很相关 → 给高权重
- “我” 和 “喜欢” 也很相关 → 给高权重
- “我” 和 “苹果” 关系弱 → 权重低

**→ 模型就知道：“吃”后面应该是“食物”，不是“书”。**



### 2）自注意力机制（`Self-Attention`）：语义理解的钥匙

>  **自注意力 = 让模型真正“理解语义”**，而不仅仅是记忆模式。

 什么是自注意力？所有词都参与“互相打分”，决定彼此的重要性。     

工作流程（简化版）：

- 对每个词，计算它与其他所有词的“相关度”（`Attention Score`）

- 用这些分数加权求和，得到该词的“新表示”

举个例子：句子：“我喜欢你。------> ” 三个词：我、喜欢、你

| 词   | 对“我”的影响 | 对“喜欢”的影响 | 对“你”的影响 |
| ---- | ------------ | -------------- | ------------ |
| 我   | 1.0（自己）  | 0.8            | 0.5          |
| 喜欢 | 0.7          | 1.0            | 0.9          |
| 你   | 0.4          | 0.6            | 1.0          |

**类比总结：**自注意力像什么？

| 比喻           | 说明                                         |
| -------------- | -------------------------------------------- |
| **班级讨论会** | 每个同学（词）发言时，都会参考其他同学的观点 |
| **社交网络**   | 每个人（词）都有自己的“好友圈”（高权重词）   |
| **侦探破案**   | 每个线索（词）都要和其他线索交叉验证         |



### 3）多头注意力（`Multi-Head Attention`）：并行计算不同子空间的特征

>  **多头注意力 = 并行思考，提升表达能力**

**为什么需要“多头”？**因为一个词可能在**多个角度**上有意义。比如“银行”：

- 金融意义上的“银行”
- 河边的“河岸”（`bank`）

**多头注意力做了什么？**

- 把输入分成多个“子空间”（`head`），每个 `head` 学不同的关系
- 比如：
  - Head 1：学习语法结构
  - Head 2：学习实体关系
  - Head 3：学习情感倾向

**类比**： 一个团队有 8 个成员，每人负责一个方向分析问题 → 整体判断更全面。

举个例子：句子：“他去了北京。”

- 一个 `head` 可能关注“他”和“北京”之间的地理关系
- 另一个 `head` 关注“去”这个动作的时间顺序
- 第三个 `head` 关注“北京”是否是城市名

→ 多头一起工作，模型理解更丰富。



### 4）位置编码（`Positional Encoding`）：引入序列位置信息

> **`Transformer` 本身是“无序”的，位置编码就是给每个词贴上“我在第几位”的标签，让模型知道顺序！**

| 问题                     | 回答                                                         |
| ------------------------ | ------------------------------------------------------------ |
| **为什么需要位置编码？** | 因为 Transformer 本身不知道词的顺序，会把“猫追老鼠”和“老鼠追猫”当成一回事！ |
| **位置编码是什么？**     | 一串专门为“第几个位置”设计的数字，像座位号                   |
| **怎么加进去？**         | 把“词的意思数字”和“位置数字”直接相加，变成一个新数字         |
| **为什么用正弦函数？**   | 因为这样生成的数字既能区分每个位置，又能让 AI 自动学会“相邻词关系更近” |

**解决方案：位置编码**

- 给每个词加上一个“位置标签”（如第1位、第2位……）
- 这些标签是数学生成的（正弦/余弦函数），能让模型感知顺序

**具体怎么做？假设奶茶店有个智能系统，只认“数字配方卡”。**

- **第一步：把词翻译成“味道代码”（词向量）**

  - “我” → `[0.2, -0.1, 0.5]` （代表“人称”）

  - “不” → `[-0.8, 0.9, -0.3]` （代表“否定”）

  - “吃” → `[0.6, 0.4, -0.2]` （代表“动作”）

  - “香菜” → `[0.1, -0.7, 0.8]` （代表“食材”）

- **第二步：给每个位置生成“顺序密码”（位置编码）**

  - 第1位（“我”） → `[0.0, 1.0, 0.0]`

  - 第2位（“不”） → `[0.5, 0.9, 0.1]`

  - 第3位（“吃”） → `[0.8, 0.6, 0.3]`

  - 第4位（“香菜”）→ `[1.0, 0.1, 0.5]`

- **第三步：把“味道”和“时间”混在一起（相加）**最终输入给 `AI` 的是：

  - 第1个词：`[0.2, -0.1, 0.5] + [0.0, 1.0, 0.0] = [0.2, 0.9, 0.5]`

  - 第2个词：`[-0.8, 0.9, -0.3] + [0.5, 0.9, 0.1] = [-0.3, 1.8, -0.2]`

  - ……现在，`AI` 看到第2个输入是 `[-0.3, 1.8, -0.2]`，它能反推：





## 2、大模型技术突破与前沿趋势

> **大模型 = 参数超多、训练数据超大、能力超强的 `AI` 模型**，它是当前 AI 的“天花板”。   

**Transformer 是起点，大模型是终点，而我们正在路上。**

- **`Transformer `改变了 `NLP` 的游戏规则**
- **大模型让我们看到了“通用人工智能”的曙光**
- **技术仍在飞速发展**：MoE、稀疏注意力、多模态、Agent……

### 1）大模趋势

#### a、阶段趋势

| 阶段                | 核心技术与代表模型                                       | 能力突破                             |
| ------------------- | -------------------------------------------------------- | ------------------------------------ |
| 1. 传统模型         | `CNN` / `RNN `/ `LSTM`                                   | 处理局部特征或短序列任务             |
| 2. Transformer 架构 | Self-Attention / Positional Encoding                     | 全局建模长距离依赖，并行高效训练     |
| 3. 大模型时代       | GPT / BERT / Llama / Qwen + MoE / Sparse Attention       | 涌现通用智能、零样本推理、多任务泛化 |
| 4. 实用化与轻量化   | 量化（Quantization）/ 知识蒸馏（Distillation）/ 模型剪枝 | 高效部署至端侧设备（手机、IoT）      |

```
传统方法（规则系统 + 词典）
       ↓
RNN / LSTM（能记顺序，但慢、难训、易忘）
       ↓
CNN（并行快，擅抓局部模式，但忽略全局结构）
       ↓
Transformer（自注意力实现全局理解，支持并行训练）
       ↓
大语言模型（GPT、Qwen、Llama…）——具备涌现能力与通用智能
       ↓
轻量化技术（量化、蒸馏、MoE）→ 落地手机、汽车、边缘设备
```



#### b、专业名词

| 名称              | 全称                           | 中文           | 特点             | 记忆关键词         | 当前地位       |
| ----------------- | ------------------------------ | -------------- | ---------------- | ------------------ | -------------- |
| **`NLP`**         | `Natural Language Processing`  | 自然语言处理   | 让 AI 理解语言   | **任务**           | 持续发展       |
| **`RNN`**         | `Recurrent Neural Network`     | 循环神经网络   | 顺序听，但健忘   | **慢慢听，听完忘** | 基本被取代     |
| **`LSTM`**        | **`Long Short-Term Memory`**   | 长短期记忆网络 | 会筛选记忆       | **带 memo 的 RNN** |                |
| **`CNN`**         | `Convolutional Neural Network` | 卷积神经网络   | 扫局部，速度快   | **滑窗抓重点**     | 轻量场景仍有用 |
| **`Transformer`** | —                              | 变换器         | 全局看，又快又准 | **注意力超能力**   | LLM 的基础     |

- 在 `2017` 年 ·`Transformer`出现后，**`LSTM`在大模型中基本被取代**
- 但在**资源有限的小设备**（如嵌入式系统）或**简单任务**中，`LSTM` 因结构简单仍有价值

| 模型              | 记忆力             | 处理上下文的方式                 | 速度         | 是否主流                   |
| ----------------- | ------------------ | -------------------------------- | ------------ | -------------------------- |
| **`RNN`**         | 弱（短记忆）       | 逐词顺序处理，依赖前序信息       | 慢（串行）   | 已淘汰                     |
| **`LSTM`**        | 强（可记长信息）   | 逐词顺序处理，依赖前序信息       | 慢（仍串行） | 被取代，但仍有轻量场景使用 |
| **`Transformer`** | 极强（全局注意力） | 通过自注意力并行分析全句词的关系 | 快（并行）   | 当前主流（GPT/Qwen 基础    |



### 2）大模型的定义与特点

> **参数量 ≥ 数亿，通常在数十亿到万亿级别**

| 特征                  | 说明                                           |
| --------------------- | ---------------------------------------------- |
| **通用性强**          | 能做问答、写作、编程、翻译等任务               |
| **零样本/少样本学习** | 不用额外训练，直接提示就能完成任务             |
| **涌现能力**          | 参数大到一定程度后，突然出现推理、规划等新能力 |



#### a、为什么会出现“涌现”？原因到底是什么？

这是目前 AI 领域最大的谜团之一。但科学家们有几种主流猜测：

**1）规模跨越“临界点”**

类比：一群蚂蚁各自乱爬，但当数量够多时，它们能自动形成“蚁路”——**集体智慧自发涌现**。

- 小模型像小学生，只能记公式
- 当模型大到一定程度（比如 100 亿参数以上），内部结构变得极其复杂
- 正如水加热到 100°C 会变成蒸汽，**模型达到某个“相变点”后，智能突然“冒出来”**



**2）记忆与推理的融合**

> 就像你读了很多书，虽然没学过写作课，但突然能写小说了。

- 大模型记住了海量文本中的“模式”
- 比如它见过成千上万次“先列步骤，再得出结论”的推理过程
- 所以当你让它“一步一步想”，它会**自动调用这些记忆片段**，拼成逻辑链条



**3）注意力机制的“自我组织”**

> 类比： 一个工厂里，每个工人只做一件事，但当人数够多时，整个系统能自动完成“生产汽车”的复杂流程。

- `Transformer` 的注意力头可以“组合”起来
- 某些头负责“提取数字”，某些头负责“执行运算”，某些头负责“验证结果”
- 当模型足够大时，这些头能**自动协作**，形成类似“工作流”的结构



#### b、传统模型 vs 大模型

> 传统模型是“专家”，大模型是“通才”。

| 对比项   | 传统模型（如 CNN/RNN） | 大模型（如 GPT/Qwen） |
| -------- | ---------------------- | --------------------- |
| 参数量   | 几百万到几千万         | 数十亿到万亿          |
| 数据需求 | 小数据集即可           | 需要海量数据（TB 级） |
| 训练成本 | 万元级                 | 百万甚至亿元级        |
| 能力     | 专项任务（如分类）     | 通用智能（多任务）    |
| 推理方式 | 固定逻辑               | 动态生成              |





## 3、稀疏注意力（Sparse Attention）：降低计算复杂度

> **稀疏注意力 = 让大模型也能处理长文本**

问题出现：全局自注意力的计算复杂度是 *O*(*n*2)，当序列很长时（如 10000 字），计算爆炸！

解决方案：稀疏注意力

- 不让每个词都看所有词，只看“重要”的几个
- 常见方法：
  - **局部注意力**：只看前后 `10` 个词
  - **全局+局部混合**：对关键词看全局，其他看局部

**类比**： 读书时不用一字一句全记，重点段落细读，其余略过 → 提高效率。

举个例子：文章有 10000 字，但只有 100 个关键词。 模型只关注这 100 个词之间的关系，忽略其他 → 计算量减少 100 倍！





## 4、混合专家模型（MoE, Mixture of Experts）：动态路由机制

> **`MoE` = 用更少的计算，实现更大的模型容量**

什么是 MoE？模型内部有多个“专家”（子网络），每次只激活其中一部分。

工作流程：

1. 输入进来 → 由“门控网络”决定哪些专家该干活
2. 只调用 1~2 个专家 → 其他保持休眠
3. 输出结果

 **类比**： 一个公司有 100 个部门，接到一个任务，系统自动分配给“财务部”和“法务部” → 不浪费资源。

举个例子：

- 用户问：“如何申请贷款？” → 激活“金融专家”
- 用户问：“写一首诗” → 激活“文学专家”
- 用户问：“解释量子力学” → 激活“科学专家”



## 5、模型压缩与加速：量化、知识蒸馏

为什么需要压缩？大模型太大，无法部署在手机、平板等设备上。

主要技术：

- 量化：**把模型里的“高精度数字”换成“低精度数字”，就像把高清图转成压缩 JPG。**

- 知识蒸馏：**用一个大模型（老师）教会一个小模型（学生），让学生学会老师的“思维方式”，而不仅是答案。**

| 方法         | 原理         | 优点             | 缺点                | 适用场景         | 效果                         |
| ------------ | ------------ | ---------------- | ------------------- | ---------------- | ---------------------------- |
| **量化**     | 降低数字精度 | 快、省、几乎无损 | 极端压缩会掉点      | 已有模型快速部署 | 体积缩小 4 倍，速度提升 2 倍 |
| **知识蒸馏** | 老师教学生   | 小模型学得更聪明 | 需要大模型+额外训练 | 定制轻量模型     | 小模型性能接近大模型         |

举个例子：

- **大模型**：GPT-3（175B 参数）→ 服务器跑

- **小模型**：DistilGPT-3（60B 参数）→ 手机端运行

- 通过知识蒸馏，小模型学会了大模型的“经验”

 **类比**： 老师（大模型）讲课 → 学生（小模型）记笔记 → 考试时也能拿高分















![ContactAuthor](https://raw.githubusercontent.com/HealerJean/HealerJean.github.io/master/assets/img/artical_bottom.jpg)



<!-- Gitalk 评论 start  -->

<link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">

<script src="https://unpkg.com/gitalk@latest/dist/gitalk.min.js"></script> 
<div id="gitalk-container"></div>    
 <script type="text/javascript">
    var gitalk = new Gitalk({
		clientID: `1d164cd85549874d0e3a`,
		clientSecret: `527c3d223d1e6608953e835b547061037d140355`,
		repo: `HealerJean.github.io`,
		owner: 'HealerJean',
		admin: ['HealerJean'],
		id: 'KsRNX7mYzuJbLvpfx6nA',
    });
    gitalk.render('gitalk-container');
</script> 




<!-- Gitalk end -->



