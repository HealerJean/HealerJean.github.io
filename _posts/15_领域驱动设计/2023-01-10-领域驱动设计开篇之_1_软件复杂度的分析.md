---
title: 领域驱动设计开篇之_1_软件复杂度的分析
date: 2023-01-10 00:00:00
tags: 
- DDD
category: 
- DDD
description: 领域驱动设计开篇之_1_软件复杂度的分析
---

**前言**     

 Github：[https://github.com/HealerJean](https://github.com/HealerJean)         

 博客：[http://blog.healerjean.com](http://HealerJean.github.io)          



# 一、什么是复杂系统

> **复杂系统是由大量相互作用的部分组成的系统**。与整个系统比起来，**这些组成部分相对简单，没有中央控制，组成部分之间也没有全局性的通信，并且组成部分的相互作用导致了复杂行为**。       
>
> **在软件系统中，函数、类、模块、组件和服务等都可以视为组成部分，他们之间的相互作用最终导致了软件系统的复杂行为**。



## 1、复杂度成因

![image-20230110160410751](https://raw.githubusercontent.com/HealerJean/HealerJean.github.io/master/blogImages/image-20230110160410751.png)



| 理解能力\预测能力 | 有序                               | 复杂难测                                                     | 混沌                                                         |
| ----------------- | ---------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 复杂难测          | 手表：手表结构复杂，功能明确可预测 | 城市：城市建设的空间结构、人员结构都比较复杂，需要人花较多时间才能熟悉，城市的规划也随时间存在不确定性风险，比较难以预测结果 | 股市：影响因素多且复杂，不可控，不可预测，是个典型的混沌模型 |
| 简单              | 内衣：原理简单，功能单一           | 三人团队：需要通过简单的沟通和协作，做到团队成员间的角色和职责清晰可控 | 双摆：结构简单，但是对初始设置具有高度敏感性，其行为不可预测 |

![image-20230110160507690](https://raw.githubusercontent.com/HealerJean/HealerJean.github.io/master/blogImages/image-20230110160507690.png)



## 2、理解能力

> 开发人员对软件系统的理解能力主要在规模、结构

### 1）规模

#### a、需求的数量

> 软件系统的需求决定了系统的规模，一般情况下，数十万行的代码行肯定不能与数千万行的系统规模相比较，而软件系统的规模取决于需求的数量。再者说，需求会生长的，会从一颗小数随着时间慢慢变成参天大树。**到了某一个时间点，需求的数量才会慢慢稳定下来。但是当需求线性增长的时候，为了实现这些功能，软件规模也会线性的增长**



#### b、需求的联系

> 系统规模的扩张，不仅仅是需求的数量，和需求直接的联系也分不开。各种需求功能点直接回相互依赖，修改一处而动全身



#### c、无法避免的技术债

> **随着软件系统规模的扩张，软件复杂度也会增长，但是这种复杂度并不仅仅是线性的，而是更加陡峭的指数级别增长**，不论是多么厉害的大牛，**再今天看似合理的技术方案决策，都会再未来随着系统规模和软件的复杂度变得不堪一击**。     
>
> **主动消除和降低技术债：只不过，区别在于债务的多少问题，以及偿还的利息有多高，一般对付技术债的唯一方案就是让技术债变得可见，指定计划主动消除和降低**       



**技术债的积累： **   

⬤ **需求复杂度增加：**多个功能点的开发实现和功能点之间的千丝万缕联系带来了软件规模的的成倍增加。不同业务场景增加了不同的分支。导致圈复杂度的增加。                

⬤ **设计缺陷：**如果在设计上没有做到功能之间的正交，就会导致代码维护成本的增加；       

⬤ **`bug` 引入：**没有为业务逻辑编写单元测试，建议功能代码的测试网，就可能因为某一处功能点的修改引入潜在的风险，导致系统运行的风险增加。        



**技术债的严重性：**

纷至沓来的技术债逐渐积累，一旦到了某个临界点，迅速会不如衰亡，成为遗留系统，这个相信不少开发人员都遇到过。



#### d、代码行数

> 软件规模的一个显著的特征就是代码行数，但是，代码行数有欺骗性，有时候代码庞大非常肯能是肥胖病，意味着可能出现了大量重复的代码。代码的圈复杂度或多或少也会影响整个软件系统的规模
>



### 2）结构

> 我们熟悉的迷宫就是一个结构非常复杂的空间，很多规模较小但是却非常复杂的系统就是这样的一个迷宫，这个时候结构成为了决定系统复杂度的一个关键因素，但是归根结底，**结构之所以复杂，大多数情况下是由系统的质量属性决定的** 比如：我们需要满足高性能的要求，就可能考虑引入缓存，并行处理，线程池，异步消息等等。



#### a、微服务拆分

> 纵观软件设计的发展史，一定是不断拆分的微型化过程，拆分后的软件单元不可能单兵作战，怎么通信，怎么协同，数据不一致等问题接踵而来，就是系统拆分后面临的主要问题，这些问题的固有复杂度在特定情况下有可能超过分解带来的收益。



#### b、分层架构

> **分层架构的引入是为了维护系统的有序性，但是如果团队不注意维护逻辑分层确定的边界，不按照架构规定的层次分配各个类，各个模块，各个系统的职责。随着团队不注意维护逻辑分层确定的好的边界，就会让边界变的越来越模糊。**     
>
> 最终随着需求的增加，分层架构就失去了原本规划好清晰结构的价值，系统也会变得越来越混乱，最终陷入无序的设计，随着带来的软件复杂度也会大大提高



## 3、预测能力

> 影响预测能力的关于是变化，对变化应对不合理，会导致设计不足或者过度设计。我们无法预知未来，肯定就无法预测未来的变化，这就带来软件系统的不可预测性。    
>
> **在面对可能得变化的时候，我们需要尽可能的保证方案的平衡，既要避免设计不足使得变化对系统产生根本影响，又要防止为了扩展让方案变化的各位复杂。  这非常考验一个开发人员的技术功底**



### 1）过度设计

> 设计软件的时候，变化总会让我们患得患失，不知道如何把握系统设计的度      
>
> ⬤ 如果拒绝变化，系统的设计会变得僵化，一旦有新的变化，修改维护的成本将会非常大。    
>
> ⬤ 如果过于看重变化，希望覆盖一切变化可能，如果预期的变化没有发生，我们之前为变化付出的成本将用于不在补偿回来。



### 2）设计不足

> 很多时候，由于设计人员技能不足，没有明确识别出未来确认会发生的变化，或者对需求的变化放心缺乏前瞻，会导致整个设计变得过于僵化，未来修改的成本太高。这样就会走向另一个极端，这就是设计不足      
>
> 设计不足的方案只顾眼前，对于一定要发生的变化视而不见，这不仅导致方案缺乏可扩展性，甚至有可能出现技术实现方向的错误，这样的实际不是合理的简单设计，而是对于糟糕的质量视而不见，是为了应付进度蒙混过关的临时花招。表面满足了进度要求，但是未来偿还欠下的债务时，需要付出几倍成本。如果整个系统都是都是这样潦草的设计，那么未来说不定某一个需求就会成为压垮这个系统的最后一个稻草









![ContactAuthor](https://raw.githubusercontent.com/HealerJean/HealerJean.github.io/master/assets/img/artical_bottom.jpg)



<!-- Gitalk 评论 start  -->

<link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">

<script src="https://unpkg.com/gitalk@latest/dist/gitalk.min.js"></script> 
<div id="gitalk-container"></div>    
 <script type="text/javascript">
    var gitalk = new Gitalk({
		clientID: `1d164cd85549874d0e3a`,
		clientSecret: `527c3d223d1e6608953e835b547061037d140355`,
		repo: `HealerJean.github.io`,
		owner: 'HealerJean',
		admin: ['HealerJean'],
		id: 'kYKWIOspPT814cxQ',
    });
    gitalk.render('gitalk-container');
</script> 




<!-- Gitalk end -->



