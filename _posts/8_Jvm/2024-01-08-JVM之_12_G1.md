---
title: JVM之_12_G1
date: 2023-12-12 00:00:00
tags: 
- JVM
category: 
- JVM
description: JVM之_12_G1
---

**前言**     

 Github：[https://github.com/HealerJean](https://github.com/HealerJean)         

 博客：[http://blog.healerjean.com](http://HealerJean.github.io)          



# 一、`G1` 介绍

> `G1` `GC`，全称 `Garbage`-`First`   `Garbage` `Collector`，通过 `-XX` : `+UseG1GC` 参数来启用，作为体验版随着 `JDK 6u14`版本面世，在 `JDK 7u4` 版本发行时被正式推出，相信熟悉 `JVM` 的同学们都不会对它感到陌生。在 `JDK` `9 `中，`G1` 被提议设置为默认垃圾收集器（JEP 248）。     
>
> `G1` 是一种服务器端的垃圾收集器，应用在多处理器和大容量内存环境中，在实现高吞吐量的同时，尽可能的满足垃圾收集暂停时间的要求。它是专门针对以下应用场景设计的:    
>
> ⬤  像 `CMS` 收集器一样，能与应用程序线程并发执行。     
>
> ⬤ 整理空闲空间更快。     
>
> ⬤ 需要 `GC` 停顿时间更好预测。     
>
> ⬤ 不希望牺牲大量的吞吐性能。     
>
> ⬤ 不需要更大的 `Java` `Heap`。    
>
> `G1` 收集器的设计目标是取代 `CMS` 收集器，它同 `CMS` 相比，在以下方面表现的更出色：  `G1` 是一个有整理内存过程的垃圾收集器，不会产生很多内存碎片。  `G1` 的 `Stop` `The` `World` ( `STW` )更可控，**G1在停顿时间上添加了预测机制，用户可以指定期望停顿时间**。





# 二、`G1` 中几个重要概念

## 1、分区 `Region`

> 传统的 `GC` 收集器将连续的内存空间划分为新生代、老年代和永久代（`JDK` `8` 去除了永久代，引入了元空间 `Metaspace`），这种划分的特点是各代的存储地址（逻辑地址，下同）是连续的。如下图所示：

![image-20240108174208757](/Users/healerjean/Desktop/HealerJean/HCode/HealerJean.github.io/blogImages/image-20240108174208757.png)



### 1）`Region` 最多有多少？    

**默认情况：**`G1` 将堆内存划分为多个大小相等的 `Region`，最多可以有 `2048` 个 `Region`。每个 `Region` 的大小通常是堆内存大小除以`2048` ，但也可以通过  `JVM`  参数 `-XX:G1HeapRegionSize`来手动指定 `Region` 的大小。需要注意的是，这个参数的值必须是 `2` 的幂，且范围在 `1MB` 到 `32MB`之间。

**实际配置：**在实际使用中，`JVM` 会根据堆内存的大小自动计算  `Region `的数量，但也可以通过调整堆内存大小和`-XX:G1HeapRegionSize` 参数来间接控制 `Region `的数量（手动指定 `Region`大小）。例如，如果堆内存大小为 `4096MB`，且未指定 `-XX:G1HeapRegionSize`参数，则默认每个`Region` 的大小为 `2MB`（`4096MB` / `2048`），`Region`的数量为 `2048`个。 **推荐默认的计算方式**      



### 2）`Region` 各代存储地址是连续的吗？     

答案：   

⬤ **`G1` 的各代存储地址是不连续的，每一代都使用了 `n` 个不连续的大小相同的 `Region`**          

⬤ **`G1` 保留了年轻代和老年代的概念，但不再是物理隔阂了，它们都是（可以不连续）`Region`的集合，一个`Region` 可能之前是年轻代，如果 `Region` 进行了垃圾回收，之后可能又会变成老年代，每个`Region`占有一块连续的虚拟内存地址。`G1` 并不要求对象的存储一定是物理上连续的，只要逻辑上连续即可；每个分区也不会确定地为某个代服务，可以按需在年轻代和老年代之间切换，如下图所示：**

![image-20240108174302364](/Users/healerjean/Desktop/HealerJean/HCode/HealerJean.github.io/blogImages/image-20240108174302364.png)

### 3）`Region` 数量和大小的关系是什么？    

答案：当堆内存总量固定时，如果 `Region`的数量较多，那么每个 `Region`的大小就会相应减小。例如，如果堆内存是 `4GB`，你可以选择有 `2048` 个` Region` （每个 `Region` 大约 `2MB` ），也可以选择有 `1024` 个 `Region`（每个 `Region` 大约 `4MB`），以此类推。    



### 4） `Region` 数量较多好处    

**1、更好的内存利用率**     

**答案**：假设 `JVM` 的堆内存总量为 `4GB`，如果选择较少的 `Region` 数量（比如 `512` 个 `Region`，每个 `Region` 大约 `8MB` ），那么当有大量小对象被创建时，这些对象可能会分散在多个 `Region`中，导致内存碎片的产生。而如果选择较多的 `Region` 数量（比如 `2048`个`Region`，每个 `Region` 大约 `2MB` ），则小对象可以更加紧密地填充在 `Region`中，减少了内存碎片，提高了内存利用率。     



**2、更灵活的 `GC` 管理**

**答案**：在 `GC` 过程中，`G1` 会尝试并行地处理多个 `Region`，以缩短  `GC` 的停顿时间。如果 `Region`数量较多，`G1`可以更加灵活地选择需要回收的 `Region`，**而不是每次都必须处理大量的内存区域**。这样，`G1 `可以更加精确地控制 `GC`的范围和时机，减少对整个应用的影响    



**3、更好的负载平衡**    

**答案**：在多核处理器环境下，`G1` 可以并行地使用多个`GC` 线程来回收 `Region`。如果 `Region` 数量较多，这些 `GC`线程可以更加均匀地分配到各个 `Region` 上，实现更好的负载平衡。这样，每个 `GC` 线程都有足够的工作来做，避免了某些线程空闲而其他线程过载的情况。     



**4、更容易处理大对象**     

**答案**：虽然大对象（巨型对象）会占用多个 `Region`，但在 `Region  `数量较多的情况下，这些大对象对 `GC` 的影响相对较小。因为即使是大对象，也只是占用了相对较少的 `Region` 数量（尽管这些 `Region` 在物理上可能是连续的）。这样，在 `GC` 过程中，`G1` 可以更容易地处理这些大对象，而不会导致整个 `GC` 过程的性能下降，**如果数量较小，则 `Region` 会比较大，导致无法获取巨型对象，不容处理实际出现的大对象** 。



**5、更可预测的停顿时间**    

**答案**：`G1` 收集器提供了可预测的停顿时间模型，允许用户设置期望的 `GC` 停顿时间。在 `Region` 数量较多的情况下，`G1` 可以更加精确地控制每次 `GC` 的停顿时间，因为它可以更加灵活地选择需要回收的 `Region` 。这样，`G1` 可以更加接近地满足用户设置的期望停顿时间，提高了应用的响应性和可预测性。



### 5）初始 `Region`是怎么分配的

> **年轻代与老年代的划分**：虽然  `G1`  在逻辑上保留了年轻代（包括 `Eden` 区和两个 `Survivor` 区）和老年代的概念，但在物理上它们并不再是固定且隔离的。相反，`G1`会根据需要动态地将 ``Region` 分配给年轻代或老年代。默认情况下，年轻代占整个堆内存的 `5%`，但这个比例可以通过 `-XX:G1NewSizePercent ` 和  `-XX:G1MaxNewSizePercent` 参数进行调整 。    
>
> **动态调整**：在  `JVM` 运行过程中，`G1` 会根据应用的内存使用情况和垃圾收集的效果动态地调整 ``Region` 的分配。例如，如果年轻代中的对象频繁晋升到老年代，`G1` 可能会增加老年代中 `Region`的数量以容纳更多的对象



## 2、巨形对象 `Humongous` `Region`

### **1）什么是巨型对象？**    

答案：一个大小达到甚至超过分区大小一半的对象称为巨型对象( `Humongous` `Object` )。       



### 2）巨型对象会直接进入老年代吗？     

答案：`G1`垃圾收集器对于对象什么时候会转移到老年代跟之前讲过的原则一样，唯一不同的是对大对象的处理，`G1` 有专门分配大对象的 `Region` 叫 `Humongous` 区，而不是让大对象直接进入老年代的 `Region`中         



### 3）那巨型对象不直接进入老年代作用是什么呢？     

答案：`Humongous` 区专门存放短期巨型对象，不用直接进老年代，可以**节约老年代的空间，避免因为老年代空间不够的 `GC`开销**。        



### 4）既然不直接进入老年代，那`humongous`区域的大对象什么时候被回收      

答案：其实很简单，在新生代和老年代回收的时候，就会顺带着对大对象一并回收了，所以这就是 `G1` 内存模型下对大对象的分配和回收的策略。`G1` 垃圾收集器在处理巨型对象时，会避免进行拷贝操作，因为巨型对象的拷贝成本很高。在回收时，`G1` 会优先考虑回收那些没有巨型对象的 `Region`，以减少拷贝成本和提高回收效率。      



### 5）如果 `Region` 放不下怎么办？     

答案：如果一个`H` 区装不下一个巨型对象，那么`G1`会寻找连续的 `H` 分区来存储。`G1` 的大多数行为都把 `Humongous` `Region`作为老年代的一部分来进行看待（但还是不太一样哦）



### 6）如何减少 `humongous` 对象影响    

答案：为了减少连续 `H-objs` 分配对 `GC` 的影响，需要把大对象变为普通的对象，建议增大 `Region` `size` （前提是已知有大对象，否则建议默认）。一个 `Region`的大小可以通过参数 `-XX:G1HeapRegionSize `设定，取值范围从 `1M` 到 `32M` ，且是 `2` 的指数，，默认将整堆划分为 `2048` 个分区。如果不设定，那么 `G1` 会根据 `Heap`大小自动决定。





## 3、卡表 `Card` `Table`

> 在 `G1` 堆中，存在一个卡表 `CardTable` 的数据，`CardTable`  是由元素为 `1B` 的数组来实现的，数组里的元素称之为卡片/卡页。这个 `CardTable` 会映射到整个堆的空间，每个卡片会对应堆中的 `512 `字节 空间。     
>
> ⬤ 卡表（`Card` `Table`）是记忆集的一种具体实现，每个 `Region` 被分成了若干个大小为 `512` 字节的连续内存区域，举例，每个 `Region` 大小为 `1` `MB`，每个 `Region` 都会对应 `2048` 个 `Card` `Page`。       
>
> ⬤ 而`Card` `Table`  是一种 `points`-`out`（**我引用了谁的对象**）的结构， `Card` `Table` 维护着所有的 `Card`。`Card` `Table` 的结构是一个字节数组, **`Card` `Table` 用单字节的信息映射着一个 `Card`**。当`Card` 中存储了对象时，称为这个 `Card` 被脏化了（`dirty` `card`）。对于一些热点 `Card` 会存放到 `Hot` `card` `cache`。同 `Card` `Table` 一样，`Hot` `card` `cache` 也是全局的结构。



**查找一个对象所在的 `Card` 的位置索引可以计算得出：对象的地址-堆开始的地址 / `512`**

![image-20240802145811495](/Users/healerjean/Desktop/HealerJean/HCode/HealerJean.github.io/blogImages/image-20240802145811495.png)



### **1）`Card` `Table` 作用是什么呢？**

答案：用于跟踪整个堆内存中各个卡（`Card` ）的状态，以优化垃圾收集（`GC` ）过程。在 `JVM` 中，堆内存通常被划分为新生代和老年代等不同的代，而 `Card` `Table` 的设计初衷是为了解决分代收集时，`live` `set`（存活对象集合）扫描需要穿梭到不同代时的效率问题



### 2）`Card` `Table` 的工作原理

**存储位置：**`Card` `Table`  存储在 `JVM` 的堆内存中，它是一个全局的数据结构，用于记录堆内存中各个 `Card` 的状态信息。



**卡的划分**：每个 `Region` 被分成了若干个大小为 `512` 字节的连续内存区域，每个区域称为一个卡（`Card`）。每个卡对应 `Card` `Table`中的一个元素（通常是一个字节），用于记录该卡的状态。          



**状态记录**：当堆内存中的某个对象引用发生变化时（无论是新生代还是老年代中的对象），`JVM` 会通过写屏障（`Write` `Barrier`）机制来标记该对象所在的卡为“脏”（ `Dirty` ）。这意味着该卡中可能包含了对其他代中对象的引用。       
		**举例：**假设有一个新生代对象 `A`，它引用了老年代对象 `B`。当 `A` 的引用发生变化（例如，`A` 不再引用 `B`，而是引用了一个新的老年代对象 `C`）时，写屏障会被触发。`JVM` 会检查这个引用变化是否涉及到跨代引用，并相应地更新卡表。在这个例子中，由于 `A` 原本引用了老年代对象 `B`，**因此 `B` 所在的卡页对应的卡表项可能会被标记为“脏**”。在后续的 `GC` 过程中，`JVM` 会特别关注这个被标记为“脏”的卡页，以确保不会错误地回收掉仍然被引用的老年代对象 `B`。



**`GC` 时的处理**：在进行垃圾收集时，垃圾收集器会检查 `Card` `Table`中标记为 `Dirty` 的卡。这些卡中的对象会被视为潜在的可达对象，需要被进一步扫描以确定其是否仍然存活。通过这种方式，垃圾收集器可以只扫描那些可能包含存活对象的区域，而不是整个堆内存。



### 3）维护机制

> 卡表的维护依赖于写屏障（`Write` `Barrier`）技术。写屏障是在对象引用赋值操作之前或之后附加的一段代码，用于检测并更新卡表信息。
>
> 1、当一个对象在新生代中被创建，并且其引用被老年代中的对象持有时，写屏障会检测到这一变化，并在卡表中标记对应的卡。    
>
> 2、同样，当老年代中的对象更新了对新生代的引用时，写屏障也会更新卡表，以确保记忆集的准确性。



## 4、`SATB`（`Snapshot` `At` `The` `Beginning`）写屏障技术的应用

> `SATB`（`Snapshot` `At` `The` `Beginning`）写屏障是一种特殊的写屏障技术，它主要用于解决并发标记算法中的漏标问题。



### 1）工作原理

> ⬤ 在 `GC` 开始时（即并发标记的初始阶段），`SATB` 会记录所有 `GC` `Roots` 的初始状态（即“快照”）。    
>
> ⬤ 在并发标记过程中，如果对象的引用发生变化（如新增引用或删除引用），`SATB` 会将这些变化记录下来，但并不会立即更新对象的标记状态。     
>
> ⬤ 在并发标记结束后，`SATB` 会根据记录的变化信息，重新遍历那些引用发生变化的对象，并根据新的引用关系更新它们的标记状态。



### 2）优点

⬤ `SATB` 能够确保在并发标记过程中，即使对象的引用发生变化，也不会导致漏标问题。

⬤ 它通过延迟更新对象的标记状态，减少了并发标记过程中的同步开销。     

**⬤ 与 `RSet` 高效 的配合**：`G1` 中的每个 `region` 都包含一个 `hash` 表（`RSet`），用于记录指向当前 `region` 的外部引用。`SATB` 算法能够很好地利用这一特性，因为它只需要读取 `RSet` 中的内容来更新对象的标记状态，而无需进行全堆扫描。这种高效的配合使得 SATB 算法在 `G1` 中更加适用。





## 5、并发标记算法（三色标记法）

> `CMS` 和 `G1` 在并发标记时使用的是同一个算法：三色标记法，使用白灰黑三种颜色标记对象。白色是未标记；灰色自身被标记，引用的对象未标记；黑色自身与引用对象都已标记。

⬤ 白：对象没有被标记到，标记阶段结束后，会被当做垃圾回收掉。      

⬤ 灰：对象被标记了，但是它的 `field ` 还没有被标记或标记完。      

⬤ 黑：对象被标记了，且它的所有`field` 也被标记完了。



> `GC`  开始前所有对象都是白色， `GC`  一开始所有根能够直达的对象被压到栈中，待搜索，此时颜色是灰色。然后灰色对象依次从栈中取出搜索子对象，子对象也会被涂为灰色，入栈。当其所有的子对象都涂为灰色之后该对象被涂为黑色。当 `GC` 结束之后灰色对象将全部没了，剩下黑色的为存活对象，白色的为垃圾。

![image-20240108195525678](/Users/healerjean/Desktop/HealerJean/HCode/HealerJean.github.io/blogImages/image-20240108195525678.png)





### 1）漏标问题

> 在 `remark` 过程中，黑色指向了白色，如果不对黑色重新扫描，则会漏标。会把白色 `D` 对象当作没有新引用指向从而回收掉。     
>
> 当遍历的 `C` 对象的时候，`C`  对象已经存放到灰色容器中，突然用户线程修改 `C` 对象属性. `E=Null` ; `E` 对象与 `C` 对象断开，则 `E` 对象为垃圾对象，但是用户线程修改`B` 对象的属性= `E` 对象，在进行最终标记阶段时B对象已经为黑色不会继续遍历B对象，就会导致E对象会被垃圾线程清理，这个过程称作为漏标问题。

![image-20240108195743410](/Users/healerjean/Desktop/HealerJean/HCode/HealerJean.github.io/blogImages/image-20240108195743410.png)

并发标记过程中，`Mutator` 删除了所有从灰色到白色的引用，会产生漏标。此时白色对象应该被回收

产生漏标问题的条件有两个：

- 黑色对象指向了白色对象
- 灰色对象指向白色对象的引用消失

所以要解决漏标问题，打破两个条件之一即可：

### 2）解决漏标

⬤ **跟踪黑指向白的增加** `incremental` `update`：增量更新，关注引用的增加，把黑色重新标记为灰色，下次重新扫描属性。`CMS` 采用该方法。    

⬤ **记录灰指向白的消失** `SATB` `snapshot` `at` `the` `beginning`：关注引用的删除，当灰–>白消失时，要把这个 引用 推到 `GC`的堆栈，保证白还能被 `GC` 扫描到。`G1` 采用该方法。      



**问题1：`CMS` 记录跟踪黑指向白的增加 具体过程是什么？**    

**答案：**在并发标记过程中，如果对象的引用发生变化（如新增引用或删除引用），`SATB` 会将这些变化记录下来，但并不会立即更新对象的标记状态。在并发标记结束后，`SATB` 会根据记录的变化信息，重新遍历那些引用发生变化的对象，并根据新的引用关系更新它们的标记状态



**问题2：G1记录灰指向白的消失，具体过程是什么呢？**    

答案：

**引用删除的处理：**当灰色对象删除了对白色对象的引用时（即灰–>白消失），`SATB` 通过写屏障（ `Write` `Barrier` ）来捕获这一变化。具体来说，`G1` 使用前置写屏障（`Pre-write Barrier`）来记录被删除的引用。当引用发生变化时，写屏障会被触发，并将旧引用（即被删除的引用）推送到一个特殊的队列（如 `SATBMarkQueue`）中。     

**保证白色对象被扫描到：**在并发标记的后期阶段（如重新标记阶段），`G1` 会处理 `SATBMarkQueue` 中的对象。这些对象代表了在并发标记过程中被删除的引用所指向的白色对象。`G1` 会以这些白色对象为根，重新扫描它们的引用链，以确保它们被正确地标记为存活或垃圾。通过这种方式，即使白色对象在并发标记过程中被灰色对象删除了引用，它们仍然有机会被扫描到，从而避免了漏标的问题。

​    

**问题：为什么 `G1` 采用 `SATB` 而不用 `incremental` `update`** ？

答案：因为采用 `incremental` `update` 把黑色重新标记为灰色后，之前扫描过的还要再扫描一遍，效率太低。      

**优点：**    

**1、效率提升：**`SATB` 算法在开始时生成一个快照，并假设所有在开始时可达的对象都是存活的。这减少了在并发标记过程中需要处理的对象数量，因为新创建的对象或新增的引用关系在并发标记阶段不会被立即处理，而是留到下一轮垃圾收集时再考虑。相比之下，`incremental update`  算法需要实时跟踪和处理新增的引用关系，这可能会增加额外的开销。    

**2、减少深度扫描**：SATB 算法不需要在重新标记阶段再次深度扫描被删除的引用对象，而 `incremental update` 算法则需要对增量引用的根对象进行深度扫描。由于 G1 的区域（region）众多，这种深度扫描的代价会比 CMS（使用 `incremental update`）的单一老年代区域更高。因此，G1 选择 SATB 算法来避免这种高代价的深度扫描。       

**3、可控的开销**：尽管 `SATB` 算法可能会产生更多的浮动垃圾，但由于 `G1` 扫描的是选定的固定个数的 `region`，这种开销是可控的。同时。       

**缺点：**

1、**浮动垃圾的产生**：`SATB` 算法可能会产生更多的浮动垃圾（即在本次垃圾收集过程中未能回收但将在下次垃圾收集过程中被回收的垃圾）。然而，这种浮动垃圾并不会对程序造成致命影响，因为它们在下次垃圾收集时仍然会被回收。相比之下，漏标（即错误地回收了本应存活的对象）的后果是致命的，因为它会直接影响程序的正确性。      







## 6、已记忆集合 `Remember` `Set` (`RSet`)

> `RSet`，全称 `Remembered` `Set`，是一种记录跨代（或跨 `Region`）引用的数据结构。在 `JVM` 中， `RSet` 用于记录某个 `Region` 中的对象被其他 `Region `中的对象所引用的信息。属于`points` - `into` 结构（**谁引用了我的对象**）。比如 `Region2` 的 `RSet` 中记录着 `Region1` 和 `Region3` 都引用了它的对象     



![image-20240108182646668](/Users/healerjean/Desktop/HealerJean/HCode/HealerJean.github.io/blogImages/image-20240108182646668.png)





### 1）`Rset` 作用     

答案：**通过 `RSet`，垃圾收集器可以快速地定位到可能包含跨代引用的对象**，从而减少了在 `GC` 过程中需要扫描的内存范围，提高了 `GC`的效率。



### 2）`Rset` 工作原理

**存储位置：**`RSet` 主要存储在 `JVM` 的堆内存中，用于跟踪跨代引用的信息。在 `G1` 垃圾收集器等现代 `JVM` 实现中，每个 `Region`（区域）都会有一个与之对应的 `RSet`，用于记录其他 `Region` 对当前 `Region`的引用关系。

**数据结构**：`RSet` 通常实现为一个 `Hash` `Table`，其中 `Key` 是引用当前 `Region` 中对象的外部 `Region` 的起始地址，`Value` 是一个集合，包含了这些外部 `Region` 中引用当前 `Region `内对象的 `Card` `Table`的索引。    

**跨代引用处理**：在 `GC` 过程中，当需要回收某个 `Region` 时，垃圾收集器会先检查该 `Region` 的 `RSet`。如果 `RSet`不为空，则意味着有其他 `Region` 中的对象引用了该 `Region` 中的对象。此时，垃圾收集器会根据 `RSet` 中的信息，只扫描那些可能包含跨代引用的外部`Region` 中的 `Card Table`，而不是扫描整个堆内存。



### 3）存储方式

**稀疏表（`Sparse`）**：使用哈希表来存储，其中 `key` 是 `region` 的索引（ `index`），`value` 是  `card` 数组（`card` `index`）。这种方式适用于引用关系较为稀疏的情况。

​	举例：假设有两个 `Region`，`Region A` 和 `Region B`。`Region A` 中有一个对象 `ObjA`，`Region B` 中有一个对象 `ObjB`，且 `ObjB `的某个字段引用了 `ObjA`。在这个例子中，`Region A` 的 `RSet` 会记录一个条目，`Key` 是 `Region B` 的起始地址（或索引），`Value` 是`Region B` 中引用 `ObjA` 的 `Card` 的索引

​    

**细粒度（`Fine`）**：当某个 `Region` 的 `card` 数量超过一定阈值时，`RSet` 会退化为一个 `bitmap` ，其中每一位对应一个 `card`的索引。这种方式适用于引用关系较为密集的情况。              



**粗粒度（`Coarse`）**：当被引用的 `Region` 数量超过一定阈值时，`RSet` 会进一步退化为只记录 `region` 的引用情况，由 `bitmap`存储，每个分区对应一个比特位，因此粗粒度的 `PRT` 只是记录了引用数量，需要通过整堆扫描才能找出所有引用，因此扫描速度也是最慢的。这种方式适用于引用关系非常密集，且对空间效率有较高要求的情况。







## 5、收集集合：`Collection` `Set`

> `Collection` `Set`，是指在垃圾收集过程中被回收的 `Region` 集合，也可以理解为是垃圾收集暂停过程中被回收的目标     
>
> - 这些 `Region` 可能包括年轻代（`Young` `Generation`）的 `Eden `区、`Survivor`区，以及老年代（`Old` `Generation`）的某些`Region`。
> - `G1`收集器会根据 `Region` 中的垃圾数量和回收收益来决定哪些 `Region` 应该被加入 `CSet` 进行回收。



### 1）`CSet` 的生成与回收过程

1、在垃圾收集开始时，`G1`  收集器会根据一定的策略（如垃圾数量、回收收益等）选择一部分 `Region` 组成 `CSet`。    

2、然后，`G1` 收集器会暂停应用程序的执行（ `Stop` - `The` - `World` ），并对`CSet` 中的 `Region` 进行垃圾收集。     

3、收集过程中，`G1` 会采用复制算法（对于年轻代）或标记-整理算法（对于老年代）来回收垃圾对象，并将存活的对象移动到其他`Region` 中。     

4、收集完成后，`CSet` 中的 `Region` 会被释放并加入到空闲 `Region` 队列中，供后续对象分配使用。



# 三、`G1` 垃圾回收过程

> `G1` 提供了两种主要的垃圾收集模式：`Young` `GC` 和 `Mixed` `GC`。`Full` `GC` 在 `G1` 中不是直接提供的，但在特定情况下（如 `Mixed` `GC` 无法跟上内存分配速度）会回退到串行老年代收集器（ `Serial` `Old` `GC`）进行全堆扫描。     
>
> **与 `CMS` 的“标记--清理”算法不同，`G1`从整体来看是基于“标记整理”算法实现的收集器；从局部上来看是基于“复制”算法实现的。**







![image-20240802174157376](/Users/healerjean/Desktop/HealerJean/HCode/HealerJean.github.io/blogImages/image-20240802174157376.png)



| 参数                      | 说明                                                         |
| ------------------------- | ------------------------------------------------------------ |
| `Young-only phase`        | “ `Young`- `only` ” 是指垃圾收集器只会回收年轻代，该阶段主要完成回收过程中的 年轻代回收（`Young GC`） 和 老年代并发标记周期（`Concurrent Marking Cycle`） 两个过程 |
| `Space-reclamation phase` | 空间回收阶段，该阶段会进行多次年轻代收集（`Young GC`）以及增量回收部分老年代，被称为混合收集（`Mixed GC`）。<br/>当 `G1` 判断继续回收老年代不足以释放更多的空间，或者停顿时间大于 `MaxGCPauseMillis`（默认 `200ms`）时，会退出该阶段。空间回收阶段对应回收过程中的混合回收（`Mixed GC`） |



## 1、`Young` `GC`（年轻代收集）(复制算法)

> `YoungGC` 并不是说现有的 `Eden` 区放满了就会马上触发，`G1` 会计算下现在 `Eden`区回收大概要多久时间，如果回收时间远远小于参数 `-XX:MaxGCPauseMills` 设定的值，那么增加年轻代的 `region`，继续给新对象存放，不会马上做 `Young` `GC`，直到下一次`Eden`区放满，`G1` 计算回收时间接近参数 ` -XX:MaxGCPauseMills` 设定的值，那么就会触发 `Young` `GC`。




当 `Eden` 区域装满，还是会触发新生代的 `GC`，那么新生代的 `GC` 还是会通过复制算法来进行垃圾回收，同时系统进入“`Stop the World`” 状态，然后把 `Eden` 区中的对应的 `Region` 里存活的对象拷贝到 `S1` 对应的 `Region`中，接着回收掉 `Eden` 对应的 `Region` 中的垃圾对象。

![image-20240802173406541](/Users/healerjean/Desktop/HealerJean/HCode/HealerJean.github.io/blogImages/image-20240802173406541.png)



### 1）触发条件

> 当年轻代的 `Eden` 区空间耗尽，无法再为新创建的对象分配内存时，会触发 `G1 Young GC`。



### 2）准备阶段

> **1、选择收集集合（`CSet`）**：`G1` 会在遵循用户设置的 `GC` 暂停时间上限的基础上，选择一个最大年轻代区域数，将这个数量的所有年轻代区域（`Eden` 区和 `Survivor` 区）作为收集集合（ `Collection Set`，简称 `CSet` ）。    
>
> **2、暂停应用程序（`Stop-The-World`）**：为了进行垃圾回收，G1会暂停所有应用程序线程，，以确保在根扫描过程中不会有新的对象被创建或引用关系发生变化。



### 3）回收过程

#### a、跟扫描

#### b. `GC` `Roots`

`GC` `Roots` 是垃圾收集器在进行垃圾回收时需要特别关注的根对象集合。这些根对象通常包括以下几类：

| `Gc Roots`                                        | 说明                                                         |
| ------------------------------------------------- | ------------------------------------------------------------ |
| 虚拟机栈（栈帧中的局部变量表）中引用的对象        | 当 `Java` 方法被执行时，会在虚拟机栈中创建一个栈帧，用于存储局部变量表、操作数栈、动态链接、方法出口等信息。其中，局部变量表中的引用类型变量就构成了 `GC Roots`的一部分。 |
| 方法区中的类静态属性引用的对象                    | 类的静态属性在类加载时就被初始化，并存储在方法区中。这些静态属性引用的对象也是 `GC Roots`的一部分 |
| 本地方法栈中JNI（即一般说的Native方法）引用的对象 | 当Java代码调用本地方法（Native Method）时，这些本地方法可能会通过JNI接口引用一 些`Java` 对象。这些被本地方法引用的对象同样属于 `GC Roots` |



> **1、从 `GC` `Roots`开始遍历**：`G1`垃圾收集器从 `GC Roots` 开始遍历，查找所有从根可达的对象。这些对象被标记为存活对象，即它们在下一次垃圾回收中不应被回收。    
>
> 2、同时，将 `RSet`（`Remembered Set`）中记录的外部引用也作为扫描存活对象的入口。`RSet` 用于跟踪其他区域（如老年代）对年轻代区域的引用。`RSet` 中记录的外部引用也被作为扫描存活对象的入口。这意味着 `G1` 垃圾收集器在根扫描过程中会同时考虑 `GC` `Roots` 和 `RSet` 中的引用关系，以确保所有存活的对象都被正确标记    



#### c、更新 `Rset`

> **脏卡表处理**：在更新 `RSet` 之前，`G1` `Table` 会先处理脏卡表（`Dirty` `Card`）。脏卡表记录了自上次 `GC` 以来哪些内存区域被修改过（即可能有新的跨代引用产生）。    
>
> **更新 `RSet`**：通过遍历脏卡表，`G1` 能够找到所有被老年代引用的年轻代对象，并将这些引用关系更新到 `RSet `中。这样，在后续的根扫描过程中，`G1` 就能够利用 `RSet` 中的信息来避免误回收这些对象。

 举例：假设在`Young GC` 之前，老年代中有一个对象引用了年轻代中的一个对象。在 `Young GC`开始时，这个跨代引用会被记录在脏卡表中。然后，在更新 `RSet` 的过程中，`G1` 会找到这个跨代引用，并将其更新到年轻代的 `RSet` 中。在后续的根扫描过程中，`G1` 会遍历`RSet` 中的引用，确保年轻代中被老年代引用的对象不会被误回收。



#### d、移动存活对象

> 1、遍历标记栈，将栈内的所有存活对象移动至 `Survivor` 区域或老年代区域（如果对象年龄达到晋升阈值）。    
>
> 2、如果 `Survivor` 空间不够，`Eden` 空间的部分数据会直接晋升到老年代空间。    
>
> 3、`Survivor` 区的数据也会移动到新的 `Survivor` 区中，部分数据可能晋升到老年代。





## 2、`Mixed` `GC`（混合收集）

> 当堆占有率 （`-XX：InitiatingHeapOccupancyPercent` ”,默认值是 `45%` ）达到设定的值则触发，回收所有的 `Young` 和部分 `Old` ( 根据期望的 `GC`  停顿时间确定 `old` 区垃圾收集的优先顺序) 以及大对象区          
>
> 需要把各个 `region` 中存活的对象拷贝到别的 `region`里去，拷贝过程中如果发现**没有足够的空  `region`** 能够承载拷贝对象就会触发一次 `Full` `GC`



`-XX：G1MixedGCCountTarget`：可以设置在一次混合回收的过程中，最后一个阶段执行几次混合回收，默认值是 `8` 次！这样设置的目的也是能让每次回收停顿的时长记得到保证同时又能间隙的让系统接着运行。    

`-XX：G1HeapWastePercent`：默认值是 `5%`，意思是当混合回收的时候，一旦空闲出来的`Region` 数量达到了堆内存的5%，此时就会立即停止混合回收。





### 1）全局并发标记

#### a、初始标记，（同 `CMS`）

> 初始标记阶段会  `Stop` `The` `World`（`STW`），这个阶段的耗时通常很短，因为GC Roots的数量相对较少，它是伴随 `Young` `GC` 同步完成的。    
>
> 初始标记主要完成 2 件事情：
>
> > 1、标记 `GC` `Roots` 直接关联的对象   
> >
> > 2、标记出所有的 `survivor` 区（`Root` 区）

![image-20240802174804447](/Users/healerjean/Desktop/HealerJean/HCode/HealerJean.github.io/blogImages/image-20240802174804447.png)

**问题1：为什么初始标记会搭载 `Young` `GC`？**      

答案：最大的考虑是性能问题，这里给出两个具体的理由：

**1、减少停顿时间**：`Young GC` 会 ` Stop The World`，而初始标记刚好借着这个停顿时间，做一些额外的标记工作，从而减少  `STW` 的时间；    

**2、提升效率**：`Young GC` 是回收年轻代，而初始标记是标记年轻代和老年代中存活的对象。两者结合，就可以把处理年轻代这个重叠的过程给复用了，提高垃圾收集的效率；



#### b、并发标记（同 `CMS` ）

> 并发标记阶段就是**从 `GC` `Roots` 的直接关联对象开始遍历整个对象集合的过程**， 这个过程耗时较长但是不需要停顿用户线程， 可以与垃圾收集线程一起并发运行。  
>
> 并发标记主要完成 3件事情：
>
> > 1、从 `GC` `Root` 开始，对堆中所有对象进行可达性分析，确认需要回收的对象    
> >
> > 2、更新卡表    
> >
> > 3、标记空的 `Region`



#### c、重新标记：`Remark`

> 由于并发标记阶段应用线程还在运行，可能会产生新的对象或改变对象的引用关系，因此 `G1` 垃圾收集器需要再次进行短暂的`STW`，以标记那些在并发标记阶段发生变化的对象。重新标记主要完成两件事情：    
>
> > 1、回收并发标记过程中的空 `Regio`    
> >
> > 2、利用起始快照算法  `Snapshot- At-The- Beginning` （`SATB`） 修正并发标记中的数据



### 3）移动/拷贝存活对象

> 1、在混合回收阶段，`G1` 垃圾收集器会根据并发标记的结果，选择部分老年代区域和整个年轻代区域进行回收。这个阶段会停止应用线程的执行，进入`STW` 状态。   
>
> **2、`G1` 垃圾收集器会遍历选定的区域，将存活的对象复制到新的区域中（如果是年轻代，则复制到 `Survivor` 区或老年代；如果是老年代，则复制到其他空闲的老年代区域）。这个过程类似于复制算法，但目标不仅仅是年轻代，也包括部分老年代**。    
>
> 3、复制完成后，`G1` 垃圾收集器会清理掉原区域中的垃圾对象，并释放相应的内存空间。



#### a、选择收集集合`CSet`

> 根据全局并发标记的结果和停顿时间目标，选择部分老年代区域和整个年轻代区域作为 `CSet`。



#### b、清理阶段-筛选回收：`Cleanup`

> 1、对存活对象进行统计并完全释放空闲区域。（`STW`）     
>
> 2、清理记忆集（`Remembered Sets`）。（`STW`）     
>
> 3、重置空闲区域并将它们返回到空闲列表。（并发执行）



**问题1： 筛选器是如何回收的？**    

答案：：筛选回收阶段首先 **对各个 `Region` 的回收价值和成本进行排序，根据用户所期望的 `GC` 停顿时间**（可以用 `JVM` 参数 **`-XX:MaxGCPauseMillis` **指定）**来制定回收计划**。

​		举例：比如说老年代此时有`1000` 个 `Region` 都满了，但是因为根据预期停顿时间，本次垃圾回收可能只能停顿 `200` 毫秒，那么通过之前回收成本计算得知，可能回收其中 `800` 个 `Region` 刚好需要`200ms` ，那么就只会回收 `800` 个 `Region` ( `Collection Set` ，要回收的集合)，尽量把 `GC` 导致的停顿时间控制在我们指定的范围内。     

​		这个阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分 `Region`，时间是用户可控制的，而且停顿用户线程将大幅提高收集效率。    



 **问题2：筛选器是如何实现的？ **   

答案：`G1`  收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的 `Region` (这也就是它的名字 `Garbage`-`First` 的由来)，比如一个`Region` 花 `200ms` 能回收 `10M` 垃圾，另外一个 `Region` 花 `50ms` 能回收 `20M` 垃圾，在回收时间有限情况下，`G1` 当然会优先选择后面这个`Region` 回收。这种使用 `Region` 划分内存空间以及有优先级的区域回收方式，保证了 `G1` 收集器在有限时间内可以尽可能高的收集效率。



### 3）整理内存空间

> 由于混合回收涉及到了老年代的回收，`G1`垃圾收集器还会对内存空间进行整理，以减少内存碎片的产生。这个过程类似于标记-整理算法中的整理阶段。    
>
> **注意：`G1`混合回收的算法并不是纯粹的复制算法或整理算法，而是结合了这两种算法的优点。在年轻代回收时，`G1` 更倾向于使用复制算法来减少 `GC` 停顿时间；而在老年代回收时，`G1` 则会使用标记-整理算法来整合内存碎片并释放更多的内存空间**。





## 3、`Full` `GC` （全堆收集）

> `Fu1l GC` 是 `G1` 最后的防护线，它本是 `G1` 设计时需要尽量避免的。在 `G1` 中，`Full` `GC` 通常不是由 `G1`直接触发的，而是在特定情况下（如`Mixed` `GC` 无法跟上内存分配速度）会回退到串行老年代收集器（ `Serial` `Old` `GC` ）进行全堆扫描。`Full` `GC`是一个耗时的过程，会停止所有应用线程，直到垃圾收集完成。

**`G1`  主要通过以下几个参数和指标来决定是否需要触发 `Full` `GC`：**

| 参数                                | 默认值 | 说明                                                         | 举例                                                         |
| ----------------------------------- | ------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| `-XX:G1HeapWastePercent`            | `5%`   | 堆中可以容忍的最大垃圾比例。如果在 `Mixed` `GC` 之后，垃圾的比例超过了这个阈值，`G1` 可能会触发 `Full` `GC` 来回收更多的空间 | `-XX:G1HeapWastePercent=10` 意味着 `G1`将在预计回收超过堆的 `10%` 时启动混合垃圾收集。 |
| `-XX:G1MixedGCLiveThresholdPercent` | `85%`  | 当 `Old` 区中的对象占用的比例超过多少时，这部分区域会被包含在 `Mixed GC` 中，默认 85。如果这个比例设置得太低，可能会导致过多的`Old` 区域被包含在 `Mixed GC` 中，进而增加 `GC` 的工作量和停顿时间，最终可能引发 `Full GC` | `-XX:G1MixedGCLiveThresholdPercent=60` 表示如果混合垃圾收集后旧区中的存活对象比例低于 `60%`，`G1` 将尝试在下一次混合垃圾收集中回收更多区域。 |
| `-XX:G1MixedGCCountTarget`          | `8`    | 在开始进行 `Full` `GC` 之前，可以执行的 `Mixed` `GC`的最大次数。如果连续的 `Mixed GC `没有有效地回收内存，达到这个次数限制后，`G1` 可能会触发 `Full` `GC`。 | `-XX:G1MixedGCCountTarget=4`  表示 `G1` 将尝试在并发标记周期结束时，通过执行至多 `4` 次混合垃圾收集来清理足够的空间。 |
| `-XX:G1ReservePercent`              | `10%`  | 保留的堆内存的百分比，默认是 `10`，作为一个缓冲区来减少 `Full` `GC`的发生。如果可用内存低于这个阈值，`G1` 可能会触发 `Full` `GC`<br><br>阈值”并不是指保留区域的百分比本身，而是指堆内存的整体使用情况。具体来说，当堆内存的使用率达到某个临界点（这个临界点取决于多个因素，包括堆内存的大小、G1ReservePercent的设置、GC停顿时间目标等）时，G1垃圾收集器可能会决定触发Full GC来清理内存。然而，由于保留区域的存在，G1在触发Full GC之前通常会有更多的选择和灵活性来管理内存。 | `-XX:G1ReservePercent=10` 表示 `JVM` 堆中将保留 `10%` 的空间作为预留空间，用于在并发垃圾收集期间使用。 |



# 三、`G1` 和 `CSM` 差异

## 1、相同点

> **1、目标**：两者都旨在通过回收`JVM` 堆内存中的无用对象来优化内存使用，并减少内存泄漏的风险。    
>
> **2、`Full` `GC`**：在特定条件下，`G1` 和 `CMS` 都会触发 `Full` `GC`，即对整个堆（包括年轻代和老年代）进行垃圾收集。



## 2、区别

|                     | `G1`                                                         | `CMS`                                                        |
| ------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **适用场景**        | 适用于大内存、多 `CPU` 的服务端应用                          | 适用于对停顿时间要求较高的应用，如互联网网站或`B/S` 系统的服务端 |
| **垃圾收集算法**    | 基于区域的内存管理，将堆划分为多个 `Region`，采用标记-整理算法，局部（`Region`之间）可能采用复制算法 | 基于标记-清除算法，仅作用于老年代                            |
| **Full GC时的停顿** | 在进行`Full` `GC` 时需要暂停用户线程                         | 在 `Full` `GC` 时尽量不暂停用户线程，但初始标记和重新标记阶段会 `STW` |
| **内存碎片**        | 通过整理内存区域，减少了内存碎片                             | 由于采用标记-清除算法，可能会产生内存碎片                    |
| **内存压缩**        | 支持在垃圾收集时进行内存整理和压缩                           | 不支持内存压缩，特定条件下支持压缩，即`UseCMSCompactAtFullCollection`设置为true时），CMS是支持在Full GC过程中进行内存压缩整理的。通过合理设置`CMSFullGCsBeforeCompaction`参数，用户可以在减少内存碎片与降低停顿时间之间找到最佳的平衡点。 |
| **CPU资源需求**     | 需要更多的 `CPU` 资源来运行，以缩短 `STW` 时间               | 对 `CPU` 资源敏感，但总体需求相对较少                        |
| **默认性**          | 从 `JDK` `9`开始，`G1` 成为默认的垃圾回收器                  | 在早期 `JDK` 版本中，`CMS` 是可选的并发垃圾收集器，但不是默认选项 |



## 3、优缺点

### 1）`G1` - 优点

**1、高效并行与并发，适用于大内存、多核环境**

> `G1` 采用了并行和并发的方式进行垃圾收集，可以充分利用多核处理器的计算能力。在回收期间，多个`GC` 线程可以同时工作，提高了垃圾收集的效率。`G1` 的设计初衷就是针对拥有多核处理器和大内存的机器，通过并行和并发的方式提高垃圾收集的效率，同时减少停顿时间，满足服务端应用的需求。



**b、分代收集**

> `G1` 虽然依然区分年轻代和老年代，但不再坚持固定大小和固定数量的堆区域划分。它将堆空间分为若干个区域（Region），这些区域在逻辑上可以是年轻代或老年代的一部分，回收的粒度更细，范围更小，使得垃圾收集更加灵活。



**c、空间整合与减少内存碎片**

> `G1` 使用标记-整理算法，对内存进行压缩和整理，减少了内存碎片的产生。这种特性有利于程序长时间运行，尤其是在分配大对象时不会因为找不到连续的内存空间而提前触发 `GC`。



**d、可预测的停顿时间**

> `G1` 允许用户设定 `GC` 的停顿时间目标，通过跟踪各个 `Region` 的垃圾堆积价值，优先回收价值最大的 `Region`，从而在保证吞吐量的同时，尽量满足用户设定的停顿时间要求。







### 2）`G1` - 缺点

**a、`CPU` 资源消耗**

> `G1` 在垃圾收集过程中需要多个`GC` 线程同时工作，这会增加 `CPU` 的负载。尤其是在高负载情况下，可能会影响应用程序的性能。



**b、实现复杂度**

> `G1` 引入了新的数据结构和算法（如 `RSet`、`Card` `Table`等），使得实现相对复杂。这增加了维护的难度，也提高了出错的概率。



**c、在某些场景下吞吐量可能不如其他收集器**

> 虽然 `G1` 在大多数情况下都能提供较好的性能，但在某些特定场景下（如小内存应用），其吞吐量可能不如其他收集器（如 `CMS`， **`G1` 复杂的数据结构和算法会占用一定的性能；多线程并行执行由于小内存资源有限，多线程并行可能会引发线程资源竞争和上下文切换开销进而降低系统吞吐量** ）。



### 3）`CMS `- 优点

**a、低停顿时间**

> `CMS` 采用了并发标记和并发清除的方式，大部分垃圾收集工作都可以与应用程序并发执行，从而减少了用户线程的停顿时间。



**b、高吞吐量，与应用程序并发执行**

> 由于 `CMS` 在并发阶段不会暂停用户线程，因此可以保持较高的应用程序吞吐量，通过并发执行的方式实现这一目标。。



### 4）`CMS` -缺点

**a、内存碎片**

> `CMS` 采用标记-清除算法，可能会导致内存碎片的产生。当内存碎片过多时，可能需要提前触发 `Full` `GC` 来整理内存，从而影响性能。



**b、对 `CPU `资源敏感**

> `CMS` 在并发标记和并发清除阶段会占用一部分 `CPU` 资源，这可能会导致应用程序的吞吐量下降。



**c、无法处理浮动垃圾，可能产生"`Concurrent` `Mode` `Failure`"**

> 在并发清除阶段，用户线程还在运行，可能会产生新的垃圾对象（浮动垃圾）。这些垃圾对象需要在下一次 `GC` 时才能被清理，从而增加了`GC` 的负担。当老年代内存不足以存放新产生的浮动垃圾时， `CMS` 可能会触发" `Concurrent` `Mode` `Failure`"，导致另一次`Full` `GC` 的产生。这会增加停顿时间，并影响性能。



### 4、什么场景适合 `G1`

**1）`50%` 以上的堆被存活对象占用**

> 使用 `G1` ，就不用特意预留出很大的老年代空间，`G1` 会根据对象存活状态，动态分配每种不同代对象需要占用的空间。



**2）对象分配和晋升的速度变化非常大**

> 前提还是大内存机器才使用 `G1`，大内存的主机如果对象分配和晋升的速度变化非常快的话，`G1` 的这种内存设计可以很快的划分出对应所需的区域【区域占比动态增长，不像 `CMS` 等垃圾收集器要划分固定的空间来区分年轻代和老年代】，但因为 `G1` 算法比较复杂，在小内存机器里面性能不如 `CMS` 等主流垃圾收集器。



**3）垃圾回收时间特别长，超过1秒，停顿时间是 `500ms` 以内**

> `G1` 有一大好处就是可以设置我们每次想要回收的停顿时间【 **`-XX:MaxGCPauseMillis`**】，可以有效提升用户体验。



**4）8GB以上的堆内存(建议值)**

> `G1` 适合8G以上内存的机器使用【结构设计，`2048` 个 `Region` ，内存太小的话每个 `Region` 也很小，很容易就超过 `Region` 的一半被识别为超大对象，这样 `Humongous` 区东西会很多，反而不能很好的进行 `GC`收集】





# 五、`JVM` `G1` 参数

| 参数                        | 说明                                                         | 用法 |
| --------------------------- | ------------------------------------------------------------ | ---- |
| `XX:+UseG1GC`               | 启用 `G1`垃圾收集器                                          |      |
| `-XX:G1HeapRegionSize`      | 每个分区的大小，默认值是会根据整个堆区的大小计算出来，范围是 `1M` ~ `32M`，取值是 `2` 的幂，计算的倾向是尽量有 `2048` 个分区数。比如如果是 `2G` 的 `heap` ，那 `region` = `1M`。`16Gheap`, `region=8M`。 |      |
| `-XX:ConcGCThreads`         | 并发执行的线程数，默认值接近整个应用线程数的1/4。            |      |
| `-XX:G1MixedGCCountTarget:` | 一次全局并发标记之后，后续最多执行的 `MixedGC`次数。默认值是8. |      |







![ContactAuthor](https://raw.githubusercontent.com/HealerJean/HealerJean.github.io/master/assets/img/artical_bottom.jpg)



<!-- Gitalk 评论 start  -->

<link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">

<script src="https://unpkg.com/gitalk@latest/dist/gitalk.min.js"></script> 
<div id="gitalk-container"></div>    
 <script type="text/javascript">
    var gitalk = new Gitalk({
		clientID: `1d164cd85549874d0e3a`,
		clientSecret: `527c3d223d1e6608953e835b547061037d140355`,
		repo: `HealerJean.github.io`,
		owner: 'HealerJean',
		admin: ['HealerJean'],
		id: 'IQKZSpCBmtrX26iL',
    });
    gitalk.render('gitalk-container');
</script> 




<!-- Gitalk end -->



