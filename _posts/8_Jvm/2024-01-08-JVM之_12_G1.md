---
title: JVM之_12_G1
date: 2023-12-12 00:00:00
tags: 
- JVM
category: 
- JVM
description: JVM之_12_G1
---

**前言**     

 Github：[https://github.com/HealerJean](https://github.com/HealerJean)         

 博客：[http://blog.healerjean.com](http://HealerJean.github.io)          



# 一、`G1` 介绍

> `G1` `GC`，全称 `Garbage`-`First`   `Garbage` `Collector`，通过 `-XX` : `+UseG1GC` 参数来启用，作为体验版随着 `JDK 6u14`版本面世，在 `JDK 7u4` 版本发行时被正式推出，相信熟悉 `JVM` 的同学们都不会对它感到陌生。在 `JDK` `9 `中，`G1` 被提议设置为默认垃圾收集器（JEP 248）。     



- **`G1` 收集器的设计目标：**`G1` 收集器的设计目标是取代 `CMS` 收集器，它同 `CMS` 相比，在以下方面表现的更出色：  `G1` 是一个有整理内存过程的垃圾收集器，不会产生很多内存碎片。  `G1` 的 `Stop` `The` `World` ( `STW` )更可控，**`G1` 在停顿时间上添加了预测机制，用户可以指定期望停顿时间**。

- **`G1` 收集器的应用场景：**`G1` 是一种服务器端的垃圾收集器，应用在多处理器和大容量内存环境中，**在实现高吞吐量的同时，尽可能的满足垃圾收集暂停时间的要求**。它是专门针对以下应用场景设计的:    

  - 像 `CMS` 收集器一样，能与应用程序线程并发执行。     


  - 整理空闲空间更快。     

  - 需要 `GC` 停顿时间更好预测。     

  - 不希望牺牲大量的吞吐性能。     

  - 不需要更大的 `Java` `Heap`。    



# 二、`G1` 中几个重要概念

## 1、分区 `Region`

> **传统的 `GC` 收集器：**连续的内存空间划分为新生代、老年代和永久代（`JDK` `8` 去除了永久代，引入了元空间 `Metaspace`），这种划分的特点是各代的存储地址（逻辑地址，下同）是连续的。如下图所示：

![image-20240108174208757](https://raw.githubusercontent.com/HealerJean/HealerJean.github.io/master/blogImages/image-20240108174208757.png)



### 1）`Region` 大小和数量有多少？    

**默认情况：**`G1` 将堆内存划分为多个大小相等的 `Region`，JVM 在自动计算 Region Size 时，**目标是让 Region 数量接近 2048**，但只是一个启发式初始值，**不是硬性规定**，**`Region` 的最大数量是 `65536`（即 2^16）**。每个 `Region` 的大小通常是堆内存大小除以`2048` ，但也可以通过  `JVM`  参数 `-XX:G1HeapRegionSize` 来手动指定 `Region` 的大小。需要注意的是，这个参数的值必须是 `2` 的幂，且范围在 `1MB` 到 `32MB`之间。

**实际配置：**在实际使用中，`JVM` 会根据堆内存的大小自动计算  `Region `的数量，但也可以通过调整堆内存大小和`-XX:G1HeapRegionSize` 参数来间接控制 `Region `的数量（手动指定 `Region`大小）。   

- 例如，如果堆内存大小为 `4096MB`，且未指定 `-XX:G1HeapRegionSize`参数，则默认每个`Region` 的大小为 `2MB`（`4096MB` / `2`），`Region`的数量为 `2048`个。 **生产环境建议显式设置 `-XX:G1HeapRegionSize`**      

- 推荐值：**示例**：`-XX:G1HeapRegionSize= 4M  `表示每个 `Region`大小为 `4MB`。
  - 小堆（ ≤ `4GB`）：`2MB`
  - 中等堆（`4GB`~`32GB`）：`4MB`~`8MB`
  - 大堆（ ≥ `32GB` ）：`16MB`~`32MB`



**问题1：**为什么有人说“最多 2048”？这是怎么来的   

答案：`JVM` 在自动决定 `Region Size` 时，**目标是让 `Region` 总数接近 `2048`**。但这只是一个“启发式初始值”，**不是上限**

| 概念                         | 数值      | 说明                                                         |
| ---------------------------- | --------- | ------------------------------------------------------------ |
| **初始默认目标 Region 数量** | ~2048     | JVM 启动时“希望”划分成约 2048 个 Region（用于自动计算 Region Size） |
| **实际最大 Region 数量**     | **65536** | 系统硬上限，不可超过                                         |



**问题2：`G1 Region` 大小是如何确定的？**   

答案：G1 使用如下优先级顺序决定 `Region Size`：

1. 如果显式设置了 `-XX:G1HeapRegionSize=N`，推荐用于生产环境，避免自动计算不一致 

2. 如果未设置，则 `JVM` 自动计算：

- 目标：**堆大小 ÷ ~2048 ≈ `Region` `Size`**
- 但结果必须是：**1MB、2MB、4MB、8MB、16MB、32MB** 中的一个
- 然后反向计算出实际 `Region` 数量



**问题3：推荐配置策略是什么（根据堆大小）**

| 堆大小 | 目标 Region 数 | 推荐 Region Size                                             | 实际 Region 数 |
| ------ | -------------- | ------------------------------------------------------------ | -------------- |
| 4GB    | ~2048          | 2MB                                                          | 2048           |
| 8GB    | ~2048          | 4MB                                                          | 2048           |
| 32GB   | ~2048          | 16MB                                                         | 2048           |
| 64GB   | ~2048          | 32MB                                                         | 2048           |
| 128GB  | ~2048          | 但最大只能 32MB → 实际 Region Size=32MB → 实际 Region 数 = 128*1024/32 = **4096** |                |



### 2）`Region` 各代存储地址是连续的吗？     

⬤ **`G1` 的各代存储地址是不连续的，每一代都使用了 `n` 个不连续的大小相同的 `Region`**          

⬤ **`G1` 保留了年轻代和老年代的概念，但不再是物理隔阂了，它们都是（可以不连续）`Region`的集合，   **

- **一个`Region` 可能之前是年轻代，如果 `Region` 进行了垃圾回收，之后可能又会变成老年代，每个`Region`占有一块连续的虚拟内存地址。**
- **`G1` 并不要求对象的存储一定是物理上连续的，只要逻辑上连续即可；每个分区也不会确定地为某个代服务，可以按需在年轻代和老年代之间切换，如下图所示：**

![image-20240108174302364](https://raw.githubusercontent.com/HealerJean/HealerJean.github.io/master/blogImages/image-20240108174302364.png)

### 3）`Region` 数量和大小的关系是什么？    

答案：当堆内存总量固定时，如果 `Region`的数量较多，那么每个 `Region`的大小就会相应减小。例如，如果堆内存是 `4GB`，你可以选择有 `2048` 个` Region` （每个 `Region` 大约 `2MB` ），也可以选择有 `1024` 个 `Region`（每个 `Region` 大约 `4MB`），以此类推。    



### 4） `Region` 数量较多好处    

**1、更好的内存利用率**     

**答案**：假设 `JVM` 的堆内存总量为 `4GB`，如果选择较少的 `Region` 数量（比如 `512` 个 `Region`，每个 `Region` 大约 `8MB` ），那么当有大量小对象被创建时，这些对象可能会分散在多个 `Region`中，导致内存碎片的产生。而如果选择较多的 `Region` 数量（比如 `2048`个`Region`，每个 `Region` 大约 `2MB` ），则小对象可以更加紧密地填充在 `Region`中，减少了内存碎片，提高了内存利用率。     



**2、更灵活的 `GC` 管理**

**答案**：在 `GC` 过程中，`G1` 会尝试并行地处理多个 `Region`，以缩短  `GC` 的停顿时间。如果 `Region`数量较多，`G1`可以更加灵活地选择需要回收的 `Region`，**而不是每次都必须处理大量的内存区域**。这样，`G1 `可以更加精确地控制 `GC`的范围和时机，减少对整个应用的影响    



**3、更好的负载平衡**    

**答案**：在多核处理器环境下，`G1` 可以并行地使用多个`GC` 线程来回收 `Region`。如果 `Region` 数量较多，这些 `GC`线程可以更加均匀地分配到各个 `Region` 上，实现更好的负载平衡。这样，每个 `GC` 线程都有足够的工作来做，避免了某些线程空闲而其他线程过载的情况。     



**4、更容易处理大对象**     

**答案**：虽然大对象（巨型对象）会占用多个 `Region`，但在 `Region  `数量较多的情况下，这些大对象对 `GC` 的影响相对较小。因为即使是大对象，也只是占用了相对较少的 `Region` 数量（尽管这些 `Region` 在物理上可能是连续的）。这样，在 `GC` 过程中，`G1` 可以更容易地处理这些大对象，而不会导致整个 `GC` 过程的性能下降，**如果数量较小，则 `Region` 会比较大，导致无法获取巨型对象，不容处理实际出现的大对象** 。



**5、更可预测的停顿时间**    

**答案**：`G1` 收集器提供了可预测的停顿时间模型，允许用户设置期望的 `GC` 停顿时间。在 `Region` 数量较多的情况下，`G1` 可以更加精确地控制每次 `GC` 的停顿时间，因为它可以更加灵活地选择需要回收的 `Region` 。这样，`G1` 可以更加接近地满足用户设置的期望停顿时间，提高了应用的响应性和可预测性。



### 5）初始 `Region`是怎么分配的

- **年轻代与老年代的划分**：虽然  `G1`  在逻辑上保留了年轻代（包括 `Eden` 区和两个 `Survivor` 区）和老年代的概念，但在物理上它们并不再是固定且隔离的。相反，`G1`会根据需要动态地将 `Region` 分配给年轻代或老年代。默认情况下，年轻代占整个堆内存的 `5%`，但这个比例可以通过 `-XX:G1NewSizePercent ` 和  `-XX:G1MaxNewSizePercent` 参数进行调整 。    

- **动态调整**：在  `JVM` 运行过程中，`G1` 会根据应用的内存使用情况和垃圾收集的效果动态地调整 ``Region` 的分配。例如，如果年轻代中的对象频繁晋升到老年代，`G1` 可能会增加老年代中 `Region`的数量以容纳更多的对象



### 6）如何查看 `Regin` 分配情况

使用 `jmap` - `head`命令，**理论总 `Region` 数** 可能和实际分配的不一致。`JVM` 可能不会将所有 `Region` 都分配给年轻代、老年代或`Survivor` 区，原因包括：

- **内存对齐**：`JVM` 可能对堆起始地址或 `Region` 边界进行对齐（如按页大小对齐），导致部分空间未被使用。
- **保留空间**：`JVM` 可能预留部分 `Region` 用于特殊用途（如巨型对象分配、元空间映射等）。
- **动态调整**：`G1` 在运行时可能动态调整各代大小，但总 `Region` 数不变。

**未分配的 `Region` 原因和 去向**，这些“缺失”的 `Region` 可能用于以下场景：

1. 空闲 `Region`（`Free` `Regions`）：`G1` 维护一个全局的空闲 `Region` 列表（`Free` `List`），用于动态分配给年轻代或老年代。
2. 未使用的堆空间：`JVM` 可能未将堆的全部容量划分为 `Region` ，例如保留部分空间作为安全边际。
3. `G1` 内部管理结构：`G1` 需要额外的 `Region` 存储元数据（如 `Remembered` `Sets`、`Card` `Table`等），这些可能不直接计入各代。





## 2、巨形对象 `Humongous` `Region`

### **1）什么是巨型对象？**    

答案：一个大小达到甚至超过分区大小一半的对象称为巨型对象( `Humongous` `Object` )。       



### 2）巨型对象会直接进入老年代吗？     

答案：`G1`垃圾收集器对于对象什么时候会转移到老年代跟之前讲过的原则一样，唯一不同的是对大对象的处理，`G1` 有专门分配大对象的 `Region` 叫 `Humongous` 区，而不是让大对象直接进入老年代的 `Region`中         



### 3）那巨型对象不直接进入老年代作用是什么呢？     

答案：`Humongous` 区专门存放短期巨型对象，不用直接进老年代，可以**节约老年代的空间，避免因为老年代空间不够的 `GC`开销**。        



### 4）既不直接进入老年代，那`humongous`区域大对象什么时候回收      

答案：其实很简单，在新生代和老年代回收的时候，就会顺带着对大对象一并回收了，所以这就是 `G1` 内存模型下对大对象的分配和回收的策略。`G1` 垃圾收集器在处理巨型对象时，会避免进行拷贝操作，因为巨型对象的拷贝成本很高。在回收时，`G1` 会优先考虑回收那些没有巨型对象的 `Region`，以减少拷贝成本和提高回收效率。      



### 5）如果 `Region` 放不下怎么办？     

答案：如果一个`H` 区装不下一个巨型对象，那么`G1`会寻找连续的 `H` 分区来存储。`G1` 的大多数行为都把 `Humongous` `Region`作为老年代的一部分来进行看待（但还是不太一样哦）



### 6）如何减少 `humongous` 对象影响    

- 大对象变普通对象：为了减少连续 `H-objs` 分配对 `GC` 的影响，需要把大对象变为普通的对象，建议增大 `Region` `size` （前提是已知有大对象，否则建议默认）。一个 `Region`的大小可以通过参数 `-XX:G1HeapRegionSize `设定，取值范围从 `1M` 到 `32M` ，且是 `2` 的指数，
- **监控 `Humongous` `Allocation`：**开启 `GC` 日志，`-XX:+PrintHeapAtGC`，观察是否有大量 H-obj：



## 3、卡表 `Card` `Table`

- **目的**：**解决跨代引用问题**：在进行 **`Minor GC`（新生代回收）** 时，如何快速找到“老年代对象 → 新生代对象”的引用？

  - `Minor GC` 只扫描新生代，但如果老年代有对象引用了新生代对象，这个新生代对象就不能被回收。所以必须知道哪些老年代区域包含了对新生代的引用

- **原理**：将堆内存划分为固定大小的小块（称为“`Card`”），**每个 `Card` 用一个字节记录其状态**，   

  - **当一个对象 `A` 修改了它的字段，使其指向另一个代的对象 `B` 时，`JVM` 会将 “对象 A 所在的 `Card`” 标记为 `Dirty`**。  
  - 比如：**当老年代对象引用了新生代对象时，该老年代对象所在的 `Card` 被标记为“脏”**

-  **图解分析**

  -  堆内存布局

    - 整个堆被划分为多个 `Region`，每个 `Region` 大小相同（例如 1MB）。

    - 每个 `Region` 内部又被细分为更小的 `Card`，每个 `Card` 大小为 512 字节。

    - ```
      Heap (1 GB)
      +-------------------+-------------------+ ... +-------------------+
      | Region 0          | Region 1          | ... | Region N          |
      +-------------------+-------------------+ ... +-------------------+
      ```

  - `Card Table` 结构

    - `Card Table` 是一个数组，每个元素对应一个 `Card`。

    - 数组长度 = 堆大小 / 卡片大小 = `1GB` / `512B` = `2097152` 个元素。

    - 每个元素是一个字节，记录该 `Card` 是否“脏”（即是否有老年代对象引用新生代对象）。

    - ```
      Card Table (2 MB)
      +-------------------+-------------------+ ... +-------------------+
      | Card 0            | Card 1            | ... | Card 2097151      |
      +-------------------+-------------------+ ... +-------------------+
      ```



### 1）如何计算 `Card` 的位置索引？

   (对象地址 - 堆开始地址) / 512计算对象在堆中的偏移量。



### 2） 为什么 `Card` 大小是 512 字节？

A: 这是为了平衡空间开销和查找效率。如果 `Card` 太小，`Card Table` 会非常大；如果 `Card` 太大，精度会降低。



### 3）`Card Table` 的大小怎么计算？

`Card Table` 大小 = 堆大小 / `Card` 大小。例如 1GB 堆，512 字节 `Card` → Card Table 需要 2MB。



### 4）如果没有 `Card Table` 会怎样？

A: 没有 `Card Table`，`GC` 需要全堆扫描来追踪跨代引用，性能会大幅下降。



### 5）应用场景

- 跨代引用追踪
  - 在 `Minor GC` 时，只需要检查 `Card Table` 中标记为“脏”的 `Card`，就能快速找到老年代对象对新生代对象的引用。
  - 避免全堆扫描，提高 `GC` 效率。
-  `Write Barrier`：当程序写入对象引用时，`JVM` 会自动更新 `Card Table`，标记相应的 `Card` 为“脏”。



### 6）脏 只会标记老年代对象吗

**不会！`Card Table` 的“脏”标记，并不是只针对老年代对象。**

- 老年代对象引用新生代对象（最常见、最重要，这是 `Card` `Table` 最主要的用途。）
  - 在下一次 **`Minor GC`** 时，`GC` 需要知道“谁引用了新生代”
  - 它只需扫描所有 **`Dirty Card`**，找到 `objOld`，发现它引用了 `child`
  - 于是 `child` 不会被回收

- 新生代对象引用老年代对象（也会触发，但意义不同，**通常不重要，但技术上会发生。**）
  - 在 **`Full` `GC` 或 `Mixed` `GC`** 中，整个堆都会被扫描，不需要依赖 Card Table
  - 在 **`Minor` `GC`** 中，我们只关心“谁引用了新生代”，不关心“新生代引用了谁”



## 4、`SATB`（`Snapshot` `At` `The` `Beginning`）写屏障技术的应用

> `SATB`（`Snapshot` `At` `The` `Beginning`）写屏障是一种特殊的写屏障技术，它主要用于解决并发标记算法中的漏标问题。



### 1）工作原理

**目标：**在 **并发标记** 期间，用户线程还在运行，对象引用可能随时变化。 `SATB` 的目标是：**确保不会漏掉任何原本可达、但后来被断开引用的对象**。

| 项目               | 说明                                                       |
| ------------------ | ---------------------------------------------------------- |
| **写屏障做什么**   | 在 `A.field = C` 之前，把 `A.field` 原来的值（B）记录下来  |
| **为什么能防漏标** | 即使 B 后来没人引用，GC 也会因为“它曾被引用”而重新检查它   |
| **代价是什么**     | 可能多标一些已经“真正死亡”的对象（称为“浮动垃圾”），但安全 |

#### **a、工作流程**

- 原来：A 引用 B，B 是可达的，会被标记

- 用户线程执行：A.field = C，A 不再引用 B（B 可能变成不可达）

- 触发 SATB 写屏障：在赋值前，JVM 记录：B 曾经被引用过！，把 B 加入“待标记队列”

- GC 后续会处理 B，确保它被正确标记

#### **b、标记过程：**

```
并发标记开始时（快照）：
   A → B → C
     ↗
    D

用户线程修改：
   A → C     // 断开对 B 的引用

SATB 写屏障：
   “等等！B 被删了，先记下来！”
   → 把 B 加入标记栈

GC 继续标记：
   从栈中取出 B，继续标记 C、D……
   → B 不会被漏标
```



### 2）优点

| 优点                   | 说明                                                         |
| ---------------------- | ------------------------------------------------------------ |
| **防止漏标**           | 在并发标记期间，即使对象引用被修改，也能通过“删除前记录”机制，确保存活对象不被错误回收。 |
| **低性能开销**         | 写屏障仅在引用修改时触发，只记录被删除的引用目标，对应用线程影响小。 |
| **支持高效并发**       | 无需暂停用户线程，是 `G1` 等垃圾回收器实现并发标记的关键技术。 |
| **与 `RSet` 协同高效** | RSet 告诉 GC “谁引用了我”，SATB 确保“被断开的引用对象不丢失”，两者配合实现精准、快速的跨区标记。 |



## 5、并发标记算法（三色标记法）

> **CMS 和 G1 在并发标记阶段都基于“三色标记法”**，通过 **白、灰、黑** 三种颜色动态标记对象的可达性状态，以识别存活对象。 **理想情况下**：灰色对象全部处理完，仅剩黑色（存活）和白色（垃圾）

| 颜色     | 正确性保证                       | 含义                                                         |
| -------- | -------------------------------- | ------------------------------------------------------------ |
| **白色** | 垃圾，未处理或不可达，最终被回收 | 对象尚未被标记，**默认状态**。标记阶段结束后，仍为白色的对象将被回收。 |
| **灰色** | 正在处理中，不会丢失             | 对象自身已被标记，但它的 **成员字段（引用）还未被处理**。它是“正在处理”的中间状态，通常存放在标记栈或队列中。 |
| **黑色** | 已完全处理，不会遗漏             | 对象自身已被标记，且 **所有成员字段指向的对象也都被标记完成**。它是“已完成”的状态。 |



**标记过程：**

```
1. 初始状态：所有对象为 白色
2. GC Roots（根对象）直接引用的对象 → 标记为 灰色，加入标记栈

3. 从栈中取出一个灰色对象
4. 扫描它的所有引用字段
5. 将其引用的白色对象标记为 灰色，入栈
6. 当该对象的所有引用都被处理后 → 标记为 黑色

7. 重复 3~6，直到标记栈为空
8. 结束：所有黑色对象为存活对象，白色对象为垃圾，可回收
```



![image-20240108195525678](https://raw.githubusercontent.com/HealerJean/HealerJean.github.io/master/blogImages/image-20240108195525678.png)



### 1）漏标问题

原因：在 **并发标记**（如 `CMS`、`G1`）中，用户线程（`Mutator`）和 `GC` 线程同时运行，在 `remark` 过程中，黑色指向了白色，如果不对黑色重新扫描，则会漏标。会把白色 `D` 对象当作没有新引用指向从而回收掉。        

当遍历的 `C` 对象的时候，`C`  对象已经存放到灰色容器中，突然用户线程修改 `C` 对象属性. `E=Null` ; `E` 对象与 `C` 对象断开，则 `E` 对象为垃圾对象，但是用户线程修改 `B` 对象的属性= `E` 对象，在进行最终标记阶段时 `B` 对象已经为黑色不会继续遍历 `B` 对象，就会导致 `E` 对象会被垃圾线程清理，这个过程称作为漏标问题。    



问题：并发标记过程中，`Mutator` 删除了所有从灰色到白色的引用，会产生漏标。此时白色对象应该被回收

产生漏标问题的条件有两个：

- 黑色对象指向了白色对象
- 灰色对象指向白色对象的引用消失

所以要解决漏标问题，打破两个条件之一即可：



![image-20240108195743410](https://raw.githubusercontent.com/HealerJean/HealerJean.github.io/master/blogImages/image-20240108195743410.png)





### 2）解决漏标

⬤ **跟踪黑指向白的增加** `incremental` `update`：增量更新，关注引用的增加，把黑色重新标记为灰色，下次重新扫描属性。`CMS` 采用该方法。    

⬤ **记录灰指向白的消失** `SATB` `snapshot` `at` `the` `beginning`：关注引用的删除，当灰 –>白消失时，要把这个 引用 推到 `GC`的堆栈，保证白还能被 `GC` 扫描到。`G1` 采用该方法。      



**问题1：`CMS` 记录跟踪黑指向白的增加 具体过程是什么？**    

**答案：**在并发标记过程中，如果对象的引用发生变化（如新增引用或删除引用），`SATB` 会将这些变化记录下来，但并不会立即更新对象的标记状态。在并发标记结束后，`SATB` 会根据记录的变化信息，重新遍历那些引用发生变化的对象，并根据新的引用关系更新它们的标记状态



**问题2：G1记录灰指向白的消失，具体过程是什么呢？**    

答案：

**引用删除的处理：**当灰色对象删除了对白色对象的引用时（即灰–>白消失），`SATB` 通过写屏障（ `Write` `Barrier` ）来捕获这一变化。具体来说，`G1` 使用前置写屏障（`Pre-write Barrier`）来记录被删除的引用。当引用发生变化时，写屏障会被触发，并将旧引用（即被删除的引用）推送到一个特殊的队列（如 `SATBMarkQueue`）中。     

**保证白色对象被扫描到：**在并发标记的后期阶段（如重新标记阶段），`G1` 会处理 `SATBMarkQueue` 中的对象。这些对象代表了在并发标记过程中被删除的引用所指向的白色对象。`G1` 会以这些白色对象为根，重新扫描它们的引用链，以确保它们被正确地标记为存活或垃圾。通过这种方式，即使白色对象在并发标记过程中被灰色对象删除了引用，它们仍然有机会被扫描到，从而避免了漏标的问题。

​    

**问题：为什么 `G1` 采用 `SATB` 而不用 `incremental` `update`** ？

答案：因为采用 `incremental` `update` 把黑色重新标记为灰色后，之前扫描过的还要再扫描一遍，效率太低。      

**优点：**    

**1、效率提升：**`SATB` 算法在开始时生成一个快照，并假设所有在开始时可达的对象都是存活的。这减少了在并发标记过程中需要处理的对象数量，因为新创建的对象或新增的引用关系在并发标记阶段不会被立即处理，而是留到下一轮垃圾收集时再考虑。相比之下，`incremental update`  算法需要实时跟踪和处理新增的引用关系，这可能会增加额外的开销。    

**2、减少深度扫描**：SATB 算法不需要在重新标记阶段再次深度扫描被删除的引用对象，而 `incremental update` 算法则需要对增量引用的根对象进行深度扫描。由于 G1 的区域（region）众多，这种深度扫描的代价会比 CMS（使用 `incremental update`）的单一老年代区域更高。因此，G1 选择 SATB 算法来避免这种高代价的深度扫描。       

**3、可控的开销**：尽管 `SATB` 算法可能会产生更多的浮动垃圾，但由于 `G1` 扫描的是选定的固定个数的 `region`，这种开销是可控的。同时。       

**缺点：**

1、**浮动垃圾的产生**：`SATB` 算法可能会产生更多的浮动垃圾（即在本次垃圾收集过程中未能回收但将在下次垃圾收集过程中被回收的垃圾）。然而，这种浮动垃圾并不会对程序造成致命影响，因为它们在下次垃圾收集时仍然会被回收。相比之下，漏标（即错误地回收了本应存活的对象）的后果是致命的，因为它会直接影响程序的正确性。      





## 6、已记忆集合 `Remember` `Set` (`RSet`)

> `RSet`，全称 `Remembered` `Set`，是一种记录跨代（或跨 `Region`）引用的数据结构。在 `JVM` 中， `RSet` 用于记录某个 `Region` 中的对象被其他 `Region `中的对象所引用的信息。属于`points` - `into` 结构（**谁引用了我的对象**）。       
>
> **举例**：Region R5 的 RSet = { R1, R3, R7 }，表示：Region R1、R3、R7 中有对象引用了 R5 中的某个对象。



### 1）核心作用

- 避免在 `GC` 时进行 **全堆扫描** 来查找跨 `Region` 引用
- 在 **`Mixed GC`** 或 **`Young GC`** 时，快速定位哪些 `Region` 中的对象引用了当前 `Region` 的对象



### 2）基本概念

| 术语          | 说明                                                       |
| ------------- | ---------------------------------------------------------- |
| **RSet 类型** | `points-into` 结构（**谁引用了我**）                       |
| **粒度**      | 每个 `Region` 拥有一个独立的 RSet                          |
| **内容**      | 记录：**哪些外部 `Region` 中的对象引用了本 Region 的对象** |
| **存储形式**  | 通常是哈希表或位图，存储“源 Region”的标识                  |



**结构：**每个 `Region` 的 `RSet` 包含一个 **哈希表（Hash Table）**，其结构如下：

| 层级      | 内容                                                         |
| --------- | ------------------------------------------------------------ |
| **Key**   | 源 `Region` 的索引（`Region Index`），不是起始地址           |
| **Value** | 一个 **集合（Collection）**，记录源 `Region` 中哪些 **Card** 包含对当前 Region 的引用 |

这个集合根据密度分为两种模式：

| 模式               | 说明                                                         |
| ------------------ | ------------------------------------------------------------ |
| **Fine-Grained**   | 使用 **BitMap**，每个 bit 代表一个 Card，适用于引用较少的场景 |
| **Coarse-Grained** | 使用 **单个 bit** 表示整个源 Region 的所有 Card，适用于大量跨区引用（如老年代大对象） |



### b、`Rset` 工作原理

**存储位置：**`RSet` 属于 `JVM` `GC` 元数据（`GC` `Metadata`），通常存储在堆外内存（`Off-Heap`）或堆内受控区域，不由用户代码直接访问。。   

- **跨代引用处理**：在 `GC`（如 `Young GC` 或 `Mixed GC`）过程中，当需要回收某个 `Region` 时，垃圾收集器会检查其 **RSet**。如果 `RSet` 非空，说明有外部 Region 中的对象引用了该 Region 中的对象。此时，`GC` 会：

  1. 遍历 RSet 中记录的每个源 Region

  1. 根据 `RSet` 中的 `Card` 信息，定位到源 `Region` 中具体的 `Card`

  1. 扫描这些 `Card` 对应的内存区域，查找对当前 `Region` 的引用

  1. 将这些引用作为 **`GC` `Root` 的一部分**，确保被引用对象不被误回收

这样就避免了全堆扫描，极大提升了 `GC` 效率。







### 3）与 `Card Table` 的关系

| 组件           | 角色                                               | 关系         |
| -------------- | -------------------------------------------------- | ------------ |
| **Card Table** | 原始日志：记录哪些 `Card` 发生了跨 `Regio`n 写操作 | **输入源**   |
| **RSet**       | 精确索引：记录“哪个 `Region` 引用了我”             | **加工结果** |

**协作流程**：

1. 用户线程执行：`objInR1.field = objInR5`（跨 `Region` 引用）
2. 触发 **写屏障** → 将 `objInR1` 所在的 Card 标记为 **`Dirty`**
3. 并发线程扫描 `Dirty Card`
4. 解析出 “`R1` → `R5`” 的引用关系
5. 将 `R1` 添加到 **`R5` 的 `RSet`** 中





### 4）`RSet` 的优势

| 优点              | 核心机制                    | 实际收益                           |
| ----------------- | --------------------------- | ---------------------------------- |
| **避免全堆扫描**  | 反向引用索引（谁引用了我）  | 减少扫描范围，避免 O(n) 扫描老年代 |
| **支持 Mixed GC** | 精确定位跨 Region 引用      | 实现增量回收，避免 Full GC         |
| **提升 GC 效率**  | 空间换时间 + 写屏障异步维护 | 降低 STW，提高吞吐量和响应性       |

#### a、**避免全堆扫描**

- 问题背景：在没有 `RSet` 的传统分代收集器中，当进行一次 **年轻代 `GC`（`Young GC`）** 时，为了判断年轻代中的对象是否存活，必须检查整个老年代是否有对象引用了这些年轻代对象。否则，就可能发生 **误回收**（如前文例子所示）。

  - 如果每次 `Young GC` 都要扫描整个老年代，开销巨大。

  - 老年代可能非常大，扫描时间长，导致 **`Stop-The-World（STW）`** 时间不可控。

- **`RSet` 如何解决：**  
  - `RSet` 为每个 `Region` 维护了一个“反向引用”列表，记录了 **哪些其他 Region 引用了它**。
    - 例如：`RSet of R5 = {R1, R3, R7}` 表示：Region 1、Region 3、Region 7 中有对象引用了 R5 中的对象。
  - 在 `Young GC` 扫描时，`G1` **不需要扫描整个老年代**，而只需检查 `RSet` 中列出的那些 Region（如 R1、R3、R7）中的引用即可。

- 效果：

  - **扫描范围从“整个老年代”缩小到“几个特定 Region”**。

  - 大幅减少 GC 工作量，显著降低 STW 时间。

  - 实现了“**局部化扫描**”，是 G1 高效性的基石。



#### b、支持 `Mixed GC`（混合回收）

`G1` 的一大特性是可以在一次 `GC` 周期中，不仅回收年轻代 `Region`，还可以**选择性地回收部分老年代 `Region`**，这种 GC 称为 **`Mixed GC`**。这是 `G1` 实现“可预测停顿时间”模型的关键。



**挑战：**当 `G1` 决定回收某个老年代 `Region`（如 `R5`）时，必须确保：

- `R5` 中的对象没有被其他**仍存活的 `Region`** 引用。
- 否则，如果 `R5` 被回收，但其他 `Region` 还引用它，就会导致悬空指针。

**`RSet` 如何支持：**`RSet` 提供了快速定位“谁引用了我”的能力。

- 当 `G1` 准备回收 Region R5 时，它会检查 `RSet of R5`。
- 如果 `RSet` 中列出的某些 Region（如 R1、R3）也**同时被选中回收**，那么这些引用可以忽略。
- 如果 RSet 中的某些 Region（如 R7）**不被回收**，那么 R5 中被 R7 引用的对象就不能被回收，必须保留或移动。

**效果：**

- `G1` 可以**精确判断**哪些老年代 `Region` 可以安全回收。
- 实现了“**增量式老年代回收**”，避免长时间 `Full` `GC`。
- 支持 `G1` 的“**垃圾优先**”策略：优先回收垃圾最多的 `Region`。



#### c、提升 ·GC 效率，降低 STW 时间

`RSet` 的设计本质上是一种 **空间换时间** 的优化。

- **空间成本**：每个 Region 都要维护一个 RSet，占用额外内存。
- **时间收益**：极大减少了 `GC` 时的扫描工作量。

- **具体体现：**

  - **`Young GC` 更快**：
    - 只需扫描 RSet 中的少量 Region，而不是整个堆。
    - STW 时间更短，应用响应更及时。

  - **Mixed GC 更高效**：
    - 快速定位跨 Region 引用，避免无效回收尝试。
    - 提高了 GC 的吞吐量和可预测性。

  - **写屏障 + 延迟更新**：
    - G1 使用写屏障（Write Barrier）异步维护脏卡表。
    - RSet 的更新可以在 GC 间隙进行，避免在 GC 时做大量工作。
    - 进一步平滑了 GC 停顿。





### 5）`RSet` 的代价

| 缺点         | 说明                                                         |
| ------------ | ------------------------------------------------------------ |
| **内存开销** | 每个 Region 都要维护一个 RSet，占用额外内存（**通常占堆 1~2%**） |
| **维护开销** | 写屏障 + 并发线程处理 `Dirty` `Card`，带来轻微性能损耗       |
| **复杂性**   | G1 使用 **Sparse RSet / Fine/Coarse 模式** 优化存储          |



## 5、收集集合：`Collection` `Set`

> `Collection` `Set`，是指在垃圾收集过程中被回收的 `Region` 集合，也可以理解为是垃圾收集暂停过程中被回收的目标     
>
> - 这些 `Region` 可能包括年轻代（`Young` `Generation`）的 `Eden `区、`Survivor`区，以及老年代（`Old` `Generation`）的某些`Region`。
> - `G1`收集器会根据 `Region` 中的垃圾数量和回收收益来决定哪些 `Region` 应该被加入 `CSet` 进行回收。



### 1）`CSet` 的生成与回收过程

1、在垃圾收集开始时，`G1`  收集器会根据一定的策略（如垃圾数量、回收收益等）选择一部分 `Region` 组成 `CSet`。    

2、然后，`G1` 收集器会暂停应用程序的执行（ `Stop` - `The` - `World` ），并对`CSet` 中的 `Region` 进行垃圾收集。     

3、收集过程中，`G1` 会采用复制算法（对于年轻代）或标记-整理算法（对于老年代）来回收垃圾对象，并将存活的对象移动到其他`Region` 中。     

4、收集完成后，`CSet` 中的 `Region` 会被释放并加入到空闲 `Region` 队列中，供后续对象分配使用。



# 三、`G1` 垃圾回收过程

> `G1` 提供了两种主要的垃圾收集模式：`Young` `GC` 和 `Mixed` `GC`。`Full` `GC` 在 `G1` 中不是直接提供的，但在特定情况下（如 `Mixed` `GC` 无法跟上内存分配速度）会回退到串行老年代收集器（ `Serial` `Old` `GC`）进行全堆扫描。     
>
> **与 `CMS` 的“标记--清理”算法不同，`G1`从整体来看是基于“标记整理”算法实现的收集器；从局部上来看是基于“复制”算法实现的。**







![image-20240802174157376](https://raw.githubusercontent.com/HealerJean/HealerJean.github.io/master/blogImages/image-20240802174157376.png)



| 参数                      | 说明                                                         |
| ------------------------- | ------------------------------------------------------------ |
| `Young-only phase`        | “ `Young`- `only` ” 是指垃圾收集器只会回收年轻代，该阶段主要完成回收过程中的 年轻代回收（`Young GC`） 和 老年代并发标记周期（`Concurrent Marking Cycle`） 两个过程 |
| `Space-reclamation phase` | 空间回收阶段，该阶段会进行多次年轻代收集（`Young GC`）以及增量回收部分老年代，被称为混合收集（`Mixed GC`）。<br/>当 `G1` 判断继续回收老年代不足以释放更多的空间，或者停顿时间大于 `MaxGCPauseMillis`（默认 `200ms`）时，会退出该阶段。空间回收阶段对应回收过程中的混合回收（`Mixed GC`） |



## 1、`Young` `GC`（年轻代收集）(复制算法)



![image-20240802173406541](https://raw.githubusercontent.com/HealerJean/HealerJean.github.io/master/blogImages/image-20240802173406541.png)



### 1）触发条件

- **`Eden` 区空间耗尽**：当年轻代中的 `Eden` 区域被新创建的对象填满，无法再分配新的对象时，理论上会触发 `Young GC`。然而，在 `G1` 中，这并不是立即发生的。
- **回收时间预估**：`G1` 收集器会计算当前 `Eden` 区的回收所需时间。如果这个预估时间远小于由参数 `-XX:MaxGCPauseMillis` 设定的最大暂停时间目标，那么 `G1` 可能会选择增加年轻代的 `region` 数量，允许更多的对象分配，而不是立即进行垃圾回收。
- **接近设定值时触发**：只有当回收 `Eden` 区的时间接近或达到 `-XX:MaxGCPauseMillis` 参数所设定的值时，才会真正触发 `Young GC`。



### 2）准备阶段

> **1、选择收集集合（`CSet`）**：`G1` 会在遵循用户设置的 `GC` 暂停时间上限的基础上，选择一个最大年轻代区域数，将这个数量的所有年轻代区域（`Eden` 区和 `Survivor` 区）作为收集集合（ `Collection Set`，简称 `CSet` ）。    
>
> **2、暂停应用程序（`Stop-The-World`）**：为了进行垃圾回收，`G1` 会暂停所有应用程序线程，，以确保在根扫描过程中不会有新的对象被创建或引用关系发生变化。



### 3）回收过程

- **复制算法**：一旦触发 `Young GC`，会采用复制算法进行垃圾回收。在这个过程中，存活的对象会被复制到另一个区域，通常是 `Survivor` 区域（如 `S0` 或 `S1`），也可能根据具体情况直接晋升到老年代。
- **`Stop the World` 事件**：在执行 `Young GC` 期间，整个应用会暂时停止（即“Stop the World”状态），以便 JVM 安全地进行垃圾回收操作。这段时间内所有的用户线程都会被挂起。
- **清理 `Eden` 区**：完成对象的复制后，原先 `Eden` 区中对应的 `Region` 将被清空，回收其中的空间以供后续的新对象分配使用。



#### a、根扫描 (`GC Roots` 扫描)

- **从 `GC` `Roots` 开始遍历**：`G1` 收集器首先从 `GC` `Roots` 开始遍历整个对象图，寻找所有可达的对象。这些对象被认为是存活的，不会被垃圾回收。
- 同时，**`RSet` 中记录的外部引用也被视为根的一部分进行扫描，以确保准确标记存活对象**。

| `Gc Roots`                                           | 说明                                                         |
| ---------------------------------------------------- | ------------------------------------------------------------ |
| 虚拟机栈（栈帧中的局部变量表）中引用的对象           | 当 `Java` 方法被执行时，会在虚拟机栈中创建一个栈帧，用于存储局部变量表、操作数栈、动态链接、方法出口等信息。其中，局部变量表中的引用类型变量就构成了 `GC Roots`的一部分。 |
| 方法区中的类静态属性引用的对象                       | 类的静态属性在类加载时就被初始化，并存储在方法区中。这些静态属性引用的对象也是 `GC Roots`的一部分 |
| 本地方法栈中 `JNI`（即一般说的Native方法）引用的对象 | 当Java代码调用本地方法（Native Method）时，这些本地方法可能会通过JNI接口引用一 些`Java` 对象。这些被本地方法引用的对象同样属于 `GC Roots` |



#### c、更新 `Rset`

- **脏卡表处理**：在更新 `RSet` 之前，`G1` 首先处理脏卡表。脏卡表记录了自上次 `GC` 以来哪些内存区域发生了变化（例如，可能有新的跨代引用产生）。通过检查这些“脏”区域，`G1` 可以识别出需要更新 `RSet` 的部分。
- **更新 `RSet`**：根据脏卡表的信息，`G1` 找到老年代中指向年轻代对象的所有引用，并将这些信息更新到 `RSet` 中。**这一步骤对于避免误回收非常重要，因为它确保了年轻代中被老年代引用的对象不会被错误地当作垃圾回收掉**。



#### d、移动存活对象

- **遍历标记栈**：完成根扫描和 `RSet` 更新后，`G1` 开始遍历标记栈中的存活对象，将其移动到适当的区域。存活对象通常会被移动到 `Survivor` 区域；如果对象达到了晋升年龄阈值，则直接移动到老年代。
- **处理空间不足的情况**：如果 `Survivor` 空间不足以容纳所有的存活对象，或者某些对象已经达到晋升阈值，那么这些对象会直接晋升到老年代。此外，在某些情况下，`Eden` 区的部分数据也可能因为 `Survivor` 空间的限制而直接晋升到老年代。



## 2、`Mixed` `GC`（混合收集）

`Mixed GC` 是 在不触发 `Full` `GC` 的前提下，逐步清理老年代垃圾，控制停顿时间，避免“全堆扫描”

- 它不仅回收 **所有年轻代 `Region`（`Eden` + `Survivor`）**
- 还会**选择性地回收部分老年代 Region（Old Generation Regions）**
- 同时也会清理 **大对象 Region（Humongous Regions）**

| 特性             | 说明                                                         |
| ---------------- | ------------------------------------------------------------ |
| **触发条件**     | 堆使用率 ≥ `IHOP`（默认 45%）→ 启动并发标记 → 标记完成后进入 Mixed GC |
| **回收范围**     | 所有 Young Region + 部分 Old Region + Humongous Region       |
| **目标**         | 实现“增量式老年代回收”，避免 Full GC                         |
| **控制停顿**     | 通过 `G1MixedGCCountTarget` 分多轮执行，每轮控制 STW 时间    |
| **避免过度回收** | `G1HeapWastePercent=5%`，达到后提前结束 Mixed GC             |
| **风险**         | 若 Region 不足或并发失败，仍会退化为 Full GC                 |



### 1）`Mixed` `GC` 触发条件

触发逻辑：当 **整个 `Java` 堆的占用率** 达到设定阈值（默认 `45%`）时，G1 会启动一个 **并发标记周期（Concurrent Marking Cycle）**：

```
-XX:InitiatingHeapOccupancyPercent=45  # 默认值 45%
```



**问题1：`Mixed` `GC` 到底是几个阶段？**

| 视角               | 阶段划分                | 说明                                                         |
| ------------------ | ----------------------- | ------------------------------------------------------------ |
| **宏观视角**       | 2 个阶段                | 1. 全局并发标记（准备）<br>2. 多轮 `Mixed` `GC` 执行（回收） |
| **微观视角**       | 多个阶段                | 标记周期有 `4` 个子阶段，执行阶段有 `N` 轮 `STW` 回收        |
| **`JVM` 日志视角** | 多次 `GC pause (mixed)` | 每次 `STW` 回收都是一条独立日志                              |

| 问题                                   | 回答                                                         |
| -------------------------------------- | ------------------------------------------------------------ |
| **Mixed GC 是两个阶段吗？**            | 从流程上看，可分为 **准备（标记）** 和 **执行（回收）** 两大阶段。 |
| **但执行阶段是几次？**                 | 通常是 **多次 STW 回收**（默认最多 8 次），不是一次完成。    |
| **全局并发标记是 Mixed GC 一部分吗？** | 是的，它是 `Mixed` `GC` 的**必要前置流程**，没有它就没有 `Mixed` `GC`。 |



**问题2：举个例子？**  

答案：假设你的应用堆使用率达到 45%，触发 IHOP：

1. **第1步**：启动 **并发标记周期**（耗时几秒，大部分并发）

2. **第2步**：标记完成，进入 **Cleanup**，G1 得到一个“回收优先级列表”

3. 第3步

   ：接下来的几次 `GC` 不再是纯 `Young` `GC`，而是：

   - `GC pause (mixed)` #1：回收 10 个老年代 Region
   - `GC pause (mixed)` #2：再回收 10 个
   - ...
   - `GC pause (mixed)` #8：完成预定目标

4. **第4步**：如果还有高价值 `Region`，可能继续；否则回到 Young GC





### 2）`Mixed GC` 执行策略

为了保证每次 `GC` 停顿时间可控（由 `-XX:MaxGCPauseMillis` 控制，默认 200ms），G1 不会一次性回收所有老年代 `Region`，而是分批进行。

#### a、`-XX:G1MixedGCCountTarget=8`（默认 8 次）

举例：如果有 `16` 个高垃圾率的老年代 `Region` 要回收，`G1` 会尽量在 8 次 Mixed GC 中完成，每次回收 ~2 个。

- 表示：`G1` 期望将所有待回收的老年代 `Region` 分成 **最多 8 轮** 来完成。
- 每轮 `Mixed` `GC` 只回收一部分 Region。
- 目的是：**摊薄总暂停时间**，避免某一次 `GC` 停顿过长。



#### b、`-XX:G1HeapWastePercent=5`（默认 5%）

- 含义：在 `Mixed GC` 过程中，允许“浪费”的空间比例为堆的 5%。
- 即：当已经回收到 **空闲 `Region` 数量 ≥ 堆总 Region 数 × 5%** 时，`G1` 会提前终止后续的 Mixed GC。
- 为什么需要这个？
  - 因为越往后回收，剩下的 `Region` 垃圾越少，**收益递减**。继续回收可能得不偿失（花了很多时间，只腾出一点点空间）。

- 效果：

  - 避免“过度回收”

  - 提高 GC 吞吐量

  - 减少不必要的 `STW`



#### c、动态调整回收集（`Collection Set, CSet`）

`G1` 在每次 `Mixed` `GC` 前都会动态决定本次要回收哪些 Region：

- 优先选择 **垃圾最多** 的 `Region`（`Garbage` `First` 策略）
- 结合 `-XX:MaxGCPauseMillis` 目标，估算本次能安全回收的 Region 数量
- 构建 `CSet`（包含部分 `Eden`、`Survivor` 和若干 Old Region）





### 3）阶段1：全局并发标记

| 子阶段                         | 类型                | 说明                                        |
| ------------------------------ | ------------------- | ------------------------------------------- |
| 1. 初始标记（Initial Mark）    | STW                 | 搭载 Young GC，标记 GC Roots 直接引用的对象 |
| 2. 并发标记（Concurrent Mark） | 并发                | 遍历对象图，标记所有存活对象                |
| 3. 重新标记（Remark）          | STW                 | 修正并发期间的引用变化（使用 SATB）         |
| 4. 清理（Cleanup）             | 部分 STW + 部分并发 | 统计存活、释放空 Region、排序回收优先级     |



#### a、初始标记 `Initial Mark`（同 `CMS`）—— `STW`

初始标记阶段会  `Stop` `The` `World`（`STW`），这个阶段的耗时通常很短，因为 `GC Roots` 的数量相对较少，它是伴随 `Young` `GC` 同步完成的。    

- **特点**：短暂的 `Stop-The-World`（`STW`）。
- **通常搭载 `Young` `GC` 执行**，复用其 `STW` 时间，提升效率。
- 任务：
  - 标记 `GC` `Roots` 直接引用的对象。
  - 标记当前 `Survivor` 区（作为根区 `Root` `Regions`）。



**问题1：为什么初始标记会搭载 `Young` `GC`？**      

- **减少停顿时间**：`Young GC` 会 ` Stop The World`，而初始标记刚好借着这个停顿时间，做一些额外的标记工作，从而减少  `STW` 的时间；
- **提升效率**：`Young GC` 是回收年轻代，而初始标记是标记年轻代和老年代中存活的对象。两者结合，就可以把处理年轻代这个重叠的过程给复用了，提高垃圾收集的效率；

![image-20240802174804447](https://raw.githubusercontent.com/HealerJean/HealerJean.github.io/master/blogImages/image-20240802174804447.png)



#### b、并发标记 `Concurrent Marking`（同 `CMS` ）—— 并发执行

此阶段由并发线程执行，过程耗时较长但是不需要停顿用户线程， 可以与垃圾收集线程一起并发运行。任务包括：

- 从 `GC` `Root` 开始，对堆中所有对象进行可达性分析，，标记存活对象
- 记录 `SATB`（`Snapshot-At-The-Beginning`）快照，用于后续修正
- 更新 `RSet` 和卡表（`Card Table`）
- 识别并标记完全为空的  `Region`（可用于后续回收）



#### c、重新标记：`Remark` —— `STW`

由于并发标记阶段应用线程还在运行，可能会产生新的对象或改变对象的引用关系，因此 `G1` 垃圾收集器需要再次进行短暂的`STW`，以标记那些在并发标记阶段发生变化的对象。重新标记主要任务：

- 处理在并发标记期间发生的引用变更（通过 `SATB` 记录的“已删除引用”）
- 标记在并发期间新晋升或新分配的存活对象。
- 完成最终的存活对象标记。



#### d、清理阶段 `Cleanup` —— 部分 `STW` + 部分并发

`Cleanup` 阶段是 **全局并发标记周期（`Global` `Concurrent` `Marking`）的最后一个阶段**，它标志着标记周期的结束，并为即将开始的 **`Mixed` `GC`** 做准备。，确定哪些 `Region` 值得回收。**只有完全空的 `Region` 才会被立即回收**。部分存活的 `Region` 不会在此阶段回收，而是进入后续的 **`Mixed GC`** 阶段处理。   

**`Cleanu`p 阶段在短暂 `STW` 中完成存活统计、空 `Region` 释放和 `RSet` 清理，随后并发地重置空 `Region` 并构建 `CSet` 优先级列表。它为 `Mixed` `GC` 提供决策依据，但不执行对象复制或内存整理。**



- `STW` 阶段（短暂暂停）：此 `STW` 阶段非常短暂，仅处理元数据，不移动对象。

| 阶段                     | 任务                              | 说明                                                         |
| ------------------------ | --------------------------------- | ------------------------------------------------------------ |
| **存活对象统计**         | **统计各 Region 的存活对象数量**  | 基于并发标记的结果，计算每个 `Region` 中存活对象的大小。这是后续 `CSet` 选择的依据。 |
| **空 Region 识别与释放** | **识别并释放完全为空的 `Region`** | 如果某个 `Region` 中 **存活对象为 0**，则将其标记为“可回收”，并立即从老年代/年轻代中移除。 |
| **RSet 元数据清理**      | **清理 `RSet` 中无效条目**        | 释放那些指向已被回收 `Region` 的 `RSet` 条目，减少内存开销。 |

- 并发阶段（与应用线程并发执行）

| 阶段                  | 任务                           | 说明                                                         |
| --------------------- | ------------------------------ | ------------------------------------------------------------ |
| **Region 重置与归还** | **将空 `Region` 返回空闲列表** | 被释放的空 `Region` 会被 `G1` 并发地重置并加入到堆的空闲`Region` 列表中，供后续分配使用。 |
| **CSet 优先级排序**   | **准备 `CSet` 优先级列表**     | `G1` 会根据 `Region` 的“垃圾占比”（即存活率低）进行排序，构建一个 **回收价值优先级队列**，用于 `Mixed` `GC` 时选择 `CSet`。 |





### 3）阶段2：`Mixed` `GC` 回收（多次 `STW`）

| 轮次           | 说明                                          |
| -------------- | --------------------------------------------- |
| 第1次 Mixed GC | 回收一部分 CSet（年轻代 + 部分老年代 Region） |
| 第2次 Mixed GC | 继续回收下一批高价值 Region                   |
| ...            | ...                                           |
| 第N次 Mixed GC | 直到满足回收目标或达到 `G1MixedGCCountTarget` |

​		

#### a、构建收集集合（`CSet`）

根据全局并发标记的结果和停顿时间目标，选择部分老年代区域和整个年轻代区域作为 `CSet`。`CSet`（`Collection` `Set`）是本次 `GC` 要回收的 `Region` 集合。

- 包含：
  - 所有年轻代 `Region`（Eden + Survivor）
  - 部分老年代 `Region`（按回收价值排序）
  - 可回收的大对象 `Region`（Humongous）
- 选择策略：
  - 根据 `-XX:MaxGCPauseMillis`（默认 200ms）估算可回收的 Region 数量。
  - 优先选择 **垃圾占比高、回收成本低** 的 Region（即“Garbage-First”策略）。



**问题1：筛选器是如何回收的？**

答案：`G1` 根据并发标记的结果，对每个 `Region` 的**回收价值**（垃圾占比）和**回收成本**（预估时间）进行评估，按“性价比”排序。结合 `-XX:MaxGCPauseMillis` 设定的停顿目标，选择一批总耗时不超过该目标的 `Region` 构成 `CSet`，在下一次 **`STW` 阶段**统一回收。   

**问题2：筛选器是如何实现的？**

答案：`G1` 在后台维护一个按“回收效率”排序的优先级列表。每次 Mixed GC 前，优先选择那些**单位时间内能回收最多垃圾**的 Region。例如：一个 Region 用`50ms` 可回收 `20MB` 垃圾，优于另一个用 `200ms` 回收 10MB 的 Region。这种策略体现了 G1 “Garbage-First” 的设计思想。



#### b、**移动/拷贝存活对象 —— `STW`**

- 暂停应用线程（`STW`），执行对象复制。
- 任务：
  - 遍历 `CSet` 中的 `Region`。
  - 将存活对象复制到新的 `Region`：
    - 年轻代对象 → 新的 `Survivor` 或 老年代
    - 老年代对象 → 其他空闲老年代 `Region`
  - 原 `Region` 被清空，内存释放。



#### c、 内存整理（`Compaction`） —— `STW`

`G1` 不使用传统“标记-整理”，而是通过“**部分压缩（`Partial` `Compaction`）**”实现碎片整理。

- **注意**：`G1` 混合回收的算法并不是纯粹的复制算法或整理算法，而是结合了这两种算法的优点。在年轻代回收时，`G1` 更倾向于使用复制算法来减少 `GC` 停顿时间；而在老年代回收时，`G1` 则会使用标记-整理算法来整合内存碎片并释放更多的内存空间
- 机制：
  - 使用 **复制算法** 实现“类整理”效果。
  - 存活对象被集中复制到新 `Region`，原 `Region` 完全释放。
- 与算法的关系：
  - 年轻代：使用标准复制算法。
  - 老年代：通过部分 `Region` 的复制实现 **等效于标记-整理** 的效果。





### 4）问题

#### 1、`Mixed` `GC` 期间，谁在消耗 `CPU` ?

| 参数                      | 作用                                          | 是否并行 | 是否 STW         |
| ------------------------- | --------------------------------------------- | -------- | ---------------- |
| `-XX:ParallelGCThreads=8` | 控制 **并行 GC 线程数**（如复制、扫描、清理） | ✅ 是     | ✅ 是（暂停应用） |

在 `Mixed GC` 中，每个 `ParallelGCThreads` 会执行：

- **从老年代 `Region` 中复制存活对象** 到新的 `Region`
- **扫描 `Root`（GC Roots）**（如线程栈、全局变量）
- **更新引用（RSet 更新）**
- **清理旧 Region**





## 3、`Full` `GC` （全堆收集）

`Fu1l GC` 是 `G1` 最后的防护线，它本是 `G1` 设计时需要尽量避免的。在 `G1` 中，`Full` `GC` 通常不是由 `G1`直接触发的，而是在特定情况下（如`Mixed` `GC` 无法跟上内存分配速度）会回退到串行老年代收集器（ `Serial` `Old` `GC` ）进行全堆扫描。`Full` `GC`是一个耗时的过程，会停止所有应用线程，直到垃圾收集完成。



### 1）何时会退化为 Full GC？

| 原因                                        | 说明                                 |
| ------------------------------------------- | ------------------------------------ |
| **晋升失败（Promotion Failure）**           | 老年代无足够空间容纳晋升对象         |
| **疏散失败（Evacuation Failure）**          | CSet 中存活对象无法复制到目标 Region |
| **并发模式失败（Concurrent Mode Failure）** | 并发标记未完成，老年代已满           |

####  **a、晋升失败（Promotion Failure）**

- 年轻代对象要晋升到老年代
- 但老年代没有足够的连续 `Regio`n（`G1` 虽然不要求连续内存，但仍需完整 Region）
- 且无法通过 `Mixed GC` 快速腾出空间
- → 触发 **Full GC（单线程、Stop-The-World、压缩整个堆）**

#### b、**疏散失败（Evacuation Failure）**

- 在 Young GC 或 Mixed GC 中，要将存活对象从原 Region “疏散”（复制）到新 Region
- 但目标 Region（如 Survivor 或 Old）空间不足
- 导致对象只能留在原地，引发碎片问题
- 最终可能触发 Full GC

#### c、 **并发模式失败（Concurrent Mode Failure）**

- 并发标记还没完成，老年代就满了
- 应用线程无法等待，被迫进入 `Full GC`



### 2） 如何避免 `Full` `GC`？（调优建议）

| 问题              | 解决方案                                              |
| ----------------- | ----------------------------------------------------- |
| 晋升失败          | 增加堆大小 / 提前触发并发标记（降低 `IHOP`）          |
| `IHOP` 默认太高   | 若应用老年代增长快，可调低 `IHOP`（如设为 `35%`）     |
| `Mixed` `GC` 太慢 | 调整 `G1MixedGCCountTarget` 或增大 `MaxGCPauseMillis` |
| 对象太大太多      | 减少大对象分配，或增大 `G1HeapRegionSize`             |



### 3）要触发 `Full` `GC` 相关参数

**`G1`  主要通过以下几个参数和指标来决定是否需要触发 `Full` `GC`：**

| 参数                                | 默认值 | 说明                                                         | 举例                                                         |
| ----------------------------------- | ------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| `-XX:G1HeapWastePercent`            | `5%`   | 堆中可以容忍的最大垃圾比例。如果在 `Mixed` `GC` 之后，垃圾的比例超过了这个阈值，`G1` 可能会触发 `Full` `GC` 来回收更多的空间 | `-XX:G1HeapWastePercent=10` 意味着 `G1`将在预计回收超过堆的 `10%` 时启动混合垃圾收集。 |
| `-XX:G1MixedGCLiveThresholdPercent` | `85%`  | 当 `Old` 区中的对象占用的比例超过多少时，这部分区域会被包含在 `Mixed GC` 中，默认 `85`。如果这个比例设置得太低，可能会导致过多的`Old` 区域被包含在 `Mixed GC` 中，进而增加 `GC` 的工作量和停顿时间，最终可能引发 `Full GC` | `-XX:G1MixedGCLiveThresholdPercent=60` 表示如果混合垃圾收集后旧区中的存活对象比例低于 `60%`，`G1` 将尝试在下一次混合垃圾收集中回收更多区域。 |
| `-XX:G1MixedGCCountTarget`          | `8`    | 在开始进行 `Full` `GC` 之前，可以执行的 `Mixed` `GC`的最大次数。如果连续的 `Mixed GC `没有有效地回收内存，达到这个次数限制后，`G1` 可能会触发 `Full` `GC`。 | `-XX:G1MixedGCCountTarget=4`  表示 `G1` 将尝试在并发标记周期结束时，通过执行至多 `4` 次混合垃圾收集来清理足够的空间。 |
| `-XX:G1ReservePercent`              | `10%`  | 保留的堆内存的百分比，默认是 `10`，作为一个缓冲区来减少 `Full` `GC`的发生。如果可用内存低于这个阈值，`G1` 可能会触发 `Full` `GC`<br><br>阈值”并不是指保留区域的百分比本身，而是指堆内存的整体使用情况。具体来说，当堆内存的使用率达到某个临界点（这个临界点取决于多个因素，包括堆内存的大小、G1ReservePercent的设置、GC停顿时间目标等）时，G1垃圾收集器可能会决定触发Full GC来清理内存。然而，由于保留区域的存在，G1在触发Full GC之前通常会有更多的选择和灵活性来管理内存。 | `-XX:G1ReservePercent=10` 表示 `JVM` 堆中将保留 `10%` 的空间作为预留空间，用于在并发垃圾收集期间使用。 |





# 三、`G1` 和 `CSM` 差异

## 1、相同点

> **1、目标**：两者都旨在通过回收`JVM` 堆内存中的无用对象来优化内存使用，并减少内存泄漏的风险。    
>
> **2、`Full` `GC`**：在特定条件下，`G1` 和 `CMS` 都会触发 `Full` `GC`，即对整个堆（包括年轻代和老年代）进行垃圾收集。



## 2、区别

|                     | `G1`                                                         | `CMS`                                                        |
| ------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **适用场景**        | 适用于大内存、多 `CPU` 的服务端应用                          | 适用于对停顿时间要求较高的应用，如互联网网站或`B/S` 系统的服务端 |
| **垃圾收集算法**    | 基于区域的内存管理，将堆划分为多个 `Region`，采用标记-整理算法，局部（`Region`之间）可能采用复制算法 | 基于标记-清除算法，仅作用于老年代                            |
| **Full GC时的停顿** | 在进行`Full` `GC` 时需要暂停用户线程                         | 在 `Full` `GC` 时尽量不暂停用户线程，但初始标记和重新标记阶段会 `STW` |
| **内存碎片**        | 通过整理内存区域，减少了内存碎片                             | 由于采用标记-清除算法，可能会产生内存碎片                    |
| **内存压缩**        | 支持在垃圾收集时进行内存整理和压缩                           | 不支持内存压缩，特定条件下支持压缩，即`UseCMSCompactAtFullCollection`设置为true时），CMS是支持在Full GC过程中进行内存压缩整理的。通过合理设置`CMSFullGCsBeforeCompaction`参数，用户可以在减少内存碎片与降低停顿时间之间找到最佳的平衡点。 |
| **CPU资源需求**     | 需要更多的 `CPU` 资源来运行，以缩短 `STW` 时间               | 对 `CPU` 资源敏感，但总体需求相对较少                        |
| **默认性**          | 从 `JDK` `9`开始，`G1` 成为默认的垃圾回收器                  | 在早期 `JDK` 版本中，`CMS` 是可选的并发垃圾收集器，但不是默认选项 |



## 3、优缺点

### 1）`G1` - 优点

**1、高效并行与并发，适用于大内存、多核环境**

> `G1` 采用了并行和并发的方式进行垃圾收集，可以充分利用多核处理器的计算能力。在回收期间，多个`GC` 线程可以同时工作，提高了垃圾收集的效率。`G1` 的设计初衷就是针对拥有多核处理器和大内存的机器，通过并行和并发的方式提高垃圾收集的效率，同时减少停顿时间，满足服务端应用的需求。



**b、分代收集**

> `G1` 虽然依然区分年轻代和老年代，但不再坚持固定大小和固定数量的堆区域划分。它将堆空间分为若干个区域（Region），这些区域在逻辑上可以是年轻代或老年代的一部分，回收的粒度更细，范围更小，使得垃圾收集更加灵活。



**c、空间整合与减少内存碎片**

> `G1` 使用标记-整理算法，对内存进行压缩和整理，减少了内存碎片的产生。这种特性有利于程序长时间运行，尤其是在分配大对象时不会因为找不到连续的内存空间而提前触发 `GC`。



**d、可预测的停顿时间**

> `G1` 允许用户设定 `GC` 的停顿时间目标，通过跟踪各个 `Region` 的垃圾堆积价值，优先回收价值最大的 `Region`，从而在保证吞吐量的同时，尽量满足用户设定的停顿时间要求。







### 2）`G1` - 缺点

**a、`CPU` 资源消耗**

> `G1` 在垃圾收集过程中需要多个`GC` 线程同时工作，这会增加 `CPU` 的负载。尤其是在高负载情况下，可能会影响应用程序的性能。



**b、实现复杂度**

> `G1` 引入了新的数据结构和算法（如 `RSet`、`Card` `Table`等），使得实现相对复杂。这增加了维护的难度，也提高了出错的概率。



**c、在某些场景下吞吐量可能不如其他收集器**

> 虽然 `G1` 在大多数情况下都能提供较好的性能，但在某些特定场景下（如小内存应用），其吞吐量可能不如其他收集器（如 `CMS`， **`G1` 复杂的数据结构和算法会占用一定的性能；多线程并行执行由于小内存资源有限，多线程并行可能会引发线程资源竞争和上下文切换开销进而降低系统吞吐量** ）。



### 3）`CMS `- 优点

**a、低停顿时间**

> `CMS` 采用了并发标记和并发清除的方式，大部分垃圾收集工作都可以与应用程序并发执行，从而减少了用户线程的停顿时间。



**b、高吞吐量，与应用程序并发执行**

> 由于 `CMS` 在并发阶段不会暂停用户线程，因此可以保持较高的应用程序吞吐量，通过并发执行的方式实现这一目标。。



### 4）`CMS` -缺点

**a、内存碎片**

> `CMS` 采用标记-清除算法，可能会导致内存碎片的产生。当内存碎片过多时，可能需要提前触发 `Full` `GC` 来整理内存，从而影响性能。



**b、对 `CPU `资源敏感**

> `CMS` 在并发标记和并发清除阶段会占用一部分 `CPU` 资源，这可能会导致应用程序的吞吐量下降。



**c、无法处理浮动垃圾，可能产生"`Concurrent` `Mode` `Failure`"**

> 在并发清除阶段，用户线程还在运行，可能会产生新的垃圾对象（浮动垃圾）。这些垃圾对象需要在下一次 `GC` 时才能被清理，从而增加了`GC` 的负担。当老年代内存不足以存放新产生的浮动垃圾时， `CMS` 可能会触发" `Concurrent` `Mode` `Failure`"，导致另一次`Full` `GC` 的产生。这会增加停顿时间，并影响性能。



### 4、什么场景适合 `G1`

**1）`50%` 以上的堆被存活对象占用**

> 使用 `G1` ，就不用特意预留出很大的老年代空间，`G1` 会根据对象存活状态，动态分配每种不同代对象需要占用的空间。



**2）对象分配和晋升的速度变化非常大**

> 前提还是大内存机器才使用 `G1`，大内存的主机如果对象分配和晋升的速度变化非常快的话，`G1` 的这种内存设计可以很快的划分出对应所需的区域【区域占比动态增长，不像 `CMS` 等垃圾收集器要划分固定的空间来区分年轻代和老年代】，但因为 `G1` 算法比较复杂，在小内存机器里面性能不如 `CMS` 等主流垃圾收集器。



**3）垃圾回收时间特别长，超过1秒，停顿时间是 `500ms` 以内**

> `G1` 有一大好处就是可以设置我们每次想要回收的停顿时间【 **`-XX:MaxGCPauseMillis`**】，可以有效提升用户体验。



**4）8GB以上的堆内存(建议值)**

> `G1` 适合8G以上内存的机器使用【结构设计，`2048` 个 `Region` ，内存太小的话每个 `Region` 也很小，很容易就超过 `Region` 的一半被识别为超大对象，这样 `Humongous` 区东西会很多，反而不能很好的进行 `GC`收集】





# 五、其他

## 1、关键参数

| 参数                        | 说明                                                         |
| --------------------------- | ------------------------------------------------------------ |
| `XX:+UseG1GC`               | 启用 `G1`垃圾收集器                                          |
| `-XX:G1HeapRegionSize`      | 每个分区的大小，默认值是会根据整个堆区的大小计算出来，范围是 `1M` ~ `32M`，取值是 `2` 的幂，计算的倾向是尽量有 `2048` 个分区数。比如如果是 `2G` 的 `heap` ，那 `region` = `1M`。`16Gheap`, `region=8M`。 |
| `-XX:ConcGCThreads`         | 并发执行的线程数，默认值接近整个应用线程数的1/4。            |
| `-XX:G1MixedGCCountTarget:` | 一次全局并发标记之后，后续最多执行的 `MixedGC`次数。默认值是8. |









## 2、`GC` 完整日志

```
2025-09-18T02:45:51.042+0800: 90821.593: [GC pause (G1 Evacuation Pause) (young) (initial-mark), 0.0098560 secs]
   [Parallel Time: 7.1 ms, GC Workers: 8]
      [GC Worker Start (ms): Min: 90821593.9, Avg: 90821594.0, Max: 90821594.0, Diff: 0.1]
      [Ext Root Scanning (ms): Min: 3.7, Avg: 3.9, Max: 4.6, Diff: 0.9, Sum: 31.2]
      [Update RS (ms): Min: 1.7, Avg: 2.1, Max: 2.2, Diff: 0.5, Sum: 16.7]
         [Processed Buffers: Min: 12, Avg: 19.8, Max: 33, Diff: 21, Sum: 158]
      [Scan RS (ms): Min: 0.1, Avg: 0.3, Max: 0.3, Diff: 0.2, Sum: 2.2]
      [Code Root Scanning (ms): Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.1]
      [Object Copy (ms): Min: 0.2, Avg: 0.3, Max: 0.5, Diff: 0.3, Sum: 2.7]
      [Termination (ms): Min: 0.0, Avg: 0.1, Max: 0.1, Diff: 0.0, Sum: 0.5]
         [Termination Attempts: Min: 1, Avg: 1.0, Max: 1, Diff: 0, Sum: 8]
      [GC Worker Other (ms): Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.1]
      [GC Worker Total (ms): Min: 6.6, Avg: 6.7, Max: 6.7, Diff: 0.1, Sum: 53.4]
      [GC Worker End (ms): Min: 90821600.6, Avg: 90821600.6, Max: 90821600.7, Diff: 0.0]
   [Code Root Fixup: 0.0 ms]
   [Code Root Purge: 0.0 ms]
   [Clear CT: 0.5 ms]
   [Other: 2.2 ms]
      [Choose CSet: 0.0 ms]
      [Ref Proc: 0.3 ms]
      [Ref Enq: 0.0 ms]
      [Redirty Cards: 0.1 ms]
      [Humongous Register: 0.1 ms]
      [Humongous Reclaim: 0.0 ms]
      [Free CSet: 0.9 ms]
   [Eden: 5416.0M(5416.0M)->0.0B(5416.0M) Survivors: 4096.0K->4096.0K Heap: 11038.7M(12288.0M)->5622.7M(12288.0M)]
 [Times: user=0.06 sys=0.00, real=0.01 secs] 
2025-09-18T02:45:51.052+0800: 90821.603: [GC concurrent-root-region-scan-start]
2025-09-18T02:45:51.058+0800: 90821.609: [GC concurrent-root-region-scan-end, 0.0062772 secs]
2025-09-18T02:45:51.058+0800: 90821.609: [GC concurrent-mark-start]
2025-09-18T02:45:59.022+0800: 90829.574: [GC concurrent-mark-end, 7.9644062 secs]
2025-09-18T02:45:59.024+0800: 90829.575: [GC remark 2025-09-18T02:45:59.024+0800: 90829.575: [Finalize Marking, 0.0004404 secs] 2025-09-18T02:45:59.024+0800: 90829.576: [GC ref-proc, 0.0007889 secs] 2025-09-18T02:45:59.025+0800: 90829.576: [Unloading, 0.0390341 secs], 0.0496933 secs]
 [Times: user=0.34 sys=0.00, real=0.05 secs] 
2025-09-18T02:45:59.074+0800: 90829.626: [GC cleanup 6360M->6360M(12288M), 0.0111116 secs]
 [Times: user=0.08 sys=0.01, real=0.02 secs] 

```





### 1）**整体时间线概览**

- **时间范围**：2025-09-18 02:45:51.042 ~ 02:45:59.074（共约 8.03 秒）
- **GC 类型**：`G1` 收集器的一次 **混合收集周期（`Mixed` `GC` `Cycle`）的开始**，以 `initial-mark` 触发并发标记。
- **堆配置**：最大堆 `12288 MB`（约 12GB）



| 阶段               | 类型         | 耗时   | 是否 STW | 说明                          |
| ------------------ | ------------ | ------ | -------- | ----------------------------- |
| `Initial Mark`     | `Young GC`   | 9.86ms | ✅ 是     | 触发并发标记，回收了 5.4GB    |
| `Root Region Scan` | `Concurrent` | 6.3ms  | ❌ 否     | 快速完成                      |
| `Concurrent Mark`  | `Concurrent` | 7.96s  | ❌ 否     | 较长，注意 CPU 占用           |
| `Remark`           | `Final Mark` | 50ms   | ✅ 是     | 可接受，但 `Unloading` 占主导 |
| `Cleanup`          | `Cleanup`    | 11ms   | ✅ 是     | 正常                          |



### 2） 初始标记阶段（Initial Mark）

```
2025-09-18T02:45:51.042+0800: 90821.593: [GC pause (G1 Evacuation Pause) (young) (initial-mark), 0.0098560 secs]
...
[Eden: 5416.0M(5416.0M)->0.0B(5416.0M) Survivors: 4096.0K->4096.0K Heap: 11038.7M(12288.0M)->5622.7M(12288.0M)]
[Times: user=0.06 sys=0.00, real=0.01 secs]
```

这是一个 **`Young` 区域的 `Evacuation Pause`**，同时也承担了 **`Initial Marking Task`**（初始标记）。

- **停顿时长**：`0.009856s ≈ 9.86ms`，非常短，属于正常范围。
- **`GC` 类型**：虽然是 `young GC`，但带有 `(initial-mark)` 标记
  - 说明它触发了 `G1` 的并发标记周期（`Concurrent Marking Cycle`）
  - 通常由老年代占用率达到 `InitiatingHeapOccupancyPercent`（默认 45%）触发。
- **内存变化：**
  - `Eden`：`5416MB` → `0MB`（全部回收）
  - `Survivor`：`4096KB`（`4MB`）未变（说明没有晋升或复制）
  - 堆总量：`11038.7MB` → `5622.7MB`（减少了约 `5.4GB`）：说明本次 Young GC 回收了大量短期对象。



### 3）并发根区域扫描（`Concurrent Root Region Scan`）

```
2025-09-18T02:45:51.052+0800: 90821.603: [GC concurrent-root-region-scan-start]
2025-09-18T02:45:51.058+0800: 90821.609: [GC concurrent-root-region-scan-end, 0.0062772 secs]
```

- **耗时**：约 `6.3ms` 此阶段是并发执行的，不暂停应用线程。
- 扫描所有包含可能指向老年代对象的 **根区域（`Root` `Regions`）**，为并发标记做准备。时间很短，正常。



### 4）并发标记（`Concurrent Marking`）

```
2025-09-18T02:45:51.058+0800: 90821.609: [GC concurrent-mark-start]
2025-09-18T02:45:59.022+0800: 90829.574: [GC concurrent-mark-end, 7.9644062 secs]
```

- **持续时间**：约 **7.96 秒**并发执行，应用线程可继续运行。
- `JVM` 在后台遍历堆中所有可达对象，标记存活对象。
- 耗时较长，说明堆中存在大量需要遍历的对象，或 `CPU` 资源紧张。
- 若频繁发生长周期并发标记，可能意味着老年代增长较快或对象存活率高。

- **关注点**：`7.96` 秒属于较长的并发标记周期。如果系统对延迟敏感，应关注是否会影响后续的 `remark` 暂停或整体响应时间。



### 5）最终标记（`Remark`）—— `STW` 阶段

```
2025-09-18T02:45:59.024+0800: 90829.575: [GC remark 2025-09-18T02:45:59.024+0800: 90829.575: [Finalize Marking, 0.0004404 secs] 2025-09-18T02:45:59.024+0800: 90829.576: [GC ref-proc, 0.0007889 secs] 2025-09-18T02:45:59.025+0800: 90829.576: [Unloading, 0.0390341 secs], 0.0496933 secs]
 [Times: user=0.34 sys=0.00, real=0.05 secs] 
```

- **`STW`（`Stop-The-World`）暂停**
- **实际暂停时间**：`real=0.05s = 50ms`
- 包含子任务：
  - `Finalize Marking`: 0.44ms（完成标记）
  - `GC ref-proc`: 0.79ms（处理软/弱/虚引用）
  - `Unloading`: 39.03ms（卸载无用类，即类卸载 + 方法区回收）



### 6）清理阶段（Cleanup）—— 部分 `STW`

```
2025-09-18T02:45:59.074+0800: 90829.626: [GC cleanup 6360M->6360M(12288M), 0.0111116 secs]
[Times: user=0.08 sys=0.01, real=0.02 secs]
```

- **耗时**：约 `11ms`（`STW`）
- 内存前后都是 `6360M` → 表示没有释放空间？
  - 实际上，这里的 `6360M->6360M` 是指堆使用量未变，但 **G1 会识别哪些区域可回收，并为后续的 Mixed GC 做准备**。
- 主要任务：
  - 统计每个 `Region` 的存活对象数量
  - 标记完全空的 `Region`
  - 决定哪些老年代 `Region` 加入后续的 `Mixed GC` 集合（`CSet`）
- 虽然堆使用未降，但这是为后续真正回收做准备。









![ContactAuthor](https://raw.githubusercontent.com/HealerJean/HealerJean.github.io/master/assets/img/artical_bottom.jpg)



<!-- Gitalk 评论 start  -->

<link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">

<script src="https://unpkg.com/gitalk@latest/dist/gitalk.min.js"></script> 
<div id="gitalk-container"></div>    
 <script type="text/javascript">
    var gitalk = new Gitalk({
		clientID: `1d164cd85549874d0e3a`,
		clientSecret: `527c3d223d1e6608953e835b547061037d140355`,
		repo: `HealerJean.github.io`,
		owner: 'HealerJean',
		admin: ['HealerJean'],
		id: 'IQKZSpCBmtrX26iL',
    });
    gitalk.render('gitalk-container');
</script> 




<!-- Gitalk end -->



