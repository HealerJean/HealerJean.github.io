---
title: Jvm垃圾回收日志分析
date: 2018-10-11 03:33:00
tags: 
- JVM
category: 
- JVM
description: Jvm垃圾回收日志分析
---
<!-- image url 
https://raw.githubusercontent.com/HealerJean123/HealerJean123.github.io/master/blogImages
　　首行缩进
<font color="red">  </font>
-->

## 前言

新生代GC（Minor GC）：指发生在新生代的垃圾收集动作，因为Java对象大多都具备朝生夕灭的特性，所以Minor GC非常频繁，一般回收速度非常快。     



老年代GC（Major GC/Full GC）：指发生在老年代的GC，出现了Major GC，经常会伴随至少一次的Minor GC，Major GC的速度一般会比Minor GC慢10倍以上。

名称通过收集器而定

```java

1、这里的收集器是Parallel Scavenge。新生代为PSYoungGen，老年代为ParOldGen，Metaspace代表元空间（JDK 8中用来替代永久代PermGen）。<br/>  
 
2、如果收集器为ParNew收集器，新生代为ParNew，Parallel New Generation 
 
3、如果收集器是Serial收集器，新生代为DefNew，Default New Generation   


```




### 1、 数据准备和实例测试 



#### 1.1、JVM参数配置 



```
参数：-verbose:gc -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8
输出gc日志， 堆内存初始化大小20M，堆内存最大20M，新生代大小10M，那么剩余分配给老年代就是10M， 输出GC的详细日志，
```



#### 1.2、Java测试类 



```java
public class Jvm01ReferenceCountingGC {

    public Object instance = null;

    private static  final int _1MB= 1024 * 1024 ;

    /**
     占点内存，以便在日志中看清楚是否被回收
     */
    private byte[] bigSize = new byte[1 * _1MB];


    public static void main(String[] args) {
        Jvm01ReferenceCountingGC objA = new Jvm01ReferenceCountingGC();
        Jvm01ReferenceCountingGC objB = new Jvm01ReferenceCountingGC();

        objA.instance = objB;
        objB.instance = objA;

        //加入这个时候发生GC，如果是jvm采用的是引用计数法的话，objA和objB不能被回收，被回收了，说明不是采用的引用计数法
        // 因为他们互相引用这对方，导致他们的引用计数都不为0，
        // 于是引用计数算法，不能通知GC收集器回收他们
        System.gc(); //垃圾收集器回收内存
        }

}
```



#### 1.3、GC控制台日志 



```
[GC (System.gc()) [PSYoungGen: 4683K->1016K(9216K)] 4683K->3144K(19456K), 0.0018542 secs] [Times: user=0.01 sys=0.00, real=0.00 secs] 
[Full GC (System.gc()) [PSYoungGen: 1016K->0K(9216K)] [ParOldGen: 2128K->2968K(10240K)] 3144K->2968K(19456K), [Metaspace: 3238K->3238K(1056768K)], 0.0053601 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
Heap
 PSYoungGen      total 9216K, used 164K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000)
  eden space 8192K, 2% used [0x00000000ff600000,0x00000000ff6290e0,0x00000000ffe00000)
  from space 1024K, 0% used [0x00000000ffe00000,0x00000000ffe00000,0x00000000fff00000)
  to   space 1024K, 0% used [0x00000000fff00000,0x00000000fff00000,0x0000000100000000)
 ParOldGen       total 10240K, used 2968K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000)
  object space 10240K, 28% used [0x00000000fec00000,0x00000000feee6290,0x00000000ff600000)
 Metaspace       used 3262K, capacity 4496K, committed 4864K, reserved 1056768K
  class space    used 311K, capacity 388K, committed 512K, reserved 1048576K



```





#### 1.4、结果说明 



> 新生代GC（Minor GC）：指发生在新生代的垃圾收集动作，因为Java对象大多都具备朝生夕灭的特性，所以Minor GC非常频繁，一般回收速度非常快。
>
> 老年代GC（Major GC/Full GC）：指发生在老年代的GC，出现了Major GC，经常会伴随至少一次的Minor GC，Major GC的速度一般会比Minor GC慢10倍以上。

​    



##### 1.4.1、GC (System.gc()



![1576220763413](D:\study\HealerJean.github.io\blogImages\1576220763413.png)



```
[GC (System.gc()) [PSYoungGen: 4683K->1016K(9216K)] 4683K->3144K(19456K), 0.0018542 secs] [Times: user=0.01 sys=0.00, real=0.00 secs] 

 
年轻代可用大小为 9216K= 9*1024 (eden+survivor=9，另一个只是起零时存储的作用) 
```



+ 第一个：  `4683K->1016K(9216K)` 

  

  > **表示GC前该`新生代`已使用容量`4683K`->GC后该新生代已使用容量`1016K`（新生代的总容量`9216K`**
  >
  > 
  >
  > **解释：GC后该新生代已使用容量`1016K`（也就是Survivor中的存储的大小）**

  

+ 第二个：`4683K->3144K(19456K)`

  

  > **表示GC前`Java`堆已使用容量`6812K`->GC后Java堆已使用容量`4936`K（Java堆总容量`19456K`）**



##### 1.4.2、Full GC (System.gc() 



![1576220906092](D:\study\HealerJean.github.io\blogImages\1576220906092.png)





```
[Full GC (System.gc()) [PSYoungGen: 1016K->0K(9216K)] [ParOldGen: 2128K->2968K(10240K)] 3144K->2968K(19456K), [Metaspace: 3238K->3238K(1056768K)], 0.0053601 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 

```



+ 第一个 ：`PSYoungGen: 1016K->0K(9216K)`

  > **老年代GC前新生代已使用容量`1016K`--------->老年代GC后新生代已使用容量（新生代总容量）**
  >
  > 
  >
  > 解释：老年代GC前新生代已使用容量`1016K`（一般有可能是，survivor中存放的内存大小）



+ 第二个 ：`ParOldGen: 2128K->2968K(10240K)`

  > **表示老年代GC前老年代已使用的容量`2128K`->老年代GC后老年代已使用的容量`2968K`（老年代总容量）**

  

+ 第三个：`3144K->2968K(19456K)`

  > **表示老年代GC前Java堆已使用的容量`3144K`->老年代GC后老Java堆已使用的容量`2968K`（Java堆的容量）**

+ 第四个：`Metaspace: 3238K->3238K(1056768K)`

  > 解释：Metaspace代表元空间（JDK 8中用来替代永久代PermGen）。   
  >
  > 表示老年代GC前永久代已使用的容量`3238K`->老年代GC后永久代已使用的容量`2968K`（永久代的容量）



##### 1.4.3、heap ：表示的为Gc之后的内存分配情况



> 下面可以看到年轻代又有东西了，但是这和我们上面老年的GC后年轻代变成0，不冲突，因为系统里面的代码执行还要占用一点年轻待啊

```java
Heap
 PSYoungGen      total 9216K, used 164K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000)
  eden space 8192K, 2% used [0x00000000ff600000,0x00000000ff6290e0,0x00000000ffe00000)
  from space 1024K, 0% used [0x00000000ffe00000,0x00000000ffe00000,0x00000000fff00000)
  to   space 1024K, 0% used [0x00000000fff00000,0x00000000fff00000,0x0000000100000000)
 ParOldGen       total 10240K, used 2968K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000)
  object space 10240K, 28% used [0x00000000fec00000,0x00000000feee6290,0x00000000ff600000)
 Metaspace       used 3262K, capacity 4496K, committed 4864K, reserved 1056768K
  class space    used 311K, capacity 388K, committed 512K, reserved 1048576K
```





## 2、JVM参数说明 



```
"http_port=8391
server_port=8392
jvm_args='-Xmn256M -Xmx1024M -Xms1024M -XX:MaxPermSize=256M -XX:PermSize=256M -XX:SurvivorRatio=8 -XX:+UseConcMarkSweepGC -XX:CMSFullGCsBeforeCompaction=50 -XX:+UseCMSCompactAtFullCollection -XX:MaxTenuringThreshold=10 -verbose:gc -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -XX:+PrintGCDateStamps -XX:+PrintFlagsFinal -Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.port=8393 -Dcom.sun.management.jmxremote.ssl=false -Dcom.sun.management.jmxremote.authenticate=false -Xloggc:/usr/local/service/log/scf/scf-manager/gc.log -Xdebug -Xrunjdwp:transport=dt_socket,server=y,suspend=n,address=19137 -Dlog4j2.isThreadContextMapInheritable=true'"



-Xmn256M -Xmx1024M -Xms1024M 
-XX:MaxPermSize=256M -XX:PermSize=256M -XX:SurvivorRatio=8 
-XX:+UseConcMarkSweepGC 
-XX:CMSFullGCsBeforeCompaction=50 
-XX:+UseCMSCompactAtFullCollection 
-XX:MaxTenuringThreshold=10 
-verbose:gc 
-XX:+PrintGCDetails 
-XX:+PrintGCTimeStamps 
-XX:+PrintGCDateStamps 
-XX:+PrintFlagsFinal 
-Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.port=8393 
-Dcom.sun.management.jmxremote.ssl=false 
-Dcom.sun.management.jmxremote.authenticate=false 
-Xloggc:/usr/local/service/log/scf/scf-manager/gc.log 
-Xdebug -Xrunjdwp:transport=dt_socket,server=y,suspend=n,address=19137 
-Dlog4j2.isThreadContextMapInheritable=true
```







#### 

```
-XX:+PrintGCDetails


-XX:+PrintGC 与 -verbose:gc 是一样的，可以认为-verbose:gc 是 -XX:+PrintGC的别名，有一点必须注意：PrintGC必须开启，只开启PrintGCDetails、PrintGCTimeStamps不会输出GC，必须PrintGC同时开启
```

```
-XX:+PrintGC 输出GC日志
[GC (System.gc())  5949K->3136K(249344K), 0.0021481 secs]
[Full GC (System.gc())  3136K->2962K(249344K), 0.0050785 secs]


-XX:+PrintGCDetails 输出GC的详细日志
-XX:+PrintGCTimeStamps 输出GC的时间戳（以基准时间的形式）
-XX:+PrintGCDateStamps 输出GC的时间戳（以日期的形式，如 2013-05-04T21:53:59.234+0800）
-XX:+PrintHeapAtGC 在进行GC的前后打印出堆的信息
-Xloggc:../logs/gc.log 日志文件的输出路径
```

































   

如果满意，请打赏博主任意金额，感兴趣的请下方留言吧。可与博主自由讨论哦

|支付包 | 微信|微信公众号|
|:-------:|:-------:|:------:|
|![支付宝](https://raw.githubusercontent.com/HealerJean123/HealerJean123.github.io/master/assets/img/tctip/alpay.jpg) | ![微信](https://raw.githubusercontent.com/HealerJean123/HealerJean123.github.io/master/assets/img/tctip/weixin.jpg)|![微信公众号](https://raw.githubusercontent.com/HealerJean123/HealerJean123.github.io/master/assets/img/my/qrcode_for_gh_a23c07a2da9e_258.jpg)|




<!-- Gitalk 评论 start  -->

<link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk@latest/dist/gitalk.min.js"></script> 
<div id="gitalk-container"></div>    
 <script type="text/javascript">
    var gitalk = new Gitalk({
		clientID: `1d164cd85549874d0e3a`,
		clientSecret: `527c3d223d1e6608953e835b547061037d140355`,
		repo: `HealerJean123.github.io`,
		owner: 'HealerJean123',
		admin: ['HealerJean123'],
		id: 'JGr01MDyOu56VQWX',
    });
    gitalk.render('gitalk-container');
</script> 

<!-- Gitalk end -->

