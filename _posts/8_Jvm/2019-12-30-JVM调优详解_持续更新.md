---
title: JVM调优详解_持续更新
date: 2019-12-30 16:33:00
tags: 
- JVM
category: 
- JVM
description: JVM调优详解_持续更新
---

<!-- image url 
https://raw.githubusercontent.com/HealerJean123/HealerJean123.github.io/master/blogImages
　　首行缩进
<font color="red">  </font>
-->

## 前言  



## 1、类加载

### 1.1、类加载说明  



> **类加载的过程包括了加载、验证、准备、解析、初始化五个阶段。**



#### 1.1.1、类的生命周期：  

> 包括，加载、验证、准备、解析、初始化、使用、卸载7个阶段，其中**验证、准备、解析3个被称为连接**    



![WX20180411-180608@2x](https://raw.githubusercontent.com/HealerJean/HealerJean.github.io/master/blogImages/WX20180411-180608@2x.png)





#### 1.1.2、JVM中OOP-KLASS模型 来表示Java对象堆区生成  



> 元数据—— instanceKlass 对象会存在元空间（方法区）
>
> 对象实例—— instanceOopDesc 会存在Java堆。Java虚拟机栈中会存有这个对象实例的引用



##### 1.1.2.1、具体过程

1、Jvm在加载class时，如果这个类没有被加载过，JVM就会进行类的加载，并在JVM内部创建一个`instanceKlass`对象表示这个类的运行时元数据（**相当于Java层的Class对象**）包括常量池、字段、方法等，存放在方法区        

2、在new一个对象时，jvm创建`instanceOopDesc`，来表示这个对象，存放在堆区，引用，存放在栈区；它用来表示对象的实例信息，看起来像个指针实际上是藏在指针里的对象；`instanceOopDesc`对应java中的对象实例      

3、HotSpot并不把`instanceKlass`暴露给Java使用，而会另外创建对应的`instanceOopDesc`来表示java.lang.Class对象，并将后者称为前者的“Java镜像”，klass持有指向oop引用(_java_mirror便是该instanceKlass对Class对象的引用)       

4、要注意，new操作返回的`instanceOopDesc`类型指针指向`instanceKlass`，而`instanceKlass`指向了对应的类型的Class实例的`instanceOopDesc`；



![1578562322110](https://raw.githubusercontent.com/HealerJean123/HealerJean123.github.io/master/blogImages/1578562322110.png)



##### 1.1.2.2、堆中实例化对象的结构    

>   在`hotSpot`虚拟机中，**对象在内存中存储的布局可以分为3块区域：对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）**。下图是普通对象实例与数组对象实例的数据结构： 





![1578561760566](https://raw.githubusercontent.com/HealerJean123/HealerJean123.github.io/master/blogImages/1578561760566.png)

> 1、对象头：`HotSpo`t虚拟机的对象头包括两部分信息：
>
> > `mark`：主要存储对象运行时记录信息，如hashcode, GC分代年龄，锁状态标志，线程ID，时间戳等; 
> 
> >`klass`（元数据指针）：即对象指向它的类元数据（`instanceKlass`实例）的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例.
> 
> > 数组长度：（只有数组对象有，如果对象是一个数组, 那在对象头中还必须有一块数据用于记录数组长度.
>
> 2、实例数据：实例数据部分是对象真正存储的有效信息，也是在程序代码中所定义的各种类型的字段内容。无论是从父类继承下来的，还是在子类中定义的，都需要记录起来。    
>
> 3、对齐填充：第三部分对齐填充并不是必然存在的，也没有特别的含义，它仅仅起着占位符的作用。不做解释



### 1.2、类加载的过程

#### 1.2.1 、加载 

> **第一个阶段加载，虚拟机规范中并没有强制约束，这个交给虚拟机自由把控类加载时机以及加载方法**
>
> > 加载是类加载的第一个阶段，这个阶段，虚拟机完成3件事情，



##### 1.2.1.1、加载工作 

1、通过一个类的全限定名来获取定义此类的二进制字节流，JAVA开发团队说的很模糊啊，充满智力的开发人员在这个基础上，从jar获取，从war获取，从动态代理proxy中获取等等    

2、将这个字节流所代表的静态存储结构转化为方法区的运行时存储结构   

3、在堆中生成一个代表这个类的`java.lang.Class`对象，作为方法区这个类的各种数据的访问入口。

##### 1.2.1.2、 加载的三种方式

1、命令行启动应用时候由JVM初始化加载    

2、通过`Class.forName()`方法动态加载   

3、通过`ClassLoader.loadClass()`方法动态加载

#### 1.2.2、验证：确保class文件的字节流中包含的信息符合当前虚拟机的要求  

1、文件格式验证：字节流是否符合Class文件格式的规范。**只有通过了这个阶段的验证，字节流才会进入内存的方法区进行存储。所以后面的3个阶段全是基于方法区的数据结构进行，不直接操作字节流。**     

2、元数据验证：对字节码的描述的信息进行语义分析，保证其符合Java语言规范。     

3、字节码验证：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。保证被校验类的方法在运行时不会做出危害虚拟机安全的事件。    

4、符号引用验证：发生在虚拟机将符号引用转化为直接引用的时候，这个动作发生在连接的第三阶段——解析，符合引用验证可以看作是对类自身以外（常量池中的各种符号引用）的信息进行匹配性校验。

#### 1.2.3、准备：正式为类变量分配内存并设置类变量初始值的阶段

>    <font color="red">  准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在方法区中进行分配，需要注意的是仅包括static修饰的变量</font>      
>
> **不包括实例变量，实例变量会在对象实例化时随着对象一块分配在Java堆中。**



##### 1.2.3.1、静态变量 

```java
public static int value = 123  
```

> **那么变量在准备阶段过后的初始值为0，而不是123，因为这个时候还没有执行java方法，123的动作在初始化阶段才会执行。**



##### 1.2.3.2、final变量 

```java
public final static int value = 123  
```

> ​    <font color="red"> 被final修饰，则在准备阶段就会将123赋值给它</font>              





#### 1.2.4、解析

> 解析过程是将常量池内的符号引用替换成直接引用。针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行





**符号引用** （字符串，能根据这个字符串定位到指定的数据，比如java/lang/StringBuilder）

> 符号引用以一组符号来描述所引用的目标, 符号可以是任何形式的字面量, 只要使用时能够无歧义的定位到目标即可.       
>
> 例如, 在Java中, 一个Java类将会编译成一个class文件. **在编译时, Java类并不知道所引用的类的实际地址, 因此只能使用符号引用来代替**. 比如org.simple.People类引用了org.simple.Language类, 在**编译时People类并不知道Language类的实际内存地址, 因此只能使用符号org.simple.Language来表示Language类的地址.**



@：类和接口的全限定名

@：字段名称和描述符

@：方法名称和描述符



**直接引用**   （内存地址）

> 1、直接指向目标的指针.(个人理解为: 指向方法区中类对象, 类变量和类方法的指针)     
>
> 2、相对偏移量. (指向实例的变量, 方法的指针)      
>
> 3、一个间接定位到对象的句柄.



#### 1.2.5、初始化阶  

> 在准备阶段，类变量已经经过一次初始化了，在这个阶段，则是通过程序制定的计划去初始化类的变量和其他资源。这些资源有static{}块等。  **初始化阶段，才真正开始执行类中定义的Java程序代码**



##### 1.2.5.1、初始化条件 

1、创建类的实例，也就是new的方式

2、访问某个类或接口的静态变量、对该静态变量赋值、调用类的静态方法

3、反射（如Class.forName(“com.shengsiyuan.Test”)）

4、初始化某个类的子类，则其父类也会被初始化

5、 Java虚拟机启动时被标明为启动类的类（Java Test），直接使用java.exe命令来运行某个主类   



##### 1.2.5.2、初始化步揍  

 1、假如这个类还没有被加载和连接，则程序先加载并连接该类，加载过就不会重新加载了

 2、假如该类的直接父类还没有被初始化，则先初始化其直接父类

 3、假如类中有初始化语句，则系统依次执行这些初始化语句  



```
(1)加载父类（以下序号相同，表明初始化是按代码从上到下的顺序来的）
　　1.为父类的静态属性分配空间并赋于初值
　　2.执行父类静态初始化块;

(2)加载子类
　　3.为子类的静态属性分配空间并赋于初值
　　4.执行子类的静态的内容;

(3)加载父类构造器
　　5.初始化父类的非静态属性并赋于初值
　　6.执行父类的非静态代码块;
　　7.执行父类的构造方法;

(4)加载子类构造器
　　8.初始化子类的非静态属性并赋于初值
　　9.执行子类的非静态代码块;
　　10.执行子类的构造方法.
```



##### 1.2.5.3、结束声明周期 

1、执行了System.exit()方法      

2、程序正常执行结束       

3、程序在执行过程中遇到了异常或错误而异常终止       

4、由于操作系统出现错误而导致Java虚拟机进程终止



#### 1.2.6、测试 static



> 静态域的初始化和静态代码块的执行只在类加载的时候执行且只执行一次，**也就是说类加载过就不会重新加载了**



```java
1、父类
public class SuperClass {
    static{
        System.out.println("super class init!");
    }
    public static int a = 1;
    public final static int b = 1;
}

2、子类
public class SubClass extends SuperClass{
    static{
        System.out.println("SubClass init!");
    }
}
3、测试
public class Test {

    static{
        System.out.println("test class init!");
    }

    public static void main(String[] args){
        System.out.println(SubClass.a);
    }
}

控制台
test class init!
super class init!
1

解释：很明显没有输出子类SubClass中的static代码块的信息，对于静态字段，只有直接定义这个类的字段的类才会被加载。

当子类添加一个静态字段的时候

public class SubClass extends SuperClass{
    static{
        System.out.println("SubClass init!");
    }

    public static int s = 2; //对于静态字段，只有指定定义这个字段的类才会初始化
}

public class Test {

    static{
        System.out.println("test class init!");
    }

    public static void main(String[] args){
        System.out.println(SubClass.s);
    }
}

控制台
test class init!
super class init!
SubClass init!
2

解释:当初始化类的时候，如果他的父类还没有被初始化，则需要先初始化它的父类，和上面的其实也不冲突啦


当
public final static int s = 2; //变成final常亮的时则不会初始化任何，因为它放到了常亮池中，并不是在类中获取的，所以不需要初始化，控制台只会打印出2


```





### 1.3、类加载器

#### 1.3.1、什么是类加载机制

> 虚拟机将描述类的数据从Class文件加载到内存，并对数据进行校验，转换解析，准备到初始化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的类加载机制

#### 1.3.2、什么是类加载器classLoader及加载过程

官方：

> 虚拟机设计团队，把类加载阶段中的，通过一个类的全限名称来描述二进制字节流，这个动作放到Java虚拟机外部去实现，以便让应用程序自己决定如何去获取所需要的类，<font color="red">实现这个动作的代码模块成为类加载器</font>。

字面理解：

> Java程序（class文件）并不是本地的可执行程序。当运行Java程序时，首先运行JVM（Java虚拟机），然后再把Java class加载到JVM里头运行，负责加载Java class的这部分就叫做Class Loader。所以classLoader的目的在于把class文件装入到jvm中。

#### 1.3.4、不同的类加载器

> 从java虚拟机的角度看看，只存在两种不同的类加载器，一种是启动类加载器Bootstrap ClassLoader ,这个类加载器使用C++实现，是虚拟机自身的一部分     ,另一个种是由java语言实现，独立于虚拟机外部，并且全都继承自抽象类Java.lang.ClassLoader，Java语言系统自带有三个类加载器: 



**3个类加载器，执行顺序(先给结果)**， **具体看sun.misc.Launcher,它是一个java虚拟机的入口应用。**

```
1. Bootstrap CLassloder 
2. Extention ClassLoader 
3. Application  ClassLoader
4. 
```



##### 1）启动类加载器（Bootstrap ClassLoader）：最顶层的加载类

> 最顶层的加载类，主要加载核心类库，这个类加载器负责将存放在`%JAVA_HOME%\lib`目录中的，或者可以通过启动jvm时指定`-Xbootclasspath`和路径来改变`Bootstrap ClassLoader`的加载目录。比如`java -Xbootclasspath/a:path`被指定的文件追加到默认的bootstrap路径中，并且是虚拟机识别的（**仅按照文件名识别，如rt.jar，名字不符合的类库即使放在lib目录中也不会被加载**）类库加载到虚拟机内存中。启动类加载器无法被Java程序直接引用，因为他是虚拟机的一部分   



```java
@Test
public void bootClassPath(){
    System.out.println(System.getProperty("sun.boot.class.path"));

   //Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home/jre/lib/resources.jar:
//Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home/jre/lib/rt.jar:
//Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home/jre/lib/sunrsasign.jar:
// Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home/jre/lib/jsse.jar:
// /Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home/jre/lib/jce.jar:
//Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home/jre/lib/charsets.jar:
///Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home/jre/lib/jfr.jar:
// Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home/jre/classes
   
    //或者执行下面的代码
    URL[] urls = sun.misc.Launcher.getBootstrapClassPath().getURLs();
    for (int i = 0; i < urls.length; i++) {
        System.out.println(urls[i].toExternalForm());
    }
    
    
}
```

##### 2）扩展类加载器（Extension ClassLoader）：

> 这个加载器由`sun.misc.Launcher.ExtClassLoader`实现，它负责加载＜JAVA_HOME＞\lib\ext目录中的，或者被`java.ext.dirs`系统变量所指定的路径中的所有类库，开发者可以直接使用扩展类加载器。

```java
@Test
public void ExtClassLoaderClassPath(){
    System.out.println(System.getProperty("java.ext.dirs"));

    //  /Users/healerjean/Library/Java/Extensions:
    //  /Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home/jre/lib/ext:
    //  /Library/Java/Extensions:/Network/Library/Java/Extensions:/System/Library/Java/Extension:
    //  /usr/lib/java

}
```

##### 3）应用程序类加载器（Application ClassLoader）：

> 这个类加载器`sun.misc.Launcher.AppClassLoader`实现。由于这个类加载器是`ClassLoader`中的`getSystemClassLoader()`方法的返回值，所以一般也称它为系统类加载器。它负责加载用户类路径（Class Path）上所指定的类库，开发者可以直接使用这个类加载器      

​     <font color="red">如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</font>   



```
ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader();
ClassLoader systemClassLoader = sun.misc.Launcher.getLauncher().getClassLoader();
sun.misc.Launcher$AppClassLoader@18b4aac2
```



```java
System.out.println(System.getProperty("java.class.path"));
   
    
    
D:\programFiles\IntelliJ IDEA 2018.3.5\lib\idea_rt.jar;D:\programFiles\IntelliJ IDEA 2018.3.5\plugins\junit\lib\junit-rt.jar;D:\programFiles\IntelliJ IDEA 2018.3.5\plugins\junit\lib\junit5-rt.jar;D:\programFiles\java-1.8.0-openjdk\jre\lib\charsets.jar;D:\programFiles\java-1.8.0-openjdk\jre\lib\ext\access-bridge-64.jar;D:\programFiles\java-1.8.0-openjdk\jre\lib\ext\cldrdata.jar;D:\programFiles\java-1.8.0-openjdk\jre\lib\ext\dnsns.jar;D:\programFiles\java-1.8.0-openjdk\jre\lib\ext\jaccess.jar;D:\programFiles\java-1.8.0-openjdk\jre\lib\ext\localedata.jar;D:\programFiles\java-1.8.0-openjdk\jre\lib\ext\nashorn.jar;D:\programFiles\java-1.8.0-openjdk\jre\lib\ext\sunec.jar;D:\programFiles\java-1.8.0-openjdk\jre\lib\ext\sunjce_provider.jar;D:\programFiles\java-1.8.0-openjdk\jre\lib\ext\sunmscapi.jar;D:\programFiles\java-1.8.0-openjdk\jre\lib\ext\sunpkcs11.jar;D:\programFiles\java-1.8.0-openjdk\jre\lib\ext\zipfs.jar;D:\programFiles\java-1.8.0-openjdk\jre\lib\jce.jar;D:\programFiles\java-1.8.0-openjdk\jre\lib\jsse.jar;D:\programFiles\java-1.8.0-openjdk\jre\lib\management-agent.jar;D:\programFiles\java-1.8.0-openjdk\jre\lib\resources.jar;D:\programFiles\java-1.8.0-openjdk\jre\lib\rt.jar;D:\study\HealerJean.github.io\_posts\8_Jvm\hlj-jvm\com-hlj-admin\target\test-classes;D:\study\HealerJean.github.io\_posts\8_Jvm\hlj-jvm\com-hlj-admin\target\classes;D:\study\HealerJean.github.io\_posts\8_Jvm\hlj-jvm\com-hlj-dao\target\classes;C:\Users\HealerJean\.m2\repository\org\springframework\boot\spring-boot-starter-web\2.1.0.RELEASE\spring-boot-starter-web-2.1.0.RELEASE.jar;C:\Users\HealerJean\.m2\repository\org\springframework\boot\spring-boot-starter\2.1.0.RELEASE\spring-boot-starter-2.1.0.RELEASE.jar;C:\Users\HealerJean\.m2\repository\org\springframework\boot\spring-boot\2.1.0.RELEASE\spring-boot-2.1.0.RELEASE.jar;C:\Users\HealerJean\.m2\repository\org\springframework\boot\spring-boot-autoconfigure\2.1.0.RELEASE\spring-boot-autoconfigure-2.1.0.RELEASE.jar;C:\Users\HealerJean\.m2\repository\org\springframework\boot\spring-boot-starter-logging\2.1.0.RELEASE\spring-boot-starter-logging-2.1.0.RELEASE.jar;C:\Users\HealerJean\.m2\repository\org\apache\logging\log4j\log4j-to-slf4j\2.11.1\log4j-to-slf4j-2.11.1.jar;C:\Users\HealerJean\.m2\repository\org\apache\logging\log4j\log4j-api\2.11.1\log4j-api-2.11.1.jar;C:\Users\HealerJean\.m2\repository\org\slf4j\jul-to-slf4j\1.7.25\jul-to-slf4j-1.7.25.jar;C:\Users\HealerJean\.m2\repository\javax\annotation\javax.annotation-api\1.3.2\javax.annotation-api-1.3.2.jar;C:\Users\HealerJean\.m2\repository\org\yaml\snakeyaml\1.23\snakeyaml-1.23.jar;C:\Users\HealerJean\.m2\repository\org\springframework\boot\spring-boot-starter-json\2.1.0.RELEASE\spring-boot-starter-json-2.1.0.RELEASE.jar;C:\Users\HealerJean\.m2\repository\com\fasterxml\jackson\datatype\jackson-datatype-jdk8\2.9.7\jackson-datatype-jdk8-2.9.7.jar;C:\Users\HealerJean\.m2\repository\com\fasterxml\jackson\datatype\jackson-datatype-jsr310\2.9.7\jackson-datatype-jsr310-2.9.7.jar;C:\Users\HealerJean\.m2\repository\com\fasterxml\jackson\module\jackson-module-parameter-names\2.9.7\jackson-module-parameter-names-2.9.7.jar;C:\Users\HealerJean\.m2\repository\org\springframework\boot\spring-boot-starter-tomcat\2.1.0.RELEASE\spring-boot-starter-tomcat-2.1.0.RELEASE.jar;C:\Users\HealerJean\.m2\repository\org\apache\tomcat\embed\tomcat-embed-core\9.0.12\tomcat-embed-core-9.0.12.jar;C:\Users\HealerJean\.m2\repository\org\apache\tomcat\embed\tomcat-embed-el\9.0.12\tomcat-embed-el-9.0.12.jar;C:\Users\HealerJean\.m2\repository\org\apache\tomcat\embed\tomcat-embed-websocket\9.0.12\tomcat-embed-websocket-9.0.12.jar;C:\Users\HealerJean\.m2\repository\org\hibernate\validator\hibernate-validator\6.0.13.Final\hibernate-validator-6.0.13.Final.jar;C:\Users\HealerJean\.m2\repository\javax\validation\validation-api\2.0.1.Final\validation-api-2.0.1.Final.jar;C:\Users\HealerJean\.m2\repository\org\jboss\logging\jboss-logging\3.3.2.Final\jboss-logging-3.3.2.Final.jar;C:\Users\HealerJean\.m2\repository\org\springframework\spring-web\5.1.2.RELEASE\spring-web-5.1.2.RELEASE.jar;C:\Users\HealerJean\.m2\repository\org\springframework\spring-webmvc\5.1.2.RELEASE\spring-webmvc-5.1.2.RELEASE.jar;C:\Users\HealerJean\.m2\repository\org\springframework\boot\spring-boot-starter-test\2.1.0.RELEASE\spring-boot-starter-test-2.1.0.RELEASE.jar;C:\Users\HealerJean\.m2\repository\org\springframework\boot\spring-boot-test\2.1.0.RELEASE\spring-boot-test-2.1.0.RELEASE.jar;C:\Users\HealerJean\.m2\repository\org\springframework\boot\spring-boot-test-autoconfigure\2.1.0.RELEASE\spring-boot-test-autoconfigure-2.1.0.RELEASE.jar;C:\Users\HealerJean\.m2\repository\com\jayway\jsonpath\json-path\2.4.0\json-path-2.4.0.jar;C:\Users\HealerJean\.m2\repository\net\minidev\json-smart\2.3\json-smart-2.3.jar;C:\Users\HealerJean\.m2\repository\net\minidev\accessors-smart\1.2\accessors-smart-1.2.jar;C:\Users\HealerJean\.m2\repository\org\ow2\asm\asm\5.0.4\asm-5.0.4.jar;C:\Users\HealerJean\.m2\repository\org\assertj\assertj-core\3.11.1\assertj-core-3.11.1.jar;C:\Users\HealerJean\.m2\repository\org\mockito\mockito-core\2.23.0\mockito-core-2.23.0.jar;C:\Users\HealerJean\.m2\repository\net\bytebuddy\byte-buddy\1.9.3\byte-buddy-1.9.3.jar;C:\Users\HealerJean\.m2\repository\net\bytebuddy\byte-buddy-agent\1.9.3\byte-buddy-agent-1.9.3.jar;C:\Users\HealerJean\.m2\repository\org\objenesis\objenesis\2.6\objenesis-2.6.jar;C:\Users\HealerJean\.m2\repository\org\hamcrest\hamcrest-core\1.3\hamcrest-core-1.3.jar;C:\Users\HealerJean\.m2\repository\org\hamcrest\hamcrest-library\1.3\hamcrest-library-1.3.jar;C:\Users\HealerJean\.m2\repository\org\skyscreamer\jsonassert\1.5.0\jsonassert-1.5.0.jar;C:\Users\HealerJean\.m2\repository\com\vaadin\external\google\android-json\0.0.20131108.vaadin1\android-json-0.0.20131108.vaadin1.jar;C:\Users\HealerJean\.m2\repository\org\springframework\spring-core\5.1.2.RELEASE\spring-core-5.1.2.RELEASE.jar;C:\Users\HealerJean\.m2\repository\org\springframework\spring-jcl\5.1.2.RELEASE\spring-jcl-5.1.2.RELEASE.jar;C:\Users\HealerJean\.m2\repository\org\springframework\spring-test\5.1.2.RELEASE\spring-test-5.1.2.RELEASE.jar;C:\Users\HealerJean\.m2\repository\org\xmlunit\xmlunit-core\2.6.2\xmlunit-core-2.6.2.jar;C:\Users\HealerJean\.m2\repository\org\springframework\boot\spring-boot-starter-aop\2.1.0.RELEASE\spring-boot-starter-aop-2.1.0.RELEASE.jar;C:\Users\HealerJean\.m2\repository\org\springframework\spring-aop\5.1.2.RELEASE\spring-aop-5.1.2.RELEASE.jar;C:\Users\HealerJean\.m2\repository\org\aspectj\aspectjweaver\1.9.2\aspectjweaver-1.9.2.jar;C:\Users\HealerJean\.m2\repository\org\springframework\security\spring-security-core\4.2.3.RELEASE\spring-security-core-4.2.3.RELEASE.jar;C:\Users\HealerJean\.m2\repository\aopalliance\aopalliance\1.0\aopalliance-1.0.jar;C:\Users\HealerJean\.m2\repository\org\springframework\spring-beans\5.1.2.RELEASE\spring-beans-5.1.2.RELEASE.jar;C:\Users\HealerJean\.m2\repository\org\springframework\spring-context\5.1.2.RELEASE\spring-context-5.1.2.RELEASE.jar;C:\Users\HealerJean\.m2\repository\org\springframework\spring-expression\5.1.2.RELEASE\spring-expression-5.1.2.RELEASE.jar;C:\Users\HealerJean\.m2\repository\org\springframework\security\spring-security-web\4.2.3.RELEASE\spring-security-web-4.2.3.RELEASE.jar;C:\Users\HealerJean\.m2\repository\com\github\pukkaone\logback-gelf\1.1.9\logback-gelf-1.1.9.jar;C:\Users\HealerJean\.m2\repository\com\fasterxml\jackson\core\jackson-databind\2.9.7\jackson-databind-2.9.7.jar;C:\Users\HealerJean\.m2\repository\com\fasterxml\jackson\core\jackson-annotations\2.9.0\jackson-annotations-2.9.0.jar;C:\Users\HealerJean\.m2\repository\com\fasterxml\jackson\core\jackson-core\2.9.7\jackson-core-2.9.7.jar;C:\Users\HealerJean\.m2\repository\org\slf4j\slf4j-api\1.7.25\slf4j-api-1.7.25.jar;C:\Users\HealerJean\.m2\repository\com\rabbitmq\amqp-client\5.4.3\amqp-client-5.4.3.jar;C:\Users\HealerJean\.m2\repository\ch\qos\logback\logback-core\1.1.6\logback-core-1.1.6.jar;C:\Users\HealerJean\.m2\repository\ch\qos\logback\logback-classic\1.1.6\logback-classic-1.1.6.jar;C:\Users\HealerJean\.m2\repository\ch\qos\logback\logback-access\1.1.6\logback-access-1.1.6.jar;C:\Users\HealerJean\.m2\repository\org\apache\commons\commons-lang3\3.4\commons-lang3-3.4.jar;C:\Users\HealerJean\.m2\repository\net\sf\json-lib\json-lib\2.4\json-lib-2.4-jdk15.jar;C:\Users\HealerJean\.m2\repository\junit\junit\4.12\junit-4.12.jar;C:\Users\HealerJean\.m2\repository\org\projectlombok\lombok\1.18.2\lombok-1.18.2.jar;C:\Users\HealerJean\.m2\repository\io\springfox\springfox-swagger2\2.7.0\springfox-swagger2-2.7.0.jar;C:\Users\HealerJean\.m2\repository\io\swagger\swagger-annotations\1.5.13\swagger-annotations-1.5.13.jar;C:\Users\HealerJean\.m2\repository\io\swagger\swagger-models\1.5.13\swagger-models-1.5.13.jar;C:\Users\HealerJean\.m2\repository\io\springfox\springfox-spi\2.7.0\springfox-spi-2.7.0.jar;C:\Users\HealerJean\.m2\repository\io\springfox\springfox-core\2.7.0\springfox-core-2.7.0.jar;C:\Users\HealerJean\.m2\repository\io\springfox\springfox-schema\2.7.0\springfox-schema-2.7.0.jar;C:\Users\HealerJean\.m2\repository\io\springfox\springfox-swagger-common\2.7.0\springfox-swagger-common-2.7.0.jar;C:\Users\HealerJean\.m2\repository\io\springfox\springfox-spring-web\2.7.0\springfox-spring-web-2.7.0.jar;C:\Users\HealerJean\.m2\repository\org\reflections\reflections\0.9.11\reflections-0.9.11.jar;C:\Users\HealerJean\.m2\repository\org\javassist\javassist\3.21.0-GA\javassist-3.21.0-GA.jar;C:\Users\HealerJean\.m2\repository\com\google\guava\guava\18.0\guava-18.0.jar;C:\Users\HealerJean\.m2\repository\com\fasterxml\classmate\1.4.0\classmate-1.4.0.jar;C:\Users\HealerJean\.m2\repository\org\springframework\plugin\spring-plugin-core\1.2.0.RELEASE\spring-plugin-core-1.2.0.RELEASE.jar;C:\Users\HealerJean\.m2\repository\org\springframework\plugin\spring-plugin-metadata\1.2.0.RELEASE\spring-plugin-metadata-1.2.0.RELEASE.jar;C:\Users\HealerJean\.m2\repository\org\mapstruct\mapstruct\1.1.0.Final\mapstruct-1.1.0.Final.jar;C:\Users\HealerJean\.m2\repository\io\springfox\springfox-swagger-ui\2.7.0\springfox-swagger-ui-2.7.0.jar;D:\programFiles\IntelliJ IDEA 2018.3.5\lib\idea_rt.jar
    
    
```



#### 1.3.5、Launcher代码解释

> **Launcher 是java虚拟机的入口应用 ，代码有精简，具体自己看**

```
1. Launcher初始化了ExtClassLoader和AppClassLoader。 
2. 
2. Launcher中并没有看见BootstrapClassLoader，但通过System.getProperty("sun.boot.class.path")得到了字符串bootClassPath,这个应该就是BootstrapClassLoader加载的jar包路径。

```

```java
public class Launcher {
    private static Launcher launcher = new Launcher();
    private static String bootClassPath =
        System.getProperty("sun.boot.class.path");
 
    public static Launcher getLauncher() {
        return launcher;
    }
 
    private ClassLoader loader;
 
    public Launcher() {
        // Create the extension class loader
        ClassLoader extcl;
        try {
            extcl = ExtClassLoader.getExtClassLoader();
        } catch (IOException e) {
            throw new InternalError(
                "Could not create extension class loader", e);
        }
 
        // Now create the class loader to use to launch the application
        try {
            loader = AppClassLoader.getAppClassLoader(extcl);
        } catch (IOException e) {
            throw new InternalError(
                "Could not create application class loader", e);
        }
 
        //设置AppClassLoader为线程上下文类加载器，这个文章后面部分讲解
        Thread.currentThread().setContextClassLoader(loader);
    }
 
    /*
     * Returns the class loader used to launch the main application.
     */
    public ClassLoader getClassLoader() {
        return loader;
    }
    /*
     * The class loader used for loading installed extensions.
     */
    static class ExtClassLoader extends URLClassLoader {}
 
/**
     * The class loader used for loading from java.class.path.
     * runs in a restricted security context.
     */
    static class AppClassLoader extends URLClassLoader {}
```

#### 1.3.6、实例测试



```java
public class Jvm02Test {
}

```

##### 1.3.6.1、自己编写的是由AppClassLoader加载的。  

>  **解释：也就是说明Jvm02Test.class文件是由AppClassLoader加载的。**

```java
public class Jvm02ClassLoader {

    /**
     * 1、 也就是说明Jvm02Test.class文件是由AppClassLoader加载的。
     */
    @Test
    public  void testClassLoader (){

        ClassLoader classLoader = Jvm02Test.class.getClassLoader();

        System.out.println("ClassLoader is:" + classLoader.toString());
        // ClassLoader is:sun.misc.Launcher$AppClassLoader@18b4aac2
    }
    
}

```



##### 1.3.6.2、系统自带的int String是通过`Bootstrap ClassLoader`加载呢  

> **解释 ：**   提示的是空指针，意思是int.class这类基础类没有类加载器加载？      
>
> > 当然不是！ ,int.class是由Bootstrap ClassLoader加载的。要想弄明白这些，我们首先得知道一个前提。       
> >
> >    <font color="red">  每个类加载器都有一个父加载器,通过getParent方法</font>    





```java
    @Test
    public void intClassLoader(){

      ClassLoader  classLoader = int.class.getClassLoader() ;
      System.out.println("int is:" + classLoader.toString());
      //空指针异常
      //java.lang.NullPointerException

      ClassLoader stringClassLoader = String.class.getClassLoader() ;
      System.out.println(stringClassLoader.toString());
//     java.lang.NullPointerException
    }
```





##### 1.3.6.3、父加载器  

>  **解释 ：这个说明，AppClassLoader的父加载器是ExtClassLoader。那么ExtClassLoader的父加载器又是谁呢？**

```java

@Test
public void classLoaderParent(){

    ClassLoader classLoader = Jvm02Test.class.getClassLoader();
    System.out.println("ClassLoader is:" + classLoader.toString());
    //  AppClassLoader
    //打印信息：" ClassLoader is:sun.misc.Launcher$AppClassLoader@18b4aac2

    System.out.println("ClassLoader\'s parent is:"+classLoader.getParent().toString());
    //ExtClassLoader@
    //打印信息："   ClassLoader's parent is:sun.misc.Launcher$ExtClassLoader@531d72ca

}

```

****



##### 1.3.6.4、ExtClassLoader的父加载器  

> **解释：又是一个空指针异常，这表明ExtClassLoader也没有父加载器。那么，为什么标题又是每一个加载器都有一个父加载器呢？这不矛盾吗？为了解释这一点，我们还需要看下面的一个基础前提。**  

```java
@Test
public  void testGrandClassLoader (){

ClassLoader classLoader = Jvm02Test.class.getClassLoader();
	System.out.println("ClassLoader is:" + classLoader.toString());
    // ClassLoader is:sun.misc.Launcher$AppClassLoader@18b4aac2
  
    System.out.println("ClassLoader\'s parent is:"+classLoader.getParent().toString());
    //ClassLoader's parent is:sun.misc.Launcher$ExtClassLoader@3941a79c
    
    System.out.println("ClassLoader\'s grand father is:"+classLoader.getParent().getParent().toString());
    //跑出了异常，空指针
    //Exception in thread "main" java.lang.NullPointerException

}
    
```



##### 1.3.6.5、总结：父加载器不是父类  



> ​    <font color="red">但上面一小节代码中，为什么调用AppClassLoader的getParent()代码会得到ExtClassLoader的实例呢？先从URLClassLoader说起，这个类又是什么？ </font>          
>
>    `launch中`已经有了下面这两个内部类，可以看见`ExtClassLoader`和`AppClassLoader`同样继承自`URLClassLoade`     

```java
static class ExtClassLoader extends URLClassLoader {
……
}
static class AppClassLoader extends URLClassLoader {
……
}


```





![WX20190208-161242@2x](https://raw.githubusercontent.com/HealerJean/HealerJean.github.io/master/blogImages/WX20190208-161242@2x.png)





> `URLClassLoader`的源码中并没有找到`getParent()`方法。这个方法在`ClassLoader.java`中。  



```java
public class URLClassLoader extends SecureClassLoader implements Closeable {}


public class SecureClassLoader extends ClassLoader {}



public abstract class ClassLoader {
 
// The parent class loader for delegation
// Note: VM hardcoded the offset of this field, thus all new fields
// must be added *after* it.
private final ClassLoader parent;
// The class loader for the system
    // @GuardedBy("ClassLoader.class")
private static ClassLoader scl;
 
private ClassLoader(Void unused, ClassLoader parent) {
    this.parent = parent;
    ...
}
protected ClassLoader(ClassLoader parent) {
    this(checkCreateClassLoader(), parent);
}
protected ClassLoader() {
    this(checkCreateClassLoader(), getSystemClassLoader());
}
public final ClassLoader getParent() {
    if (parent == null)
        return null;
    return parent;
}
public static ClassLoader getSystemClassLoader() {
    initSystemClassLoader();
    if (scl == null) {
        return null;
    }
    return scl;
}
 
private static synchronized void initSystemClassLoader() {
    if (!sclSet) {
        if (scl != null)
            throw new IllegalStateException("recursive invocation");
        sun.misc.Launcher l = sun.misc.Launcher.getLauncher();
        if (l != null) {
            Throwable oops = null;
            //通过Launcher获取ClassLoader
            scl = l.getClassLoader();
            try {
                scl = AccessController.doPrivileged(
                    new SystemClassLoaderAction(scl));
            } catch (PrivilegedActionException pae) {
                oops = pae.getCause();
                if (oops instanceof InvocationTargetException) {
                    oops = oops.getCause();
                }
            }
            if (oops != null) {
                if (oops instanceof Error) {
                    throw (Error) oops;
                } else {
                    // wrap the exception
                    throw new Error(oops);
                }
            }
        }
        sclSet = true;
    }
}
}

```



> 我们可以看到getParent()实际上返回的就是一个ClassLoader对象parent，parent的赋值是在ClassLoader对象的构造方法中，它有两个情况： 

1、由外部类创建`ClassLoader`时直接指定一个`ClassLoader`为parent。     

2、由`getSystemClassLoader()`方法生成，也就是说在`sun.misc.Laucher`通过`getClassLoader()`获取，直白的说，一个`ClassLoader`创建时如果没有指定parent(**比如我们下面的自定义加载器)**，那么它的parent默认就是`AppClassLoade`r。



```java
public class Launcher {

    private ClassLoader loader;


    public Launcher() {
        Launcher.ExtClassLoader var1;
        try {
            var1 = Launcher.ExtClassLoader.getExtClassLoader();
        } catch (IOException var10) {
            throw new InternalError("Could not create extension class loader", var10);
        }

        try {
            this.loader = Launcher.AppClassLoader.getAppClassLoader(var1);
        } catch (IOException var9) {
            throw new InternalError("Could not create application class loader", var9);
        }
```



```java
Launcher.ExtClassLoader var1;
var1 = Launcher.ExtClassLoader.getExtClassLoader(); 
this.loader = Launcher.AppClassLoader.getAppClassLoader(var1); //生成自己的父加载器
```



`AppClassLoader`的parent是`ExtClassLoader`，`ExtClassLoader`的parent是null    

`ExtClassLoader`的父加载器为null,但是`Bootstrap CLassLoader`却可以当成它的父加载器这又是为何呢？

@：**`Bootstrap ClassLoader`是由C/C++编写的，它本身是虚拟机的一部分，所以它并不是一个JAVA类，也就是无法在java代码中获取它的引用，JVM启动时通过Bootstrap类加载器加载rt.jar等核心jar包中的class文件，之前的int.class,String.class都是由它加载。**      

@：**虚拟机启动先加载`Bootstrp loader` ，`lathcher`作为虚拟机启动的入口应用，JVM初始化`sun.misc.Launcher`，并在launcher中开始加载剩余两个，`Bootstrp loader`加载`ExtClassLoader`后，就会加载`AppClassLoader`,并且将`AppClassLoader`的父加载器指定为 `ExtClassLoader`。`AppClassLoader`也是用Java写成的，它的实现类是 `sun.misc.Launcher$AppClassLoader`，**      

@：  **Bootstrap没有父加载器，但是它却可以作用一个`ClassLoader`的父加载器。比如`ExtClassLoader`。`BootStrapClassLoader `是一个纯的C++实现，没有对应的Java类。所以在Java中是取不到的。如果一个类的`classloader`是null。已经足可以证明他就是由`BootStrapClassLoader `加载的**   

@：**另外我们知道`ClassLoader`中有个`getSystemClassLoader`方法,此方法返回的正是`AppclassLoader.AppClassLoader`主要负责加载`classpath`所指定的位置的类或者是jar文档，它也是Java程序默认的类加载器。** 





#### 1.3.7、双亲委托（终于来到这里）  



##### 1.3.7.1、双亲委托原理  

> 一个类加载器查找class和resource时，是通过“委托模式”进行的，它首先判断这个class是不是已经加载成功，如果没有的话它并不是自己进行查找，而是先通过父加载器，然后递归下去，直到Bootstrap `ClassLoader`，如果`Bootstrap classloader`找到了，直接返回，如果没有找到，则一级一级返回，最后到达自身去查找这些对象。这种机制就叫做双亲委托。    
>



![20170211135054825](https://raw.githubusercontent.com/HealerJean/HealerJean.github.io/master/blogImages/20170211135054825.png)

1、一个类加载器查找class和resource时，是通过“委托模式”进行的，如果该类加载器是`AppClassLoader`,该类加载器查找资源时  ，先看看缓存是否有，缓存有从缓存中获取，否则委托给父加载器。 （也可能是自定义加载器，它的父加载器是`AppClassLoader`）      

2、递归，重复第1部的操作。      

3、如果`ExtClassLoader`也没有加载过，则由`Bootstrap ClassLoader`出面，它首先查找缓存，如果没有找到的话，就去找自己的规定的路径下，也就是`sun.mic.boot.class`下面的路径。找到就返回，没有找到，让子加载器自己去找。    

4、`Bootstrap ClassLoader`如果没有查找成功，则`ExtClassLoade`r自己在`java.ext.dirs`路径中去查找，查找成功就返回，查找不成功，再向下让子加载器找。      

5、`ExtClassLoader`查找不成功，`AppClassLoader`就自己查找，在`java.class.path`路径下查找。找到就返回。如果没有找到则返回给委托的发起者（自定义类加载器），由它到指定的文件系统或网络等URL中加载该类。如果它们都没有加载到这个类时，抛出`ClassNotFoundException`异常。如果没有委托者，则同样抛出`ClassNotFoundException`异常

 

```java
protected Class<?> loadClass(String name, boolean resolve)
        throws ClassNotFoundException
    {
        synchronized (getClassLoadingLock(name)) {
            // 首先，检测是否已经加载
            Class<?> c = findLoadedClass(name);
            if (c == null) {
                long t0 = System.nanoTime();
                try {
                    if (parent != null) {
                        //父加载器不为空则调用父加载器的loadClass
                        c = parent.loadClass(name, false);
                    } else {
                        //父加载器为空则调用Bootstrap Classloader，前面说过ExtClassLoader的parent为null，所以它向上委托时，系统会为它指定Bootstrap ClassLoader。
                        c = findBootstrapClassOrNull(name);
                    }
                } catch (ClassNotFoundException e) {
                    // ClassNotFoundException thrown if class not found
                    // from the non-null parent class loader
                }
 
                if (c == null) {
                    // If still not found, then invoke findClass in order
                    // to find the class.
                    long t1 = System.nanoTime();
                    //父加载器没有找到，则调用findclass
                    c = findClass(name);
 
                    // this is the defining class loader; record the stats
                    sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);
                    sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);
                    sun.misc.PerfCounter.getFindClasses().increment();
                }
            }
            if (resolve) {
                //调用resolveClass()
                resolveClass(c);
            }
            return c;
        }
    }

```



##### 1.3.7.2、为什么要使用双亲委托这种模型呢  

因为这样可以避免重复加载，当父亲已经加载了该类的时候，就没有必要子`ClassLoader`再加载一次。



##### 1.3.7.3、 **但是JVM在搜索类的时候，又是如何判定两个class是相同的呢？**     

​    必须满足两个条件 ，只有两者同时满足的情况下，`JVM`才认为这两个class是相同的。就算两个class是同一份class字节码，如果被两个不同的`ClassLoader`实例所加载，`JVM`也会认为它们是两个不同class。    

**@：两个类名是否相同**         

**@：是否由同一个类加载器实例加载的。**





#### 1.3.8、自定义ClassLoader  

感谢博主 https://blog.csdn.net/andyzhaojianhui/article/details/72829386  

> 不知道大家有没有发现，不管是Bootstrap ClassLoader还是ExtClassLoader等，这些类加载器都只是加载指定的目录下的jar包或者资源。如果在某种情况下，我们需要动态加载一些东西呢？比如从D盘某个文件夹加载一个class文件，或者从网络上下载class主内容然后再进行加载，这样可以吗？

###### 1.3.8.1、自定义步骤

1、编写一个类继承自`ClassLoader`抽象类。    

2、重写它的`findClass()`方法。    

3、在`findClass()`方法中调用`defineClass()`



###### 1.3.8.2、编辑一个测试文件

> 将它编译之后的class文件，放到一个任意的目录下面

```java
package com.hlj.moudle.Jvm03类加载器;

public class Jvm02Test {

    public void say(){
        System.out.println("Say Hello");
    }
}


```

###### 1.3.8.3、自定义ClassLoader示例之DiskClassLoader。  



> 我们在findClass()方法中定义了查找class的方法，然后数据通过defineClass()生成了Class对象。



```java
package com.hlj.moudle.Jvm03类加载器;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;


/**
 * @Description
 * @Author HealerJean
 * @Date 2019/2/8  下午5:13.
 */
public class Jvm03DiskClassLoader extends ClassLoader{

        private String mLibPath;

        public Jvm03DiskClassLoader(String path) {
            // TODO Auto-generated constructor stub
            mLibPath = path;
        }

        @Override
        protected Class<?> findClass(String name) throws ClassNotFoundException {
            // TODO Auto-generated method stub

            String fileName = getFileName(name);

            File file = new File(mLibPath,fileName);

            try {
                FileInputStream is = new FileInputStream(file);

                ByteArrayOutputStream bos = new ByteArrayOutputStream();
                int len = 0;
                try {
                    while ((len = is.read()) != -1) {
                        bos.write(len);
                    }
                } catch (IOException e) {
                    e.printStackTrace();
                }

                byte[] data = bos.toByteArray();
                is.close();
                bos.close();

                return defineClass(name,data,0,data.length);

            } catch (IOException e) {
                // TODO Auto-
    
```

###### 1.3.8.4、测试

```java
package com.hlj.moudle.Jvm03类加载器;

import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;

/**
 * @Description
 * @Author HealerJean
 * @Date 2019/2/8  下午5:16.
 */
public class Jvm03ClassLoaderTest {

     public static void main(String[] args) throws Exception {

        //创建自定义classloader对象。
        Jvm03DiskClassLoader loader = new Jvm03DiskClassLoader("D:\\study\\HealerJean.github.io\\_posts\\8_Jvm\\hlj-jvm\\com-hlj-admin\\src\\main\\java");
        System.out.println(loader);
        //加载class文件
        Class c = loader.loadClass("com.hlj.moudle.Jvm03类加载器.Jvm02Test");
        System.out.println(loader.getParent());
        Object obj = c.newInstance();
        Method method = c.getDeclaredMethod("say", null);
        //通过反射调用Test类的say方法
        method.invoke(obj, null);

    }


}

```



#### 1.3.9、ClosserLoader卸载Class  

>  JVM中的Class只有满足三个条件，才能被GC回收，也就是该Class被卸载（unload）：看上面 



```java
    public static void main(String[] args) throws Exception {

        //创建自定义classloader对象。
        Jvm03DiskClassLoader loader = new Jvm03DiskClassLoader("D:\\study\\HealerJean.github.io\\_posts\\8_Jvm\\hlj-jvm\\com-hlj-admin\\src\\main\\java");
        System.out.println(loader);
        //加载class文件
        Class c = loader.loadClass("com.hlj.moudle.Jvm03类加载器.Jvm02Test");
        System.out.println(loader.getParent());
        Object obj = c.newInstance();
        Method method = c.getDeclaredMethod("say", null);
        //通过反射调用Test类的say方法
        method.invoke(obj, null);

        //清除该类的实例
        obj = null;
        //清除该类的ClassLoader引用
        loader = null;
        //清除该class对象的引用
        c = null;
        // 执行一次gc垃圾回收
        System.gc();
        System.out.println("GC over");
    }

}
```



#### 1.3.10、服务器启动共用一个AppClassLoader 

> 返回结果只有一个Classloader，所以一般类很难被卸载，因此才到了方法区 

```java
 @GetMapping("")
    @ResponseBody
    public ResponseBean get() {
        try {
            Set<ClassLoader> set = new HashSet<>();
            for (int i = 0; i < 10; i++) {
                new Thread(() -> {
                    ClassLoader classLoader = Jvm02Test.class.getClassLoader();
                    set.add(classLoader);
                }).start();
            }
            Thread.sleep(6000L);
            System.out.println("----------------------");
            System.out.println(set);
            return ResponseBean.buildSuccess(set);
        } catch (AppException e) {
            log.error(e.getMessage(), e);
            return ResponseBean.buildFailure(e.getCode(), e.getMessage());
        } catch (Exception e) {
            log.error(e.getMessage(), e);
            return ResponseBean.buildFailure(e.getMessage());
        }
    }
```



![1578644692110](D:\study\HealerJean.github.io\blogImages\1578644692110.png)



![1578644709948](D:\study\HealerJean.github.io\blogImages\1578644709948.png)







## 2、JVM内存分配  



### 2.1、理解  



#### 2.1.1、为什么要了解内存 

> **由于虚拟机自动内存管理机制的帮助下**，不需要为每一个new出来的对象，去写delete/free代码。不容易出现内存泄漏和内存溢出的问题， **<font color="red">但是如果一旦出现问题，那将是非常可怕的 </font>**，如果不了解虚拟机是怎么使用内存的，那么排查错误将会成为一项非常艰难的工资。  



#### 2.1.2、内存分配误区  

> 经常有人把java内存区分为堆内存和栈内存，这种分发是错误的，只能说明大多数程序员最密切的就是这两块，<font color="red">在多线程环境下，每个线程拥有一个栈和一个程序计数器。栈和程序计数器用来保存线程的执行历史和线程的执行状态，是线程私有的资源。其他的资源（比如堆、方法区）是由同一个进程内的多个线程共享。 </font>



### 2.2、内存分配  

#### 2.2.1、程序计数器（线程私有）

> 解释：较小的内存空间，可以当做当前线程所执行字节码的行号指示器，每个线程都有自己的行号指示器，互补干扰，因此这部分内存区域也叫作私有区域



#### 2.2.2、Java虚拟机栈（线程私有）  

> 解释：这里其实就是程序员通俗意义上的栈区，<font color="red">存放基本类型的变量和对象的引用（函数调用参数，函数返回值，函数返回地址存放在栈，局部变量）</font>      



   <font color="red">每次在方法执行的同时，都会创建一个栈帧，用来存储局部变量表，操作数栈（可以理解成数字），动态链接、方法出入口等信息。每一个方法执行的时候，就对应着一个栈帧在虚拟机栈中入栈和出栈的过程 </font>   



 **栈内存溢出**        

1、如果虚拟机请求栈深度大于虚拟机所允许的深度，将抛出 `StackOverflowError`异常      

2、如果虚拟机栈可以动态扩展（当前大部分虚拟机都可以）如果扩展时无法申请到足够的内存，将飘出`OutOfMemoryError`



#### 2.2.3、本地方法栈  （线程私有）



> 本地方法栈和虚拟机栈区别是，虚拟机栈为执行的java方法服务，而本地方法栈为Native方法服务。它也会抛出`StackOverflowError`和`OutOfMemoryError`异常



#### 2.2.4、Java堆（线程共享）



> 解释：Java堆是被所有线程共享的区域，在虚拟机启动时候创建，<font color="red">  此区域的唯一目标就是存放对象实例和数组，Java堆是垃圾收集器管理的主要区域 </font>



#### 2.2.5、方法区（非堆区）（线程共享）  



> 解释：虽然Java虚拟机将**方法区描述为作为堆区的一个逻辑部分**，但是它有一个别名叫非堆区域    
>
> **<font color="red">存储加载的类信息（类的信息包含类的版本、字段、方法、接口等描述信息。）、常量区、静态变量、JIT（即时编译器）处理后的数据等，   </font>**  
>
> 
>
> **需要注意是常量池就在方法区中，也是我们这次需要关注的地方**。  





#### 2.2.6、运行时常量池     

**Java中的常量池**，实际上分为两种形态：**静态常量池**和**运行时常量池。**   **<font color="red">我们常说的常量池，就是指方法区中的运行时常量池。  </font>**



  1）所谓**静态常量池**，即*.class文件中的常量池，class文件中的常量池不仅仅包含字符串(数字)字面量，还包含类、方法的信息，占用class文件绝大部分空间。     

   2）而**运行时常量池**，**运行时常量池是方法区的一部分**。Class文件中除了有类的版本、字段、方法、接口等描述信息外，<font color="red">还有一项信息是常量池，用于存放编译器生成的各种字面量和符号引用  </font>，这部分内容将在类加载后进入方法区的运行时常量池中存放。 **，将class文件中的常量池载入到内存中，并保存在方法区中**，



> 运行时常量池相对于Class文件常量池的另外一个重要特征是具备动态性，Java语言并不要求常量一定只有编译期才会产生，也就是并非预置入Class文件中常量池的内容才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中，这种特性被开发人员利用的比较多的便是String类的intern()方法。
>
> ​        既然运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出OutOfMemoryError异常。





##### 2.2.5.1、永久代和方法区的关系  



> **《Java虚拟机规范》只是规定了有方法区这么个概念和它的作用，并没有规定如何去实现它**。 那么，在不同的 JVM 上方法区的实现肯定是不同的了。 同时，大多数用的JVM都是Sun公司的HotSpot。在HotSpot上把GC分代收集扩展至方法区，或者说**使用永久代来实现方法区**。 
>
> 因此，我们得到了结论，**永久代是HotSpot的概念是一种实现，方法区是Java虚拟机规范中的定义，是一种规范，一个是标准一个是实现。其他的虚拟机实现并没有永久代这一说法。**    



##### 2.2.5.2、永久代大小参数配置    

> 永久代是一段连续的内存空间，我们在 JVM 启动之前可以通过设置`-XX:MaxPermSize`的值来控制永久代的大小，32 位机器默认的永久代的大小为 64M，64 位的机器则为 85M。     



##### 2.2.5.3、永久代垃圾回收  

> Java虚拟机规范中也说过不要求虚拟机在方法区实现垃圾收集，  永久代中的回收率则非常低。也就是说，回收方法区内的内存性价比很低，SUN公司就曾公布过关于方法区内存泄漏的严重BUG。也就是说



> **永久代的垃圾回收和老年代的垃圾回收是绑定的，一旦其中一个区域被占满，（永久代`-XX:PermSize`达到，这个值是动态变换的哦），会触发完全垃圾回收(Full GC)**。     
>
> 由于我们可以通过`‑XX:MaxPermSize`设置永久代的大小，有一个明显的问题，一旦**类的元数据**超过了设定的大小（废弃的常亮容易被回收），程序就会耗尽内存，并出现内存溢出错误 (`java.lang.OutOfMemoryError: PermGen space`)。     
>
> **这就是为什么正确的永久代大小对避免Full GC是非常重要的原因，一般情况下，我们为了防止内存空间变换，一般情况下我们会设置成一样的 ，所以这个时候就认为永久代没有垃圾回收 ，因为达到最大设定大小就会内存溢出** 





**回收内容**

> **废弃常亮和无用的类，当然回收是可以，而不是一定能够回收,而不是和对象一样，不使用了就必然会回收**   



**1、废弃的常亮**

> **常量的回收与堆中对象的回收机制类似，当某个常量没有被任何对象引用的时候，这个常量就没有用了，就可以被回收。举例，当前系统中找不到任何String对象引用了常量池中的的某个字符串常量：abcd，那么abcd这个常量就会被回收。同理，常量池中其他类、方法、字段的符号引用也与此类似。**       

> **注意**：　**JDK7开始字符串常量池在堆中分布，所以young gc过程会扫描该区域，因此如果字符串常量区非常庞大会导致young gc过程扫描的时间也会变长。但是，young gc阶段并不会对字符串常量区进行回收，具体回收阶段是在Full gc或者CMS gc阶段**  



**2、无用的类（必须满足下面三个条件才能被回收，一般很难保证）**

　　回收类的效率非常低，但在当前企业级应用大量使用反射、动态代理、CGLib等技术的前提下，类的回收也变得很重要**。已加载类的回收条件非常苛刻，需要满足以下三个条件，才有可能被JVM回收：**（可以参考上文类加载的卸载代码）

1. 该类所有的实例都已经被回收（不会再使用它的相关new 了），即Java堆中不存在该类的任何实例； 

2. 加载该类的`ClassLoader`已经被回收，**非常难保证**； 

3. 该类对应的`java.lang.Class`对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。

   

**如何回收**   

> **虚拟机可以对满足上述3个条件的无用类进行回收，这里说的仅仅是“可以”，而不是和对象一样，不使用了就必然会回收。  **



- **是否对类进行回收，HotSpot虚拟机提供了`-Xnoclassgc`参数进行控制**
- **使用`-verbose:class`及`-XX:+TraceClassLoading`、 `-XX:+TraceClassUnLoading`查看类的加载和卸载信息。**



**回收场景**

> **在大量使用反射、动态代理、`CGLib`等bytecode框架的场景，以及动态生成JSP和OSGi这类频繁自定义`ClassLoader`的场景都需要虚拟机具备类卸载的功能(对象设置为null，便于垃圾收集器回收)，以保证永久代不会溢出。**  





##### 2.2.5.4、版本迭代 



- **在`JDK1.7`之前包括`JDK1.7`，可以使用如下`-XX:PermSize: 方法区初始大小`  `-XX:MaxPermSize:方法区最大大小`来调节方法区的大小**，超过这个值将会抛出`OutOfMemoryError`异常:`java.lang.OutOfMemoryError: PermGen`

- **`JDK 1.7`后，字符串常量池被从方法区拿到了堆中，这里没有提到运行时常量池，也就是说字符串常量池被单独拿到堆，运行时常量池剩下的东西还在方法区，也就是hotspot中的永久代**   
- **`JDK1.8`之后，永久代（`PermGen`）被完全的移除了，所以永久代的参数`-XX:PermSize`和`-XX：MaxPermSize`也被移除了**，**<font color="red">存储的类的元数据、编译后的代码数据等已经移动到了元空间（MetaSpace）中，元空间并没有处于堆内存上，而是直接占用的本地内存（NativeMemory），静态变量和常量池等并入堆中</font>**



###### 2.2.5.4.1、为什么会从老年代变成元空间 



> JDK1.8， HotSpots取消了永久代，那么是不是也就没有方法区了呢？当然不是，方法区是一个规范，规范没变，它就一直在，只不过取代永久代的是元空间（Metaspace）而已。   
>
> 在原来的永久代划分中，永久代用来存放类的元数据信息、静态常量以及常量池等。   **<font color="red">现在类的元信息存储在元空间中，静态变量和常量池等并入堆中，相当于原来的永久代中的数据，被元空间和堆内存给瓜分了  </font>**



+ **永久代大小不容易确定，因为这其中有很多影响因素，比如类的总数，常量池的大小和方法数量等**，但是`PermSize`指定太小又很容易造成永久代内存溢出；**<font color="red"> 元空间的最大可分配空间就是系统可用内存空间，由于类的元数据分配在元空间中中</font>**。因此，我们就不会遇到永久代存在时的内存溢出错误，也不会出现泄漏的数据移到交换区这样的事情。最终用户可以为元空间设置一个可用空间最大值，**<font color="red"> 如果不进行设置，JVM会自动根据类的元数据大小动态增加元空间的容量。但是，永久代的移除并不代表自定义的类加载器泄露问题就解决了。</font>**   

+ 因为在` JDK7 `之前的 `HotSpot` 虚拟机中，**纳入字符串常量池的字符串被存储在永久代中，如果添加太多字符串常量到该区域，有些虚拟机不会做永久代的垃圾回收，而且如果参数设置不妥当，比如两个永久代参数设置一样，容易发生`OOM`），因此导致了一系列的性能问题和内存溢出错误**。    **<font color="red"> JDK1.8以后，运行时常亮、以及静态变量存在于堆中，可以被垃圾收集器进行回收了</font>**  

+ **`HotSpot`虚拟机的每种类型的垃圾回收器都需要特殊处理永久代中的元数据。永久代会为GC带来不必要的复杂度，并且回收效率偏低**

+ **原来**的jar包及你自己项目的class存放的内存空间，这部分空间是固定的，启动参数里面`-permSize`确定，，且**每个项目都会占用自己的`permGen`空间**。改成`metaSpaces`，**各个项目会共享同样的class内存空间**，比如两个项目都用了fast-json开源包，**在mentaSpaces里面只存一份class，提高内存利用率，且更利于垃圾回收**；  



###### 2.2.5.4.2、元空间参数配置以及垃圾回收



> 对于64位JVM来说，元空间的默认初始大小是20.75MB，默认的元空间的最大值是无限。  



**元空间垃圾回收**  

> **只要类加载器存活，其加载的类的元数据也是存活的，就不会被回收掉**，对于僵死的类及类加载器的垃圾回收将在元数据使用达到`MetaspaceSize`参数的设定值时进行，但是**不会单独回收某个类，会把相关的空间整个回收掉**。
>
> 
>
> 适时地监控和调整元空间对于减小垃圾回收频率和减少延时是很有必要的。**持续的元空间垃圾回收说明，可能存在类、类加载器导致的内存泄漏或是大小设置不合适。**



**1.`MetaspaceSize`**    

> 初始空间大小，但不是初始容量，可以看做是扩容时触发`FullGC`的初始化阈值，**达到该值就会触发垃圾收集进行类型卸载**，同时`GC`会对该值进行调整：**如果释放了大量的空间，就适当降低该值**；**如果释放了很少的空间，那么在不超过`MaxMetaspaceSize`时，适当提高该值。**  <font color="red"> 这样就会导致我们使用命令jstat 看到的MU MC的大小和这里的会有非常巨大的差异。一般情况下，这个值大小根据不同的平台在12M到20M浮动。使用java -XX:+PrintFlagsInitial命令查看本机的初始化参数，-XX:Metaspacesize为21810376B（大约20.8M）。</font>



- 无论 `-XX:MetaspaceSize` 配置什么值，Metaspace的初始容量一定是 `21807104` （约20.8m），如果没有配置`-XX:MetaspaceSize`，那么触发FGC的阈值是21807104（约20.8m）；如果配置了`-XX:MetaspaceSize`，那么触发FGC的阈值就是配置的值；

- `Metaspace`由于使用不断扩容到 `-XX:MetaspaceSize` 参数指定的量，就会发生`FGC`；且之后每次`Metaspace`扩容都会发生`FGC`；
- Metaspace容量范围为[20.8m, MaxMetaspaceSize)；

**2.`MaxMetaspaceSize`**    

> 限制Metaspace增长的上限，如果不设置的话会导致Metaspace无限的使用本地内存，影响到其他程序。在本机上该参数的默认值为17592186044415代表着无限大。 

```java
product(uintx, MaxNewSize, max_uintx,                                  \ 
        "Maximum new generation size (in bytes), max_uintx means set " \ 
        "ergonomically")  
    
在HotSpot VM里，intx是跟平台字长一样宽的带符号整型，uintx是其无符号版。max_uintx是(uintx) -1，也就是说在32位平台上是无符号的0xFFFFFFFF，64位平台上则是0xFFFFFFFFFFFFFFFF。

jmap -heap显示的部分参数是以MB为单位来显示的，而MaxNewSize的单位是byte。我跑例子的平台是64位的，于是算一下 0xFFFFFFFFFFFFFFFF / 1024 / 1024 = 17592186044415 MB 。   
参数的说明告诉我们，当MaxNewSize的值等于max_uintx时，意思就是交由ergonomics来自动选择的最大大小。并不是说最大大小真的有0xFFFFFFFFFFFFFFFF这么大。
```

  

**3.`MinMetaspaceFreeRatio`**    

> 当进行过Metaspace GC之后，会计算当前Metaspace的空闲空间比，如果空闲比小于这个参数（即实际非空闲占比过大，内存不够用），那么虚拟机将增长Metaspace的大小。默认值为40，也就是40%。设置该参数可以控制Metaspace的增长的速度，太小的值会导致Metaspace增长的缓慢，Metaspace的使用逐渐趋于饱和，可能会影响之后类的加载。而太大的值会导致Metaspace增长的过快，浪费内存。



**4.`MaxMetasaceFreeRatio`**

> 当进行过Metaspace GC之后， 会计算当前Metaspace的空闲空间比，如果空闲比大于这个参数，那么虚拟机会释放Metaspace的部分空间。默认值为70，也就是70%。





**建议**

1. `MetaspaceSize` 和 `MaxMetaspaceSize` 设置一样大；MaxMetaspaceSize如果设置太小，可能会导致频繁FullGC，甚至OOM。
2. 具体设置多大，建议稳定运行一段时间后通过 `jstat -gc pid` 确认且这个值大一些，对于大部分项目256m即可。



###### 2.2.5.4.3、元空间内存组成



###### 1、Metaspace 元空间内存 





![1578468221339](https://raw.githubusercontent.com/HealerJean123/HealerJean123.github.io/master/blogImages/1578468221339.png)





Metaspace由**一个或多个虚拟空间组成**，虚拟空间的分配单元是Chunk（快），其中Chunk使用列表进行维护    



**当使用一个classLoader加载一个类时，过程如下：**

1. 当前classLoader是否有对应的Chunk且有足够的空间。    

2. 查找空闲列表中的有没有空闲的Chunk。    

3. 如果没有，就从当前虚拟空间中分配一个新的Chunk，**这个时候会把对应的内存进行Commit，这个动作就是提交。但不是马上使用哦**
4.  **如果当前虚拟空间不足，则预留(reserves)一个新的虚拟空间。**



因为有GC的存在，有些Chunk的数据可能会被回收（Free Chunk），那么这些Chunk属于committe的一部分，但不属于capacity         

这些被分配的Chunk，第三个Chunk，基本很难被100%用完，存在碎片内存的情况，这些Chunk实际被使用的内存之和即used的大小；     

​        



> `used`,`capacity`,`committed`和`reserved`并不纯粹是JVM的概念，它和操作系统相关。
>
> > reserved：元数据的空间保留（但不一定提交）的量，操作系统预留的内存大小
>
> > committed： 空间块的数量。**指那些被commit的Chunk大小之和**
>
> > capacity： 当前分配块的元数据的空间。**是指那些被实际分配的Chunk大小之和；**
>
> > used：加载的类的空间量。
>
> 



###### 2、Class space 压缩类空间内存 



> ​    <font color="red">Java对象内存分配 ，堆上对象有指向Metaspace中自己类信息的指针`klass`    在64位平台上，为了压缩JVM对象中的类指针，引入了“压缩类指针空间”（对象中的_klass变为4字节，指向压缩类空间中的数据，该数据再指向Metaspace中的类信息</font>              



  ![1578476627967](https://raw.githubusercontent.com/HealerJean123/HealerJean123.github.io/master/blogImages/1578476627967.png)





> metaspace其实由两大部分组成  **(具体各自里面放什么，还真没看懂，希望以后有机会进行深入的学习吧)** 
>
> - **Klass Metaspace （也就是 Class space 压缩类空间 ）**
> - NoKlass Metaspace



` Klass Metaspace`就是用来存`klass`的，**`klass`是我们熟知的class文件在jvm里的运行时数据结构**， `Klass Metaspace`内存大小可通过`-XX:CompressedClassSpaceSize`参数来控制

>  **`-XX:CompressedClassSpaceSize`**
>
> 默认1G，这个参数主要是设置Klass Metaspace的大小，这块内存也可以没有，假如没有开启压缩指针就不会有这块内存，这种情况下klass都会存在NoKlass Metaspace里，而且假如-Xmx超过了32G，也是没有这块内存的，因为会这么大内存会关闭压缩指针开关。还有就是这块内存最多只会存在一块。         





`NoKlass Metaspace`专门来存`klass`相关的其他的内容，这块内存是由多块内存组合起来的，所以可以认为是不连续的内存块组成的。这块内存是必须的，虽然叫做`NoKlass Metaspace`，但是也其实可以存`klass`的内容，上面已经提到了对应场景。



  

**压缩指针（压缩类指针Klass，压缩对象指针OOP）**  ，默认是为了64位平台



1、使用`-XX:+UseCompressedOops` 来压缩对象指针     

@：oops是指普通对象指针       

@：Java堆中对象的对象指针被压缩到32bit      



2、使用`-XX:+UseCompressedClassPointers` 压缩类指针`Klass`，jdk1.8默认打开，这个内存大小可通过`-XX:CompressedClassSpaceSize`参数来控制，默认为1G。     

@：使用类指针压缩空间的基地址

@：对象的类指针（`_klass`）被压缩至32bit

![1578477090503](https://raw.githubusercontent.com/HealerJean123/HealerJean123.github.io/master/blogImages/1578477090503.png)





###### 测试  ：同时设置 PermSize 和 MaxPermSize的大小。     

![1578043745362](https://raw.githubusercontent.com/HealerJean123/HealerJean123.github.io/master/blogImages/1578043745362.png) 



![1578043727287](https://raw.githubusercontent.com/HealerJean123/HealerJean123.github.io/master/blogImages/1578043727287.png)  



![1578043757120](https://raw.githubusercontent.com/HealerJean123/HealerJean123.github.io/master/blogImages/1578043757120.png)



@：在`JDK1.6`环境下，抛出`OutOfMemoryError：PermGen space`,永久代空间不足。     

@：在`JDK1.7`和`JDK1.8`环境下，抛出`OutOfMemoryError：Java heap space`，堆空间不足。         

@：通过上面的报错信息也正好印证了咱们上面说的将常量池由永久代移动到了Java堆内存中。但是通过比对`JDK1.7`和`JDk1.8`的报错信息咱们也可以看到，相比于`JDK1.7`，上图中`JDK1.8`的报错信息中多出了一部分红色的警告信息。`Ignoring option PermSize/MaxPermSize= XXM;support was removerd in 8.0;`**意思就是，忽略这两个参数，这两个参数已经被删除了。**这是因为从`JDK1.8`之后，`永久代（PermGen`）被完全的移除了，所以永久代的参数`-XX:PermSize`和`-XX：MaxPermSize`也被移除了。



### 2.3、搞懂代码内存分配  

#### 2.3.1、堆和栈   

##### 2.3.1.1、栈：随着方法的结束和结束

> **由编译器自动分配释放**   ，**存放基本类型的变量和对象的引用（函数调用参数，函数返回值，函数返回地址存放在栈，局部变量）**
>
> 也就是说线程上下文的东西都在栈上，其他都在堆上（包括类的成员变量也在堆上）   ， 	当在一段代码块定义一个变量时，Java就在栈中为这个变量分配内存空间，当超过变量的作用域后，Java会自动释放掉为该变量所分配的内存空间，该内存空间可以立即被另作他用。   **也就是随着方法而生，随着方法而亡**  



**1、存放栈中的数据大小是固定的，生命周期也是固定的**

如`int a = `3;，这里的a是一个指向`int`类型的引用，指向`3`这个字面值。这些字面值的数据，由于大小可知，生存期可知(这些字面值固定定义在某个程序块里面，程序块退出后，字段值就消失了)，出于追求速度的原因，就存在于栈中。



**2、栈的数据共享**

```java
int a = 3; int b = 3；
```



@：编译器先处理int a = 3；首先它会在栈中创建一个变量为a的引用，然后查找有没有字面值为3的地址，没找到，就开辟一个存放3这个字面值的地址，然后将a指向3的地址。      

@：接着处理int b = 3；在创建完b的引用变量后，由于在栈中已经有3这个字面值，便将b直接指向3的地址。这样，就出现了a与b同时均指向3的情况。    



**3、字面值的引用不同于类对象的引用**

@：假定两个类对象的引用同时指向一个对象，如果一个对象引用变量修改了这个对象的内部状态，那么另一个对象引用变量也即刻反映出这个变化。        

@：通过字面值的引用来修改其值，不会导致另一个指向此字面值的引用的值也跟着改变的情况。     



如2上例，我们定义完a与 b的值后，再令a=4；那么，b不会等于4，还是等于3。在编译器内部，遇到a=4；时，它就会重新搜索栈中是否有4的字面值，如果没有，重新开辟地址存放4的值；如果已经有了，则直接将a指向这个地址。因此a值的改变不会影响到b的值。而对象就会随着改变



**4、栈优势：**

 栈的优势是，存取速度比堆要快，仅次于直接位于CPU中的寄存器。但缺点是，存在栈中的数据大小与生存期必须是确定的，缺乏灵活性。另外，**栈数据可以共享**





##### 2.3.1.2、堆  ：不会随着方法的结束而结束

> 一般**由程序员分配释放**，   若程序员不释放，程序结束时可能由OS回 收，**堆内存用来存放由new创建的对象和数组。在堆中分配的内存，（包括类的成员变量上）**    



##### 2.3.1.3、堆优势  

> 堆的优势是可以动态地分配内存大小，生存期也不必事先告诉编译器，Java的垃圾收集器会自动收走这些不再使用的数据。**但缺点是，由于要在运行时动态分配内存，存取速度较慢**。



#### 2.3.2、**java中的基本数据类型一定存储在栈中的吗**  

> 当然是错误的，   基本数据类型是放在栈中还是放在堆中，这取决于基本类型在何处声明，下面对数据类型在内存中的存储问题来解释一下：

##### 2.3.2.1、在方法中声明的变量，局部变量

> 即该变量是局部变量，每当程序调用方法时，系统都会为该方法建立一个方法栈，其所在方法中声明的变量就放在方法栈中，当方法结束系统会释放方法栈，其对应在该方法中声明的变量随着栈的销毁而结束，这就局部变量只能在方法中有效的原因



**！方法中声明的变量可以是基本类型的变量，也可以是引用类型的变量。**   

@：当声明是基本类型的变量的时，其变量名及值（变量名及值是两个概念）是放在JAVA虚拟机栈中   

@：当声明的是引用变量时，所声明的变量（该变量实际上是在方法中存储的是内存地址值）是放在JAVA虚拟机的栈中，该变量所指向的对象是放在堆类存中的。  



##### 2.3.2.2、 在类中声明的变量是成员变量，也叫全局变量

> ​    <font color = "red">放在堆中的，因为全局变量不会随着某个方法执行结束而销毁）。</font>      



**！同样在类中声明的变量即可是基本类型的变量 也可是引用类型的变量**

@：**当声明的是基本类型的变量其变量名及其值放在堆内存中的**

@：**引用类型时，其声明的变量仍然会存储一个内存地址值，该内存地址值指向所引用的对象。引用变量名和对应的对象仍然存储在相应的堆中**





##### 2.3.2.3、图文举例说明   



**图一**  

![1578551508710](https://raw.githubusercontent.com/HealerJean123/HealerJean123.github.io/master/blogImages/1578551508710.png)

```java
String str1 = “abc”;
String str2 = “abc”;
String str3 = “abc”;
String str4 = new String(“abc”);
String str5 = new String(“abc”);
```





**图二**  

![1578551935334](https://raw.githubusercontent.com/HealerJean123/HealerJean123.github.io/master/blogImages/1578551935334.png)

```java
public class Test{  
    public static void main(String args[]){  
        int date = 9;  
        Test test = new Test();        
        test.change(date);   
        BirthDate d1= new BirthDate(7,7,1970);         
    }    

    public void change1(int i){  
        i = 1234;  
    }   
}


class BirthDate {  
    private int day;  
    private int month;  
    private int year;      
    public BirthDate(int d, int m, int y) {  
        day = d;   
        month = m;   
        year = y;  
    }  
    省略get,set方法………  
}  




1. main方法开始执行：int date = 9; date局部变量，基础类型，引用和值都存在栈中。
2. Test test = new Test(); test为对象引用，存在栈中，对象(new Test())存在堆中。
3. test.change(date); i为局部变量，引用和值存在栈中。当方法change执行完成后，i就会从栈中消失。
4. BirthDate d1= new BirthDate(7,7,1970);  d1为对象引用，存在栈中，对象(new BirthDate())存在堆中，其中d，m，y为局部变量存储在栈中，且它们的类型为基础类型，因此它们的数据也存储在栈中。day,month,year为成员变量，它们存储在堆中(new BirthDate()里面)。当BirthDate构造方法执行完之后，d,m,y将从栈中消失。  


```



#### 2.3.3、final常亮存储在哪里    

> final修饰的成员变量!常量在类编译时期载入类的常量池中。 
>
> > 当 final 修饰的是一个引用类型数据时，也就是修饰一个对象时，引用在初始化后将永远指向一个内存地址，不可修改。但是该内存地址中保存的对象信息，是可以进行修改的。

@：final修饰的成员变量（实例变量）和静态变量（静态变量也只能是用static修饰的成员变量）在常量池中，//暂时认为final 对象也在常量池中       

@：**final修饰的局部变量，我们也可以称之为不可变变量。引用存储在栈中，对象存储在堆中**



#### 2.3.4、包装类 Integer



> Java的8种基本类型(Byte, Short, Integer, Long, Character, Boolean, Float, Double), 除Float和Double以外, 其它六种都实现了常量池, 但是它们只在大于等于-128并且小于等于127时才使用常量池。



```java
public void test3() {
    Integer i = 100;
    Integer j = 100;
    System.out.println(i == j); //true //常量池存储

    Integer i2 = 128;
    Integer j2 = 128;
    System.out.println(i2 == j2); //false 堆存储
}
```





### 2.4、异常判断    

![WX20190207-190335@2x](https://raw.githubusercontent.com/HealerJean/HealerJean.github.io/master/blogImages/WX20190207-190335@2x.png)



#### 2.4.1、java堆溢出：java.lang.OutOfMemoryError: Java heap space



##### 2.4.1.1、测试代码

```
 -Xms20m -Xmx20m
```



```java
package com.hlj.moudle.jvm001.service;

import java.util.ArrayList;
import java.util.List;

public class Jvm01HeadOOM {

    static class OOMObject{}

    public static void main(String[] args) {
        List<OOMObject> oomObjects = new ArrayList<>();

        while (true){
            oomObjects.add(new OOMObject());
        }
    }
}

```

过一段时间之后报下面错误

```java
Exception in thread "main" java.lang.OutOfMemoryError: Java heap space
	at java.util.Arrays.copyOf(Arrays.java:3210)
	at java.util.Arrays.copyOf(Arrays.java:3181)
	at java.util.ArrayList.grow(ArrayList.java:265)
	at java.util.ArrayList.ensureExplicitCapacity(ArrayList.java:239)
	at java.util.ArrayList.ensureCapacityInternal(ArrayList.java:231)
	at java.util.ArrayList.add(ArrayList.java:462)
	at com.hlj.jvm.memory.JavaHeap.main(JavaHeap.java:19)

Process finished with exit code 1
```



##### 2.4.1.2、异常分析和解决

可以看到上面的提示`Java heap space` java堆内存，如果出现上面的异常，从代码上看是否存在某些对象生命周期过长，持有状态时间过长的情况，尝试减少程序运行期的的内存消耗  





#### 2.4.2、虚拟机栈和本地方法栈溢出：java.lang.StackOverflowError

> -Xss：设置每个线程的栈大小。
>
> ​    
>
> JDK5.0以后每个线程栈大小为1M，以前每个线程栈大小为256K。更具应用的线程所需内存大小进行调整。在相同物理内存下，减小这个值能生成更多的线程。但是操作系统对一个进程内的线程数还是有限制的，不能无限生成，经验值在3000~5000左右。  


##### 2.4.2.1、测试代码

```java
 -Xss128k
```

```java
package com.hlj.moudle.jvm001.service;

public class Jvm02JavaVMStackSOF {
    private int stackLength = 1;//栈内存

    public void stackLeak() {
        stackLength++;
        stackLeak();
    }

    public static void main(String[] args) throws Throwable {
        Jvm02JavaVMStackSOF oom = new Jvm02JavaVMStackSOF();
        try {
            oom.stackLeak();
        } catch (Throwable e) {
            System.out.println("stack length：" + oom.stackLength);
            throw e;
        }
    }
}
```

##### 2.4.2.2、异常分析和解决

```java
stack length：1547
Exception in thread "main" java.lang.StackOverflowError
	at com.hlj.moudle.jvm001.service.JavaVMStackSOF.stackLeak(JavaVMStackSOF.java:15)
	at com.hlj.moudle.jvm001.service.JavaVMStackSOF.stackLeak(JavaVMStackSOF.java:15)
	at com.hlj.moudle.jvm001.service.JavaVMStackSOF.stackLeak(JavaVMStackSOF.java:15)
```



解释：           



​		操作系统分配给每个进程的内存是有限制的，虚拟机提供了参数来控制方法区（非堆区MaxPermSize）和Java堆(Xmx)区这两部分的最大值        

​		操作系统剩余的内存减去`Xmx（最大堆区容量）`和`MaxPermSize（最大方法区容量）`，，程序计数器内存消耗很小可以忽略掉，如果虚拟机进程本身消耗的内存不计算在内，剩下的就给了虚拟机栈和本地方法栈了。     

​		每个线程分配到的栈容量越大，可以建立的线程数就越少，建立线程时就越容易将资源耗尽。    

​		栈深度在大多数情况下达到1000到2000没有问题，对于正常的方法调用（包括递归），这个深度完全够用了，但是如果是建立多线程导致的内存溢出，在不能减少线程数，或者更换虚拟机的情况下，就只能通过减少最大堆（这样可以让栈区多一些）、减少线程分配的栈容量（如果当前线程占用的栈资源允许的情况下）



#### 2.4.3、方法区和运行时常亮溢出

```
-XX:PermSize=10M -XX:MaxPermSize=10M
```

```java
package com.hlj.moudle.jvm001.service;


import java.util.ArrayList;
import java.util.List;


public class Jvm03RuntimeConstantPoolOOM {

    public static void main(String[] args) {
        // 使用 List 保持着常量池引用，避免 Full GC 回收常量池行为
        List<String> list = new ArrayList<String>();
        // 10MB 的 PermSize 在 integer 范围内足够产生 OOM 了
        int i = 0;
        while (true) {
            list.add(String.valueOf(i++).intern());
        }
    }
}


```

​    



## 3、JVM日志介绍  



#### System.GC()  

>调用System.GC()方法也仅仅是一个请求（或建议）。JVM接收这个请求后，并不是立刻做垃圾回收，而只是对几个垃圾回收算法做了加权，使垃圾回收操作容易发生，或提早发生，或回收较多而已。    
>
>不要显示频繁调用System.GC()。虽然只是建议而已，但是很多情况下会触发GC回收，从而增加GC的回收频率，降低程序的运行性能；

### 3.1、案例分析  



> 新生代GC（Minor GC）：指发生在新生代的垃圾收集动作，因为Java对象大多都具备朝生夕灭的特性，所以Minor GC非常频繁，一般回收速度非常快。     



> 老年代GC（Major GC/Full GC）：指发生在老年代的GC，出现了Major GC，经常会伴随至少一次的Minor GC，Major GC的速度一般会比Minor GC慢10倍以上。



#### 3.1.1、垃圾收集器名称 （名称通过收集器而定）



> 1、收集器是Parallel Scavenge。新生代为PSYoungGen，老年代为ParOldGen，Metaspace代表元空间（JDK 8中用来替代永久代PermGen）。



> 2、收集器为ParNew收集器，新生代为ParNew，Parallel New Generation 



> 2、收集器是Serial收集器，新生代为DefNew，Default New Generation   





#### 3.1.2、JVM参数



```
-Xms20M -Xmx20M -Xmn10M  -XX:SurvivorRatio=8 -verbose:gc -XX:+PrintGCDetails
输出gc日志， 堆内存初始化大小20M，堆内存最大20M，新生代大小10M，那么剩余分配给老年代就是10M， 输出GC的详细日志，
```



#### 3.1.3、GC控制台日志 



```
[GC (System.gc()) [PSYoungGen: 4683K->1016K(9216K)] 4683K->3144K(19456K), 0.0018542 secs] [Times: user=0.01 sys=0.00, real=0.00 secs] 
[Full GC (System.gc()) [PSYoungGen: 1016K->0K(9216K)] [ParOldGen: 2128K->2968K(10240K)] 3144K->2968K(19456K), [Metaspace: 3238K->3238K(1056768K)], 0.0053601 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
Heap
 PSYoungGen      total 9216K, used 164K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000)
  eden space 8192K, 2% used [0x00000000ff600000,0x00000000ff6290e0,0x00000000ffe00000)
  from space 1024K, 0% used [0x00000000ffe00000,0x00000000ffe00000,0x00000000fff00000)
  to   space 1024K, 0% used [0x00000000fff00000,0x00000000fff00000,0x0000000100000000)
 ParOldGen       total 10240K, used 2968K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000)
  object space 10240K, 28% used [0x00000000fec00000,0x00000000feee6290,0x00000000ff600000)
 Metaspace       used 3262K, capacity 4496K, committed 4864K, reserved 1056768K
  class space    used 311K, capacity 388K, committed 512K, reserved 1048576K


```



#### 3.1.4、日志总结



> 新生代GC（Minor GC）：指发生在新生代的垃圾收集动作，因为Java对象大多都具备朝生夕灭的特性，所以Minor GC非常频繁，一般回收速度非常快。
>
> 老年代GC（Major GC/Full GC）：指发生在老年代的GC，出现了Major GC，经常会伴随至少一次的Minor GC，但不是一定，比如使用工具命令强制Full GC，Major GC的速度一般会比Minor GC慢10倍以上。

​    



##### 3.1.4.1、GC (System.gc()：年轻代GC



> user ： 此次垃圾回收, 垃圾收集线程消耗的所有CPU时间(Total CPU time).
> sys ： 操作系统调用(OS call) 以及等待系统事件的时间(waiting for system event)
> real： 等于 user 以及 system time 的总和。



![1576220763413](https://raw.githubusercontent.com/HealerJean123/HealerJean123.github.io/master/blogImages/1576220763413.png)





```
[GC (System.gc()) [PSYoungGen: 4683K->1016K(9216K)] 4683K->3144K(19456K), 0.0018542 secs] [Times: user=0.01 sys=0.00, real=0.00 secs] 

 
年轻代可用大小为 9216K= 9*1024 (eden+survivor=9，另一个只是起零时存储的作用) 
```



+ 第一个：  `4683K->1016K(9216K)` 

  

  > **表示GC前该`新生代`已使用容量`4683K`->GC后该新生代已使用容量`1016K`（新生代的总容量`9216K`**
  >
  > 
  >
  > **解释：GC后该新生代已使用容量`1016K`（也就是Survivor中的存储的大小）**

  

+ 第二个：`4683K->3144K(19456K)`

  

  > **表示GC前`Java`堆已使用容量`6812K`->GC后Java堆已使用容量`4936`K（Java堆总容量`19456K`）**



##### 3.1.4.2、Full GC (System.gc() ：老年代/永久代的stop the world的GC



![1576220906092](https://raw.githubusercontent.com/HealerJean123/HealerJean123.github.io/master/blogImages/1576220906092.png)





```
[Full GC (System.gc()) [PSYoungGen: 1016K->0K(9216K)] [ParOldGen: 2128K->2968K(10240K)] 3144K->2968K(19456K), [Metaspace: 3238K->3238K(1056768K)], 0.0053601 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 

```



+ 第一个 ：`PSYoungGen: 1016K->0K(9216K)`

  > **老年代GC前新生代已使用容量`1016K`--------->老年代GC后新生代已使用容量（新生代总容量）**
  >
  > 
  >
  > 解释：老年代GC前新生代已使用容量`1016K`（一般有可能是，survivor中存放的内存大小）



+ 第二个 ：`ParOldGen: 2128K->2968K(10240K)`  

  

  > **表示老年代GC前老年代已使用的容量`2128K`->老年代GC后老年代已使用的容量`2968K`（老年代总容量）**

  

+ 第三个：`3144K->2968K(19456K)`

  

  > **表示老年代GC前Java堆已使用的容量`3144K`->老年代GC后老Java堆已使用的容量`2968K`（Java堆的容量）**

  

+ 第四个：`Metaspace: 3238K->3238K(1056768K)`

  > 解释：Metaspace代表元空间（JDK 8中用来替代永久代PermGen）。   
  >
  > 表示老年代GC前永久代已使用的容量`3238K`->老年代GC后永久代已使用的容量`2968K`（永久代的容量）



###### 1、Full Gc 和CMS Gc

@：**Full GC == Major GC指的是对老年代/永久代的stop the world的GC**    

@：`Full GC`的次数 = 老年代GC时 `stop the world`的次数       

@：`Full GC`的时间 = 老年代GC时 `stop the world`的总时间       

@：`Full GC`本身不会先进行`Minor GC`，我们可以配置，让Full GC之前先进行一次Minor GC，因为老年代很多对象都会引用到新生代的对象，先进行一次Minor GC可以提高老年代GC的速度。**比如老年代使用CMS时，设置CMSScavengeBeforeRemark优化，让CMS remark之前先进行一次Minor GC。**       

@：`CMS` ，初始标记（Initial Mark) 、重新标记（Remark）两个阶段，会`STW`。所以这个**一次正常的`cms-gc`就会产生两次`fullgc`**。我们使用`jstat -gcutil pid`。就会看到`fullgc`进行了两次。





##### 3.1.4.3、heap ：表示的为Gc之后的内存分配情况



```java
Heap
 PSYoungGen      total 9216K, used 164K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000)
  eden space 8192K, 2% used [0x00000000ff600000,0x00000000ff6290e0,0x00000000ffe00000)
  from space 1024K, 0% used [0x00000000ffe00000,0x00000000ffe00000,0x00000000fff00000)
  to   space 1024K, 0% used [0x00000000fff00000,0x00000000fff00000,0x0000000100000000)
 ParOldGen       total 10240K, used 2968K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000)
  object space 10240K, 28% used [0x00000000fec00000,0x00000000feee6290,0x00000000ff600000)
 Metaspace       used 3262K, capacity 4496K, committed 4864K, reserved 1056768K
  class space    used 311K, capacity 388K, committed 512K, reserved 1048576K
```



###### 2、解释元空间日志  

```java
Metaspace       used 3262K, capacity 4496K, committed 4864K, reserved 1056768K
  class space    used 311K, capacity 388K, committed 512K, reserved 1048576K
```





> 可以看到整个metaspace使用了3262K，其中class space使用了311K，，整个metaspace的reserved大小为1056768K，其中class space的reserved大小为1048576K







## 4、内存分配以及回收策略 

### 4.1、对象优先在Eden分配  



> 复制算法还记得吧，就是说的商业虚拟机关于新生代的垃圾收集就是采用的复制算法 将内存分为3分分别为8：1：1 那么Eden 就代表着8份 ，两块Survivor区     
>
> 
>
> 刚刚新建的对象在Eden中，经历一次Minor GC，Eden中的存活对象就会被移动到第一块survivor space S0，Eden被清空；等Eden区再满了，就再触发一次Minor GC，Eden和S0中的存活对象又会被复制送入第二块survivor space S1（这个过程非常重要，因为这种复制算法保证了S1中来自S0和Eden两部分的存活对象占用连续的内存空间，避免了碎片化的发生）。S0和Eden被清空，然后下一轮S0与S1交换角色，   



#### 4.1.1、打印内存分配信息  

##### 4.1.1.1、实例代码  



```
-verbose:gc -XX:+PrintGCDetails
```

```java
private static final int _1MB = 1024 * 1024;
/**
* 1、打印内存分配信息
* -verbose:gc -XX:+PrintGCDetails 
*/
public static void main(String[] args) {
    byte[] b1 = new byte[4 * _1MB];
}
```



##### 4.1.1.2、GC日志   

```
Heap
 PSYoungGen      total 75776K, used 9298K [0x000000076b600000, 0x0000000770a80000, 0x00000007c0000000)
  eden space 65024K, 14% used [0x000000076b600000,0x000000076bf14a88,0x000000076f580000)
  from space 10752K, 0% used [0x0000000770000000,0x0000000770000000,0x0000000770a80000)
  to   space 10752K, 0% used [0x000000076f580000,0x000000076f580000,0x0000000770000000)
 ParOldGen       total 173568K, used 0K [0x00000006c2200000, 0x00000006ccb80000, 0x000000076b600000)
  object space 173568K, 0% used [0x00000006c2200000,0x00000006c2200000,0x00000006ccb80000)
 Metaspace       used 3211K, capacity 4496K, committed 4864K, reserved 1056768K
  class space    used 304K, capacity 388K, committed 512K, reserved 1048576K
```



**日志分析：**可以看到到内存全部分配到了eden中



#### 4.1.2、手动指定收集器(UseSerialGC)

##### 4.1.2.1、实例代码  



> **我们可以看在新生代采用的是Parallel Scavenge收集器，其实我们可以指定虚拟机参数来选择垃圾收集器。**  



```
-verbose:gc -XX:+PrintGCDetails -XX:+UseSerialGC
```

```java
private static final int _1MB = 1024 * 1024;
/**
* 1、打印内存分配信息
* -verbose:gc -XX:+PrintGCDetails 
*/
public static void main(String[] args) {
    byte[] b1 = new byte[4 * _1MB];
}
```



##### 4.1.2.2、GC日志    



```
Heap
 def new generation   total 78016K, used 9646K [0x00000006c2200000, 0x00000006c76a0000, 0x0000000716c00000)
  eden space 69376K,  13% used [0x00000006c2200000, 0x00000006c2b6ba80, 0x00000006c65c0000)
  from space 8640K,   0% used [0x00000006c65c0000, 0x00000006c65c0000, 0x00000006c6e30000)
  to   space 8640K,   0% used [0x00000006c6e30000, 0x00000006c6e30000, 0x00000006c76a0000)
 tenured generation   total 173440K, used 0K [0x0000000716c00000, 0x0000000721560000, 0x00000007c0000000)
   the space 173440K,   0% used [0x0000000716c00000, 0x0000000716c00000, 0x0000000716c00200, 0x0000000721560000)
 Metaspace       used 3352K, capacity 4496K, committed 4864K, reserved 1056768K
  class space    used 319K, capacity 388K, committed 512K, reserved 1048576K
```





#### 4.1.3、eden分配的验证



##### 4.1.3.1、实例代码  

```
-Xms20M -Xmx20M -Xmn10M -XX:SurvivorRatio=8
-verbose:gc -XX:+PrintGCDetails -XX:+UseSerialGC 


参数解释：
-Xms20M -Xmx20M：Java堆大小为20M  不可扩展（Xms表示初始Java堆大小 Xmx为Java堆最大 这里设置相等，就表明不可以扩展，一般建议如此设置） 
-Xmn10M ：表示分给新生代 （下面表示分给新生到10M，那么剩余的就分配给了老年代）
-XX:SurvivorRatio=8 ：表示新生代中Eden和Survivor 比为8：1 其实从下面的代码的输出结果也能够看到的
```



```java
private static final int _1MB = 1024 * 1024;

/**
* 1、对象优先在Eden分配
* -Xms20M -Xmx20M -Xmn10M -XX:SurvivorRatio=8 -verbose:gc -XX:+PrintGCDetails -XX:+UseSerialGC
* <p>
* 参数解释：
* -Xms20M -Xmx20M：Java堆大小为20M  不可扩展（Xms表示初始Java堆大小 Xmx为Java堆最大 这里设置相等，就表明不可以扩展，一般建议如此设置）
* -Xmn10M ：表示分给新生代 （下面表示分给新生到10M，那么剩余的就分配给了老年代）
* -XX:SurvivorRatio=8 ：表示新生代中Eden和Survivor 比为8：1 其实从下面的代码的输出结果也能够看到的， 所以实际上新生代大小是 eden + 一个survivor= 9M  eden=8M survivor两块分别1M
*/
 public static void main(String[] args) {

        byte[] b1 = new byte[2*1024*1024];
        byte[] b2 = new byte[2*1024*1024];
        byte[] b3 = new byte[2*1024*1024];
        byte[] b4 = new byte[4*1024*1024];
        //一定要加这个，强制老年代GC
        System.gc();
    }

```





##### 4.1.3.2、GC日志   



> 非常遗憾，下面的日志是复制的别人的，**我的结果和这个有稍许的出入**

```

[GC (Allocation Failure) [DefNew: 7129K->520K(9216K), 0.0053010 secs] 7129K->6664K(19456K), 0.0053739 secs] [Times: user=0.00 sys=0.00, real=0.01 secs]
[Full GC (System.gc()) [Tenured: 6144K->6144K(10240K), 0.0459449 secs] 10920K->10759K(19456K), [Metaspace: 2632K->2632K(1056768K)], 0.0496885 secs] [Times: user=0.00 sys=0.00, real=0.04 secs]
Heap
def new generation total 9216K, used 4779K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000)
eden space 8192K, 58% used [0x00000000fec00000, 0x00000000ff0aad38, 0x00000000ff400000)
from space 1024K, 0% used [0x00000000ff500000, 0x00000000ff500000, 0x00000000ff600000)
to space 1024K, 0% used [0x00000000ff400000, 0x00000000ff400000, 0x00000000ff500000)
tenured generation total 10240K, used 6144K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000)
the space 10240K, 60% used [0x00000000ff600000, 0x00000000ffc00030, 0x00000000ffc00200, 0x0000000100000000)
Metaspace used 2638K, capacity 4486K, committed 4864K, reserved 1056768K
class space used 281K, capacity 386K, committed 512K, reserved 1048576K

```



**[GC (Allocation Failure) [DefNew: 7129K->520K(9216K), 0.0053010 secs] 7129K->6664K(19456K), 0.0053739 secs] [Times: user=0.00 sys=0.00, real=0.01 secs]**    

> **新生代垃圾收集完成，将新生代的放到了老年代，**



**[Full GC (System.gc()) [Tenured: 6144K->6144K(10240K), 0.0459449 secs] 10920K->10759K(19456K), [Metaspace: 2632K->2632K(1056768K)], 0.0496885 secs] [Times: user=0.00 sys=0.00, real=0.04 secs]**

> **老年代6M不清理，保持不变**  



**Heap**
**def new generation total 9216K, used 4779K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000)**
**eden space 8192K, 58% used [0x00000000fec00000, 0x00000000ff0aad38, 0x00000000ff400000)**
**from space 1024K, 0% used [0x00000000ff500000, 0x00000000ff500000, 0x00000000ff600000)**
**to space 1024K, 0% used [0x00000000ff400000, 0x00000000ff400000, 0x00000000ff500000)**
**tenured generation total 10240K, used 6144K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000)**
**the space 10240K, 60% used [0x00000000ff600000, 0x00000000ffc00030, 0x00000000ffc00200, 0x0000000100000000)**
**Metaspace used 2638K, capacity 4486K, committed 4864K, reserved 1056768K**
**class space used 281K, capacity 386K, committed 512K, reserved 1048576K**



> 最终结果，6M最后进入了老年代，4M进入新生代eden区





###### 1、分析  

+ **在分配完,b1,b2,b3后如下所示。eden，已经分配了6M，还剩2M**    

![1577955148336](https://raw.githubusercontent.com/HealerJean123/HealerJean123.github.io/master/blogImages/1577955148336.png)



+ **这个时候分配b4（4M），发现eden剩余2M已经容纳不下b4了，这个时候发了两次GC，看日志应该很容易看到6M最后进入了老年代，4M进入新生代eden区**  

![1577955138172](https://raw.githubusercontent.com/HealerJean123/HealerJean123.github.io/master/blogImages/1577955138172.png)







### 4.2、大对象直接进入老年代 (-XX:PretenureSizeThreshold，默认是0)



> 所谓的大对象其实就是需要大量连续内存空间的JAVA对象，最典型的就是那种很长的字符串和数组，大对象对于虚拟机来说是一个坏消息，（更要命的是遇到短命大对象，所以写程序的时候要尽量避免） 经常出现大对象，容易导致内存还有很多空间，就提前触发垃圾收集来获取足够的空间
>
> **JAVA虚拟机提供 `XX:PretenureSizeThreshold`参数用来设置大于它的直接放到老年代分配，这样的目的是避免了Eden和两个Survivor区直接发送大量的内存复制**  
>
> #### -XX:PretenureSizeThreshold 默认是0，意思是不管多大都是先在eden中分配内存：





#### 4.2.1、设置6M为大对象  



```
-XX:+UseSerialGC -Xms20M -Xmx20M -Xmn10M -XX:SurvivorRatio=8 
-verbose:gc -XX:+PrintGCDetails 
-XX:PretenureSizeThreshold=6M
```



##### 4.2.1.1、5M不进入老年代  



```java
 public static void main(String[] args) {
        byte[] b1 = new byte[5 * _1MB];
    }
Heap
 def new generation   total 9216K, used 7919K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000)
  eden space 8192K,  96% used [0x00000000fec00000, 0x00000000ff3bbcd8, 0x00000000ff400000)
  from space 1024K,   0% used [0x00000000ff400000, 0x00000000ff400000, 0x00000000ff500000)
  to   space 1024K,   0% used [0x00000000ff500000, 0x00000000ff500000, 0x00000000ff600000)
 tenured generation   total 10240K, used 0K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000)
   the space 10240K,   0% used [0x00000000ff600000, 0x00000000ff600000, 0x00000000ff600200, 0x0000000100000000)
 Metaspace       used 3272K, capacity 4496K, committed 4864K, reserved 1056768K
  class space    used 311K, capacity 388K, committed 512K, reserved 1048576K
```



##### 4.2.1.2、7M进入老年代 




```java
public static void main(String[] args) {
    byte[] b1 = new byte[7 * _1MB];
}


Heap
 def new generation   total 9216K, used 2799K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000)
  eden space 8192K,  34% used [0x00000000fec00000, 0x00000000feebbcc8, 0x00000000ff400000)
  from space 1024K,   0% used [0x00000000ff400000, 0x00000000ff400000, 0x00000000ff500000)
  to   space 1024K,   0% used [0x00000000ff500000, 0x00000000ff500000, 0x00000000ff600000)
 tenured generation   total 10240K, used 7168K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000)
   the space 10240K,  70% used [0x00000000ff600000, 0x00000000ffd00010, 0x00000000ffd00200, 0x0000000100000000)
 Metaspace       used 3324K, capacity 4496K, committed 4864K, reserved 1056768K
  class space    used 317K, capacity 388K, committed 512K, reserved 1048576K
```





### 4.3、长期存活的对象将进入老年代  (-XX:MaxTenuringThreshold ，默认为15)



> 虚拟机采用的是分代收集算法，java虚拟机就能够知道哪些在新生代中，哪些在老年代中。其实他对每个对象的年龄都定义了一个计数器，当对象在Ede出生并经历过地第一次Minor GC后能够进入Survivor区，会将它的年龄设置为1.每度过一次Minor GC 它的年龄就会增加1.知道增加到一定程度，   
>
> 
>
> **设置垃圾最大年龄。如果设置为0的话，则年轻代对象不经过Survivor区，直接进入年老代。对于年老代比较多的应用，可以提高效率。如果将此值设置为一个较大值，则年轻代对象会在Survivor区进行多次复制，这样可以增加对象再年轻代的存活时间，增加在年轻代即被回收的概论。**  
>
> 
>
> ####  -XX:MaxTenuringThreshold ，默认为15





#### 4.3.1、年龄设置为1  

##### 4.3.1.1、实例代码 

```
-XX:+UseSerialGC -Xms20M -Xmx20M -Xmn10M -XX:SurvivorRatio=8  
-verbose:gc -XX:+PrintGCDetails  
-XX:MaxTenuringThreshold=1  -XX:+PrintTenuringDistribution
```



```java
private static final int _1MB = 1024 * 1024;
public static void main(String[] args) {
    // b1可以在 SurvivorRatio 存储
    byte[]  b1 = new byte[_1MB / 4];
    byte[]  b2 = new byte[4 * _1MB];
    byte[]  b3 = new byte[4 * _1MB];
    b3 = null;
    b3 = new byte[4 * _1MB];
}

```



##### 4.3.1.2、GC日志  



```java
[GC (Allocation Failure) [DefNew
Desired survivor size 524288 bytes, new threshold 1 (max 1)
- age   1:    1048576 bytes,    1048576 total
: 6987K->1024K(9216K), 0.0049055 secs] 6987K->5270K(19456K), 0.0050479 secs] [Times: user=0.01 sys=0.00, real=0.01 secs] 
[GC (Allocation Failure) [DefNew
Desired survivor size 524288 bytes, new threshold 1 (max 1)
- age   1:       3488 bytes,       3488 total
: 5201K->3K(9216K), 0.0099020 secs] 9448K->5273K(19456K), 0.0099305 secs] [Times: user=0.00 sys=0.00, real=0.01 secs] 
Heap
 def new generation   total 9216K, used 4317K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000)
  eden space 8192K,  52% used [0x00000000fec00000, 0x00000000ff0369b0, 0x00000000ff400000)
  from space 1024K,   0% used [0x00000000ff400000, 0x00000000ff400da0, 0x00000000ff500000)
  to   space 1024K,   0% used [0x00000000ff500000, 0x00000000ff500000, 0x00000000ff600000)
 tenured generation   total 10240K, used 5269K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000)
   the space 10240K,  51% used [0x00000000ff600000, 0x00000000ffb25788, 0x00000000ffb25800, 0x0000000100000000)
 Metaspace       used 3265K, capacity 4496K, committed 4864K, reserved 1056768K
  class space    used 311K, capacity 388K, committed 512K, reserved 1048576K
```



**第一次GC之后，survior中有一个年龄为1的1048576 bytes，并且它的大小超过了survivor期望 大小524288，下次GC就会被移动到老年代，**







### 4.4、动态对象年龄判断  



>  为了更好适应不同程序上的内存状态，虚拟机并不是永远要求达到`MaxTenuringThreshold`，如果在Survivor空间中相同年龄所有对象的大小总和大于Survivor的一半，年龄大于它的直接进入老年代。无需等待  



```java
/**
 * VM参数：-verbose:gc -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8 -XX:MaxTenuringThreshold=15
 * -XX:+PrintTenuringDistribution
 */
@SuppressWarnings("unused")
public static void testTenuringThreshold2() {
    byte[] allocation1, allocation2, allocation3, allocation4;
    allocation1 = new byte[_1MB / 4];   // allocation1+allocation2大于survivo空间一半
    allocation2 = new byte[_1MB / 4];
    allocation3 = new byte[4 * _1MB];
    allocation4 = new byte[4 * _1MB];
    allocation4 = null;
    allocation4 = new byte[4 * _1MB];
}

```



### 4.5、空间分配担保 

> 在发生`Minor GC`之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那么`Minor GC`可以确保是安全的。     



```
HandlePromotionFailure 不再使用
```



如果不成立，则虚拟机会查看`HandlePromotionFailure`设置值是否允许担保失败。如果允许，那么会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次`Minor GC`，尽管这次`Minor GC`是有风险的；如果小于，或者`HandlePromotionFailure`设置不允许冒险，那这时也要改为进行一次`Full GC`。    

如果出现了`HandlePromotionFailure`失败，那就只好在失败后重新发起一次`Full GC`。虽然担保失败时绕的圈子是最大的，但大部分情况下都还是会将`HandlePromotionFailure`开关打开，避免`Full GC`过于频繁，参见如下代码，请读者在`JDK 6 Update 24`之前的版本中运行测试。          



<font color="red" size = "4"> 在JDK 6 Update 24之后，这个测试结果会有差异，然源码中还定义了HandlePromotionFailure参数，但是在代码中已经不会再使用它。JDK 6 Update 24之后的规则变为只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小就会进行Minor GC，否则将进行Full GC。 </font>









## 5、JVM参数 



### 项目使用 

#### 1、XIAOMI 



```
"http_port=8391
server_port=8392
jvm_args='-Xmn256M -Xmx1024M -Xms1024M -XX:MaxPermSize=256M -XX:PermSize=256M -XX:SurvivorRatio=8 -XX:+UseConcMarkSweepGC -XX:CMSFullGCsBeforeCompaction=50 -XX:+UseCMSCompactAtFullCollection -XX:MaxTenuringThreshold=10 -verbose:gc -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -XX:+PrintGCDateStamps -XX:+PrintFlagsFinal -Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.port=8393 -Dcom.sun.management.jmxremote.ssl=false -Dcom.sun.management.jmxremote.authenticate=false -Xloggc:/usr/local/service/log/scf/scf-manager/gc.log -Xdebug -Xrunjdwp:transport=dt_socket,server=y,suspend=n,address=19137 -Dlog4j2.isThreadContextMapInheritable=true'"



-Xmn256M -Xmx1024M -Xms1024M 
-XX:MaxPermSize=256M -XX:PermSize=256M -XX:SurvivorRatio=8 
-XX:+UseConcMarkSweepGC 
-XX:CMSFullGCsBeforeCompaction=50 
-XX:+UseCMSCompactAtFullCollection 
-XX:MaxTenuringThreshold=10 
-verbose:gc 
-XX:+PrintGCDetails 
-XX:+PrintGCTimeStamps 
-XX:+PrintGCDateStamps 
-XX:+PrintFlagsFinal 
-Dcom.sun.management.jmxremote 
-Dcom.sun.management.jmxremote.port=8393 
-Dcom.sun.management.jmxremote.ssl=false 
-Dcom.sun.management.jmxremote.authenticate=false 
-Xloggc:/usr/local/service/log/scf/scf-manager/gc.log 
-Xdebug -Xrunjdwp:transport=dt_socket,server=y,suspend=n,address=19137 
-Dlog4j2.isThreadContextMapInheritable=true
```





### 5.1、GC日志查看 



```
-XX:+PrintGC 输出GC日志
-XX:+PrintGCDetails 输出GC的详细日志
-XX:+PrintGCTimeStamps 输出GC的时间戳（以基准时间的形式）
-XX:+PrintGCDateStamps 输出GC的时间戳（以日期的形式，如 2013-05-04T21:53:59.234+0800）
-XX:+PrintHeapAtGC 在进行GC的前后打印出堆的信息
-XX:+PrintFlagsFinal 
-Xloggc:../logs/gc.log 日志文件的输出路径
```





#### 5.1.1、输出GC日志：-XX:+PrintGC 和 -verbose:gc 

> -XX:+PrintGC 与 -verbose:gc 是一样的，可以认为-verbose:gc 是 -XX:+PrintGC的别名   
>
> 注意：PrintGC必须开启，只开启PrintGCDetails、PrintGCTimeStamps不会输出GC，必须PrintGC同时开启，一般情况下，配置了其他的，-XX:+PrintGC会被自动打开

```
-Xms20M -Xmx20M -Xmn10M -XX:SurvivorRatio=8 
-verbose:gc

[GC (System.gc())  2635K->1065K(19456K), 0.0017115 secs]
[Full GC (System.gc())  1065K->917K(19456K), 0.0047886 secs]
```

```
-Xms20M -Xmx20M -Xmn10M -XX:SurvivorRatio=8 
-XX:+PrintG

[GC (System.gc())  2635K->1040K(19456K), 0.0013182 secs]
[Full GC (System.gc())  1040K->917K(19456K), 0.0053261 secs]
```



| 参数        | 默认值        | 用法                                                         |
| ----------- | ------------- | ------------------------------------------------------------ |
| `-verbose:` | 无            | 在输出设备上显示虚拟机运行信息                               |
|             | verbose:class | 在程序运行的时候有多少类被加载！可以用verbose:class来监视    |
|             | verbose:gc    | 在虚拟机发生内存回收时在输出设备显示信息，格式如下： [Full GC 256K->160K(124096K), 0.0042708 secs] 该参数用来监视虚拟机内存回收的情况。 |
|             | verbose:jni   | 输出native方法调用的相关情况，一般用于诊断jni调用错误信息。  |



#### 5.1.2、输出GC的详细日志（-XX:+PrintGCDetails ）



```
-Xms20M -Xmx20M -Xmn10M -XX:SurvivorRatio=8 -
verbose:gc 
-XX:+PrintGCDetails
```



```
[GC (System.gc()) [PSYoungGen: 2635K->1008K(9216K)] 2635K->1158K(19456K), 0.0013864 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
[Full GC (System.gc()) [PSYoungGen: 1008K->0K(9216K)] [ParOldGen: 150K->918K(10240K)] 1158K->918K(19456K), [Metaspace: 3218K->3218K(1056768K)], 0.0054385 secs] [Times: user=0.09 sys=0.00, real=0.01 secs] 
Heap
 PSYoungGen      total 9216K, used 246K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000)
  eden space 8192K, 3% used [0x00000000ff600000,0x00000000ff63d8e0,0x00000000ffe00000)
  from space 1024K, 0% used [0x00000000ffe00000,0x00000000ffe00000,0x00000000fff00000)
  to   space 1024K, 0% used [0x00000000fff00000,0x00000000fff00000,0x0000000100000000)
 ParOldGen       total 10240K, used 918K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000)
  object space 10240K, 8% used [0x00000000fec00000,0x00000000fece5b50,0x00000000ff600000)
 Metaspace       used 3234K, capacity 4496K, committed 4864K, reserved 1056768K
  class space    used 309K, capacity 388K, committed 512K, reserved 1048576K


```



#### 5.1.3、输出GC的时间戳（以基准时间的形式：-XX:+PrintGCTimeStamps）



```
-Xms20M -Xmx20M -Xmn10M -XX:SurvivorRatio=8 
-verbose:gc 
-XX:+PrintGCDetails 
-XX:+PrintGCTimeStamps
```

```

0.313: [GC (System.gc()) [PSYoungGen: 2635K->1008K(9216K)] 2635K->1122K(19456K), 0.0011256 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
0.315: [Full GC (System.gc()) [PSYoungGen: 1008K->0K(9216K)] [ParOldGen: 114K->918K(10240K)] 1122K->918K(19456K), [Metaspace: 3222K->3222K(1056768K)], 0.0051251 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
Heap
 PSYoungGen      total 9216K, used 246K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000)
  eden space 8192K, 3% used [0x00000000ff600000,0x00000000ff63d888,0x00000000ffe00000)
  from space 1024K, 0% used [0x00000000ffe00000,0x00000000ffe00000,0x00000000fff00000)
  to   space 1024K, 0% used [0x00000000fff00000,0x00000000fff00000,0x0000000100000000)
 ParOldGen       total 10240K, used 918K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000)
  object space 10240K, 8% used [0x00000000fec00000,0x00000000fece59a8,0x00000000ff600000)
 Metaspace       used 3245K, capacity 4496K, committed 4864K, reserved 1056768K
  class space    used 311K, capacity 388K, committed 512K, reserved 1048576K
```



#### 5.1.4、输出GC的时间戳（以日期的形式，如 2013-05-04T21:53:59.234+0800）-XX:+PrintGCDateStamps ：

```
-Xms20M -Xmx20M -Xmn10M -XX:SurvivorRatio=8 
-verbose:gc 
-XX:+PrintGCDetails 
-XX:+PrintGCDateStamps
```



```

2019-12-24T11:31:04.773+0800: [GC (System.gc()) [PSYoungGen: 2635K->1016K(9216K)] 2635K->1132K(19456K), 0.0015084 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
2019-12-24T11:31:04.775+0800: [Full GC (System.gc()) [PSYoungGen: 1016K->0K(9216K)] [ParOldGen: 116K->917K(10240K)] 1132K->917K(19456K), [Metaspace: 3206K->3206K(1056768K)], 0.0048027 secs] [Times: user=0.00 sys=0.01, real=0.00 secs] 
Heap
 PSYoungGen      total 9216K, used 246K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000)
  eden space 8192K, 3% used [0x00000000ff600000,0x00000000ff63d890,0x00000000ffe00000)
  from space 1024K, 0% used [0x00000000ffe00000,0x00000000ffe00000,0x00000000fff00000)
  to   space 1024K, 0% used [0x00000000fff00000,0x00000000fff00000,0x0000000100000000)
 ParOldGen       total 10240K, used 917K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000)
  object space 10240K, 8% used [0x00000000fec00000,0x00000000fece5478,0x00000000ff600000)
 Metaspace       used 3213K, capacity 4496K, committed 4864K, reserved 1056768K
  class space    used 304K, capacity 388K, committed 512K, reserved 1048576K

```



#### 5.1.5、输出GC的日期(-XX:+PrintGCDateStamps )



```
-Xms20M -Xmx20M -Xmn10M -XX:SurvivorRatio=8 -verbose:gc -XX:+PrintGCDetails 
 -XX:+PrintGCTimeStamps -XX:+PrintGCDateStamps
```

```
2019-12-24T11:34:45.910+0800: 0.343: [GC (System.gc()) [PSYoungGen: 2635K->1008K(9216K)] 2635K->1158K(19456K), 0.0018725 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
2019-12-24T11:34:45.912+0800: 0.345: [Full GC (System.gc()) [PSYoungGen: 1008K->0K(9216K)] [ParOldGen: 150K->917K(10240K)] 1158K->917K(19456K), [Metaspace: 3206K->3206K(1056768K)], 0.0053643 secs] [Times: user=0.00 sys=0.00, real=0.01 secs] 
Heap
 PSYoungGen      total 9216K, used 82K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000)
  eden space 8192K, 1% used [0x00000000ff600000,0x00000000ff614920,0x00000000ffe00000)
  from space 1024K, 0% used [0x00000000ffe00000,0x00000000ffe00000,0x00000000fff00000)
  to   space 1024K, 0% used [0x00000000fff00000,0x00000000fff00000,0x0000000100000000)
 ParOldGen       total 10240K, used 917K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000)
  object space 10240K, 8% used [0x00000000fec00000,0x00000000fece54d0,0x00000000ff600000)
 Metaspace       used 3213K, capacity 4496K, committed 4864K, reserved 1056768K
  class space    used 304K, capacity 388K, committed 512K, reserved 1048576K
```



#### 5.1.6、在进行GC的前后打印出堆的信息（-XX:+PrintHeapAtGC ：）

```
-Xms20M -Xmx20M -Xmn10M -XX:SurvivorRatio=8 
-verbose:gc 
-XX:+PrintGCDetails 
-XX:+PrintGCDateStamps 
-XX:+PrintGCTimeStamps 
-XX:+PrintHeapAtGC
```



```
{Heap before GC invocations=1 (full 0):
 PSYoungGen      total 9216K, used 2635K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000)
  eden space 8192K, 32% used [0x00000000ff600000,0x00000000ff892dc8,0x00000000ffe00000)
  from space 1024K, 0% used [0x00000000fff00000,0x00000000fff00000,0x0000000100000000)
  to   space 1024K, 0% used [0x00000000ffe00000,0x00000000ffe00000,0x00000000fff00000)
 ParOldGen       total 10240K, used 0K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000)
  object space 10240K, 0% used [0x00000000fec00000,0x00000000fec00000,0x00000000ff600000)
 Metaspace       used 3206K, capacity 4496K, committed 4864K, reserved 1056768K
  class space    used 304K, capacity 388K, committed 512K, reserved 1048576K
2019-12-24T13:48:42.020+0800: 0.384: [GC (System.gc()) [PSYoungGen: 2635K->1016K(9216K)] 2635K->1100K(19456K), 0.0010979 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
Heap after GC invocations=1 (full 0):
 PSYoungGen      total 9216K, used 1016K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000)
  eden space 8192K, 0% used [0x00000000ff600000,0x00000000ff600000,0x00000000ffe00000)
  from space 1024K, 99% used [0x00000000ffe00000,0x00000000ffefe010,0x00000000fff00000)
  to   space 1024K, 0% used [0x00000000fff00000,0x00000000fff00000,0x0000000100000000)
 ParOldGen       total 10240K, used 84K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000)
  object space 10240K, 0% used [0x00000000fec00000,0x00000000fec15240,0x00000000ff600000)
 Metaspace       used 3206K, capacity 4496K, committed 4864K, reserved 1056768K
  class space    used 304K, capacity 388K, committed 512K, reserved 1048576K
}
{Heap before GC invocations=2 (full 1):
 PSYoungGen      total 9216K, used 1016K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000)
  eden space 8192K, 0% used [0x00000000ff600000,0x00000000ff600000,0x00000000ffe00000)
  from space 1024K, 99% used [0x00000000ffe00000,0x00000000ffefe010,0x00000000fff00000)
  to   space 1024K, 0% used [0x00000000fff00000,0x00000000fff00000,0x0000000100000000)
 ParOldGen       total 10240K, used 84K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000)
  object space 10240K, 0% used [0x00000000fec00000,0x00000000fec15240,0x00000000ff600000)
 Metaspace       used 3206K, capacity 4496K, committed 4864K, reserved 1056768K
  class space    used 304K, capacity 388K, committed 512K, reserved 1048576K
2019-12-24T13:48:42.021+0800: 0.385: [Full GC (System.gc()) [PSYoungGen: 1016K->0K(9216K)] [ParOldGen: 84K->917K(10240K)] 1100K->917K(19456K), [Metaspace: 3206K->3206K(1056768K)], 0.0049082 secs] [Times: user=0.00 sys=0.00, real=0.01 secs] 
Heap after GC invocations=2 (full 1):
 PSYoungGen      total 9216K, used 0K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000)
  eden space 8192K, 0% used [0x00000000ff600000,0x00000000ff600000,0x00000000ffe00000)
  from space 1024K, 0% used [0x00000000ffe00000,0x00000000ffe00000,0x00000000fff00000)
  to   space 1024K, 0% used [0x00000000fff00000,0x00000000fff00000,0x0000000100000000)
 ParOldGen       total 10240K, used 917K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000)
  object space 10240K, 8% used [0x00000000fec00000,0x00000000fece54d0,0x00000000ff600000)
 Metaspace       used 3206K, capacity 4496K, committed 4864K, reserved 1056768K
  class space    used 304K, capacity 388K, committed 512K, reserved 1048576K
}
Heap
 PSYoungGen      total 9216K, used 246K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000)
  eden space 8192K, 3% used [0x00000000ff600000,0x00000000ff63d890,0x00000000ffe00000)
  from space 1024K, 0% used [0x00000000ffe00000,0x00000000ffe00000,0x00000000fff00000)
  to   space 1024K, 0% used [0x00000000fff00000,0x00000000fff00000,0x0000000100000000)
 ParOldGen       total 10240K, used 917K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000)
  object space 10240K, 8% used [0x00000000fec00000,0x00000000fece54d0,0x00000000ff600000)
 Metaspace       used 3222K, capacity 4496K, committed 4864K, reserved 1056768K
  class space    used 306K, capacity 388K, committed 512K, reserved 1048576K
```



#### 5.1.7、打印出Survivor空间中的对象的年龄分布(-XX:+PrintTenuringDistribution ：)

```
-XX:+PrintTenuringDistribution
```



```
Desired survivor size 75497472 bytes, new threshold 15 (max 15)
- age   1:   19321624 bytes,   19321624 total
- age   2:      79376 bytes,   19401000 total
- age   3:    2904256 bytes,   22305256 total

从第一行中可以看出JVM期望的Survivor空间占用为72M，对象被移到老年代中的年龄阈值为15。其中期望的Survivor空间大小为Survivor空间大小 x -XX:TargetSurvivorRatio的值。  

年龄为1的对象约19M，年龄为2的对象约79k，年龄为3的对象约为2.9M，每行后面的数值表示所有小于等于该行年龄的对象的总共大小   
比如：，比如最后一行就表示所有年龄小于等于3的对象的总共大小为约22M（等于所有年龄对象大小的和）。因为目前Survivor空间中对象的大小22M小于期望Survivor空间的大小72M，所以没有对象会被移到老年代。

```



#### 5.1.8、 打印所有的系统参数的值(-XX:+PrintFlagsFinal ：)

- 查看系统参数 

```shell
java -XX:+PrintFlagsFinal -version | grep MetaspaceSiz
```



```
-Xms20M -Xmx20M -Xmn10M -XX:SurvivorRatio=8  
-verbose:gc  
-XX:+PrintGCDetails  
-XX:+PrintGCDateStamps  
-XX:+PrintGCTimeStamps   
-XX:+PrintFlagsFinal 
```



```


[Global flags]
     intx ActiveProcessorCount                      = -1                                  {product}
    uintx AdaptiveSizeDecrementScaleFactor          = 4                                   {product}
    uintx AdaptiveSizeMajorGCDecayTimeScale         = 10                                  {product}
    uintx AdaptiveSizePausePolicy                   = 0                                   {product}
    uintx AdaptiveSizePolicyCollectionCostMargin    = 50                                  {product}
    uintx AdaptiveSizePolicyInitializingSteps       = 20                                  {product}
    uintx AdaptiveSizePolicyOutputInterval          = 0                                   {product}
    uintx AdaptiveSizePolicyWeight                  = 10                                  {product}
    uintx AdaptiveSizeThroughPutPolicy              = 0                                   {product}
    uintx AdaptiveTimeWeight                        = 25                                  {product}
     bool AdjustConcurrency                         = false                               {product}
     bool AggressiveHeap                            = false                               {product}
     bool AggressiveOpts                            = false                               {product}
     intx AliasLevel                                = 3                                   {C2 product}
     bool AlignVector                               = false                               {C2 product}
     intx AllocateInstancePrefetchLines             = 1                                   {product}
     intx AllocatePrefetchDistance                  = 192                                 {product}
     intx AllocatePrefetchInstr                     = 3                                   {product}
     intx AllocatePrefetchLines                     = 4                                   {product}
     intx AllocatePrefetchStepSize                  = 64                                  {product}
     intx AllocatePrefetchStyle                     = 1                                   {product}
     bool AllowJNIEnvProxy                          = false                               {product}
     bool AllowNonVirtualCalls                      = false                               {product}
     bool AllowParallelDefineClass                  = false                               {product}
     bool AllowUserSignalHandlers                   = false                               {product}
     bool AlwaysActAsServerClassMachine             = false                               {product}
     bool AlwaysCompileLoopMethods                  = false                               {product}
     bool AlwaysLockClassLoader                     = false                               {product}
     bool AlwaysPreTouch                            = false                               {product}
     bool AlwaysRestoreFPU                          = false                               {product}
     bool AlwaysTenure                              = false                               {product}
     bool AssertOnSuspendWaitFailure                = false                               {product}
     bool AssumeMP                                  = false                               {product}
     intx AutoBoxCacheMax                           = 128                                 {C2 product}
    uintx AutoGCSelectPauseMillis                   = 5000                                {product}
     intx BCEATraceLevel                            = 0                                   {product}
     intx BackEdgeThreshold                         = 100000                              {pd product}
     bool BackgroundCompilation                     = true                                {pd product}
    uintx BaseFootPrintEstimate                     = 268435456                           {product}
     intx BiasedLockingBulkRebiasThreshold          = 20                                  {product}
     intx BiasedLockingBulkRevokeThreshold          = 40                                  {product}
     intx BiasedLockingDecayTime                    = 25000                               {product}
     intx BiasedLockingStartupDelay                 = 4000                                {product}
     bool BindGCTaskThreadsToCPUs                   = false                               {product}
     bool BlockLayoutByFrequency                    = true                                {C2 product}
     intx BlockLayoutMinDiamondPercentage           = 20                                  {C2 product}
     bool BlockLayoutRotateLoops                    = true                                {C2 product}
     bool BranchOnRegister                          = false                               {C2 product}
     bool BytecodeVerificationLocal                 = false                               {product}
     bool BytecodeVerificationRemote                = true                                {product}
     bool C1OptimizeVirtualCallProfiling            = true                                {C1 product}
     bool C1ProfileBranches                         = true                                {C1 product}
     bool C1ProfileCalls                            = true                                {C1 product}
     bool C1ProfileCheckcasts                       = true                                {C1 product}
     bool C1ProfileInlinedCalls                     = true                                {C1 product}
     bool C1ProfileVirtualCalls                     = true                                {C1 product}
     bool C1UpdateMethodData                        = true                                {C1 product}
     intx CICompilerCount                          := 4                                   {product}
     bool CICompilerCountPerCPU                     = true                                {product}
     bool CITime                                    = false                               {product}
     bool CMSAbortSemantics                         = false                               {product}
    uintx CMSAbortablePrecleanMinWorkPerIteration   = 100                                 {product}
     intx CMSAbortablePrecleanWaitMillis            = 100                                 {manageable}
    uintx CMSBitMapYieldQuantum                     = 10485760                            {product}
    uintx CMSBootstrapOccupancy                     = 50                                  {product}
     bool CMSClassUnloadingEnabled                  = true                                {product}
    uintx CMSClassUnloadingMaxInterval              = 0                                   {product}
     bool CMSCleanOnEnter                           = true                                {product}
     bool CMSCompactWhenClearAllSoftRefs            = true                                {product}
    uintx CMSConcMarkMultiple                       = 32                                  {product}
     bool CMSConcurrentMTEnabled                    = true                                {product}
    uintx CMSCoordinatorYieldSleepCount             = 10                                  {product}
     bool CMSDumpAtPromotionFailure                 = false                               {product}
     bool CMSEdenChunksRecordAlways                 = true                                {product}
    uintx CMSExpAvgFactor                           = 50                                  {product}
     bool CMSExtrapolateSweep                       = false                               {product}
    uintx CMSFullGCsBeforeCompaction                = 0                                   {product}
    uintx CMSIncrementalDutyCycle                   = 10                                  {product}
    uintx CMSIncrementalDutyCycleMin                = 0                                   {product}
     bool CMSIncrementalMode                        = false                               {product}
    uintx CMSIncrementalOffset                      = 0                                   {product}
     bool CMSIncrementalPacing                      = true                                {product}
    uintx CMSIncrementalSafetyFactor                = 10                                  {product}
    uintx CMSIndexedFreeListReplenish               = 4                                   {product}
     intx CMSInitiatingOccupancyFraction            = -1                                  {product}
    uintx CMSIsTooFullPercentage                    = 98                                  {product}
   double CMSLargeCoalSurplusPercent                = 0.950000                            {product}
   double CMSLargeSplitSurplusPercent               = 1.000000                            {product}
     bool CMSLoopWarn                               = false                               {product}
    uintx CMSMaxAbortablePrecleanLoops              = 0                                   {product}
     intx CMSMaxAbortablePrecleanTime               = 5000                                {product}
    uintx CMSOldPLABMax                             = 1024                                {product}
    uintx CMSOldPLABMin                             = 16                                  {product}
    uintx CMSOldPLABNumRefills                      = 4                                   {product}
    uintx CMSOldPLABReactivityFactor                = 2                                   {product}
     bool CMSOldPLABResizeQuicker                   = false                               {product}
    uintx CMSOldPLABToleranceFactor                 = 4                                   {product}
     bool CMSPLABRecordAlways                       = true                                {product}
    uintx CMSParPromoteBlocksToClaim                = 16                                  {product}
     bool CMSParallelInitialMarkEnabled             = true                                {product}
     bool CMSParallelRemarkEnabled                  = true                                {product}
     bool CMSParallelSurvivorRemarkEnabled          = true                                {product}
    uintx CMSPrecleanDenominator                    = 3                                   {product}
    uintx CMSPrecleanIter                           = 3                                   {product}
    uintx CMSPrecleanNumerator                      = 2                                   {product}
     bool CMSPrecleanRefLists1                      = true                                {product}
     bool CMSPrecleanRefLists2                      = false                               {product}
     bool CMSPrecleanSurvivors1                     = false                               {product}
     bool CMSPrecleanSurvivors2                     = true                                {product}
    uintx CMSPrecleanThreshold                      = 1000                                {product}
     bool CMSPrecleaningEnabled                     = true                                {product}
     bool CMSPrintChunksInDump                      = false                               {product}
     bool CMSPrintEdenSurvivorChunks                = false                               {product}
     bool CMSPrintObjectsInDump                     = false                               {product}
    uintx CMSRemarkVerifyVariant                    = 1                                   {product}
     bool CMSReplenishIntermediate                  = true                                {product}
    uintx CMSRescanMultiple                         = 32                                  {product}
    uintx CMSSamplingGrain                          = 16384                               {product}
     bool CMSScavengeBeforeRemark                   = false                               {product}
    uintx CMSScheduleRemarkEdenPenetration          = 50                                  {product}
    uintx CMSScheduleRemarkEdenSizeThreshold        = 2097152                             {product}
    uintx CMSScheduleRemarkSamplingRatio            = 5                                   {product}
   double CMSSmallCoalSurplusPercent                = 1.050000                            {product}
   double CMSSmallSplitSurplusPercent               = 1.100000                            {product}
     bool CMSSplitIndexedFreeListBlocks             = true                                {product}
     intx CMSTriggerInterval                        = -1                                  {manageable}
    uintx CMSTriggerRatio                           = 80                                  {product}
     intx CMSWaitDuration                           = 2000                                {manageable}
    uintx CMSWorkQueueDrainThreshold                = 10                                  {product}
     bool CMSYield                                  = true                                {product}
    uintx CMSYieldSleepCount                        = 0                                   {product}
    uintx CMSYoungGenPerWorker                      = 67108864                            {pd product}
    uintx CMS_FLSPadding                            = 1                                   {product}
    uintx CMS_FLSWeight                             = 75                                  {product}
    uintx CMS_SweepPadding                          = 1                                   {product}
    uintx CMS_SweepTimerThresholdMillis             = 10                                  {product}
    uintx CMS_SweepWeight                           = 75                                  {product}
     bool CheckEndorsedAndExtDirs                   = false                               {product}
     bool CheckJNICalls                             = false                               {product}
     bool ClassUnloading                            = true                                {product}
     bool ClassUnloadingWithConcurrentMark          = true                                {product}
     intx ClearFPUAtPark                            = 0                                   {product}
     bool ClipInlining                              = true                                {product}
    uintx CodeCacheExpansionSize                    = 65536                               {pd product}
    uintx CodeCacheMinimumFreeSpace                 = 512000                              {product}
     bool CollectGen0First                          = false                               {product}
     bool CompactFields                             = true                                {product}
     intx CompilationPolicyChoice                   = 3                                   {product}
ccstrlist CompileCommand                            =                                     {product}
    ccstr CompileCommandFile                        =                                     {product}
ccstrlist CompileOnly                               =                                     {product}
     intx CompileThreshold                          = 10000                               {pd product}
     bool CompilerThreadHintNoPreempt               = true                                {product}
     intx CompilerThreadPriority                    = -1                                  {product}
     intx CompilerThreadStackSize                   = 0                                   {pd product}
    uintx CompressedClassSpaceSize                  = 1073741824                          {product}
    uintx ConcGCThreads                             = 0                                   {product}
     intx ConditionalMoveLimit                      = 3                                   {C2 pd product}
     intx ContendedPaddingWidth                     = 128                                 {product}
     bool ConvertSleepToYield                       = true                                {pd product}
     bool ConvertYieldToSleep                       = false                               {product}
     bool CrashOnOutOfMemoryError                   = false                               {product}
     bool CreateMinidumpOnCrash                     = false                               {product}
     bool CriticalJNINatives                        = true                                {product}
     bool DTraceAllocProbes                         = false                               {product}
     bool DTraceMethodProbes                        = false                               {product}
     bool DTraceMonitorProbes                       = false                               {product}
     bool Debugging                                 = false                               {product}
    uintx DefaultMaxRAMFraction                     = 4                                   {product}
     intx DefaultThreadPriority                     = -1                                  {product}
     intx DeferPollingPageLoopCount                 = -1                                  {product}
     intx DeferThrSuspendLoopCount                  = 4000                                {product}
     bool DeoptimizeRandom                          = false                               {product}
     bool DisableAttachMechanism                    = false                               {product}
     bool DisableExplicitGC                         = false                               {product}
     bool DisplayVMOutputToStderr                   = false                               {product}
     bool DisplayVMOutputToStdout                   = false                               {product}
     bool DoEscapeAnalysis                          = true                                {C2 product}
     bool DontCompileHugeMethods                    = true                                {product}
     bool DontYieldALot                             = false                               {pd product}
    ccstr DumpLoadedClassList                       =                                     {product}
     bool DumpReplayDataOnError                     = true                                {product}
     bool DumpSharedSpaces                          = false                               {product}
     bool EagerXrunInit                             = false                               {product}
     intx EliminateAllocationArraySizeLimit         = 64                                  {C2 product}
     bool EliminateAllocations                      = true                                {C2 product}
     bool EliminateAutoBox                          = true                                {C2 product}
     bool EliminateLocks                            = true                                {C2 product}
     bool EliminateNestedLocks                      = true                                {C2 product}
     intx EmitSync                                  = 0                                   {product}
     bool EnableContended                           = true                                {product}
     bool EnableTracing                             = false                               {product}
    uintx ErgoHeapSizeLimit                         = 0                                   {product}
    ccstr ErrorFile                                 =                                     {product}
    ccstr ErrorReportServer                         =                                     {product}
   double EscapeAnalysisTimeout                     = 20.000000                           {C2 product}
     bool EstimateArgEscape                         = true                                {product}
     bool ExitOnOutOfMemoryError                    = false                               {product}
     bool ExplicitGCInvokesConcurrent               = false                               {product}
     bool ExplicitGCInvokesConcurrentAndUnloadsClasses  = false                               {product}
     bool ExtendedDTraceProbes                      = false                               {product}
    ccstr ExtraSharedClassListFile                  =                                     {product}
     bool FLSAlwaysCoalesceLarge                    = false                               {product}
    uintx FLSCoalescePolicy                         = 2                                   {product}
   double FLSLargestBlockCoalesceProximity          = 0.990000                            {product}
     bool FailOverToOldVerifier                     = true                                {product}
     bool FastTLABRefill                            = true                                {product}
     intx FenceInstruction                          = 0                                   {ARCH product}
     intx FieldsAllocationStyle                     = 1                                   {product}
     bool FilterSpuriousWakeups                     = true                                {product}
     bool ForceNUMA                                 = false                               {product}
     bool ForceTimeHighResolution                   = false                               {product}
     intx FreqInlineSize                            = 325                                 {pd product}
   double G1ConcMarkStepDurationMillis              = 10.000000                           {product}
    uintx G1ConcRSHotCardLimit                      = 4                                   {product}
    uintx G1ConcRSLogCacheSize                      = 10                                  {product}
     intx G1ConcRefinementGreenZone                 = 0                                   {product}
     intx G1ConcRefinementRedZone                   = 0                                   {product}
     intx G1ConcRefinementServiceIntervalMillis     = 300                                 {product}
    uintx G1ConcRefinementThreads                   = 0                                   {product}
     intx G1ConcRefinementThresholdStep             = 0                                   {product}
     intx G1ConcRefinementYellowZone                = 0                                   {product}
    uintx G1ConfidencePercent                       = 50                                  {product}
    uintx G1HeapRegionSize                          = 0                                   {product}
    uintx G1HeapWastePercent                        = 5                                   {product}
    uintx G1MixedGCCountTarget                      = 8                                   {product}
     intx G1RSetRegionEntries                       = 0                                   {product}
    uintx G1RSetScanBlockSize                       = 64                                  {product}
     intx G1RSetSparseRegionEntries                 = 0                                   {product}
     intx G1RSetUpdatingPauseTimePercent            = 10                                  {product}
     intx G1RefProcDrainInterval                    = 10                                  {product}
    uintx G1ReservePercent                          = 10                                  {product}
    uintx G1SATBBufferEnqueueingThresholdPercent    = 60                                  {product}
     intx G1SATBBufferSize                          = 1024                                {product}
     intx G1UpdateBufferSize                        = 256                                 {product}
     bool G1UseAdaptiveConcRefinement               = true                                {product}
    uintx GCDrainStackTargetSize                    = 64                                  {product}
    uintx GCHeapFreeLimit                           = 2                                   {product}
    uintx GCLockerEdenExpansionPercent              = 5                                   {product}
     bool GCLockerInvokesConcurrent                 = false                               {product}
    uintx GCLogFileSize                             = 8192                                {product}
    uintx GCPauseIntervalMillis                     = 0                                   {product}
    uintx GCTaskTimeStampEntries                    = 200                                 {product}
    uintx GCTimeLimit                               = 98                                  {product}
    uintx GCTimeRatio                               = 99                                  {product}
    uintx HeapBaseMinAddress                        = 2147483648                          {pd product}
     bool HeapDumpAfterFullGC                       = false                               {manageable}
     bool HeapDumpBeforeFullGC                      = false                               {manageable}
     bool HeapDumpOnOutOfMemoryError                = false                               {manageable}
    ccstr HeapDumpPath                              =                                     {manageable}
    uintx HeapFirstMaximumCompactionCount           = 3                                   {product}
    uintx HeapMaximumCompactionInterval             = 20                                  {product}
    uintx HeapSizePerGCThread                       = 87241520                            {product}
     bool IgnoreEmptyClassPaths                     = false                               {product}
     bool IgnoreUnrecognizedVMOptions               = false                               {product}
    uintx IncreaseFirstTierCompileThresholdAt       = 50                                  {product}
     bool IncrementalInline                         = true                                {C2 product}
    uintx InitialBootClassLoaderMetaspaceSize       = 4194304                             {product}
    uintx InitialCodeCacheSize                      = 2555904                             {pd product}
    uintx InitialHeapSize                          := 20971520                            {product}
    uintx InitialRAMFraction                        = 64                                  {product}
   double InitialRAMPercentage                      = 1.562500                            {product}
    uintx InitialSurvivorRatio                      = 10                                  {product}
    uintx InitialTenuringThreshold                  = 7                                   {product}
    uintx InitiatingHeapOccupancyPercent            = 45                                  {product}
     bool Inline                                    = true                                {product}
    ccstr InlineDataFile                            =                                     {product}
     intx InlineSmallCode                           = 2000                                {pd product}
     bool InlineSynchronizedMethods                 = true                                {C1 product}
     bool InsertMemBarAfterArraycopy                = true                                {C2 product}
     intx InteriorEntryAlignment                    = 16                                  {C2 pd product}
     intx InterpreterProfilePercentage              = 33                                  {product}
     bool JNIDetachReleasesMonitors                 = true                                {product}
     bool JavaMonitorsInStackTrace                  = true                                {product}
     intx JavaPriority10_To_OSPriority              = -1                                  {product}
     intx JavaPriority1_To_OSPriority               = -1                                  {product}
     intx JavaPriority2_To_OSPriority               = -1                                  {product}
     intx JavaPriority3_To_OSPriority               = -1                                  {product}
     intx JavaPriority4_To_OSPriority               = -1                                  {product}
     intx JavaPriority5_To_OSPriority               = -1                                  {product}
     intx JavaPriority6_To_OSPriority               = -1                                  {product}
     intx JavaPriority7_To_OSPriority               = -1                                  {product}
     intx JavaPriority8_To_OSPriority               = -1                                  {product}
     intx JavaPriority9_To_OSPriority               = -1                                  {product}
     bool LIRFillDelaySlots                         = false                               {C1 pd product}
    uintx LargePageHeapSizeThreshold                = 134217728                           {product}
    uintx LargePageSizeInBytes                      = 0                                   {product}
     bool LazyBootClassLoader                       = true                                {product}
     intx LiveNodeCountInliningCutoff               = 40000                               {C2 product}
     intx LoopMaxUnroll                             = 16                                  {C2 product}
     intx LoopOptsCount                             = 43                                  {C2 product}
     intx LoopUnrollLimit                           = 60                                  {C2 pd product}
     intx LoopUnrollMin                             = 4                                   {C2 product}
     bool LoopUnswitching                           = true                                {C2 product}
     bool ManagementServer                          = false                               {product}
    uintx MarkStackSize                             = 4194304                             {product}
    uintx MarkStackSizeMax                          = 536870912                           {product}
    uintx MarkSweepAlwaysCompactCount               = 4                                   {product}
    uintx MarkSweepDeadRatio                        = 1                                   {product}
     intx MaxBCEAEstimateLevel                      = 5                                   {product}
     intx MaxBCEAEstimateSize                       = 150                                 {product}
    uintx MaxDirectMemorySize                       = 0                                   {product}
     bool MaxFDLimit                                = true                                {product}
    uintx MaxGCMinorPauseMillis                     = 4294967295                          {product}
    uintx MaxGCPauseMillis                          = 4294967295                          {product}
    uintx MaxHeapFreeRatio                          = 100                                 {manageable}
    uintx MaxHeapSize                              := 20971520                            {product}
     intx MaxInlineLevel                            = 9                                   {product}
     intx MaxInlineSize                             = 35                                  {product}
     intx MaxJNILocalCapacity                       = 65536                               {product}
     intx MaxJavaStackTraceDepth                    = 1024                                {product}
     intx MaxJumpTableSize                          = 65000                               {C2 product}
     intx MaxJumpTableSparseness                    = 5                                   {C2 product}
     intx MaxLabelRootDepth                         = 1100                                {C2 product}
     intx MaxLoopPad                                = 11                                  {C2 product}
    uintx MaxMetaspaceExpansion                     = 5451776                             {product}
    uintx MaxMetaspaceFreeRatio                     = 70                                  {product}
    uintx MaxMetaspaceSize                          = 4294901760                          {product}
    uintx MaxNewSize                               := 10485760                            {product}
     intx MaxNodeLimit                              = 75000                               {C2 product}
 uint64_t MaxRAM                                    = 0                                   {pd product}
    uintx MaxRAMFraction                            = 4                                   {product}
   double MaxRAMPercentage                          = 25.000000                           {product}
     intx MaxRecursiveInlineLevel                   = 1                                   {product}
    uintx MaxTenuringThreshold                      = 15                                  {product}
     intx MaxTrivialSize                            = 6                                   {product}
     intx MaxVectorSize                             = 32                                  {C2 product}
    uintx MetaspaceSize                             = 21807104                            {pd product}
     bool MethodFlushing                            = true                                {product}
    uintx MinHeapDeltaBytes                        := 524288                              {product}
    uintx MinHeapFreeRatio                          = 0                                   {manageable}
     intx MinInliningThreshold                      = 250                                 {product}
     intx MinJumpTableSize                          = 10                                  {C2 pd product}
    uintx MinMetaspaceExpansion                     = 339968                              {product}
    uintx MinMetaspaceFreeRatio                     = 40                                  {product}
    uintx MinRAMFraction                            = 2                                   {product}
   double MinRAMPercentage                          = 50.000000                           {product}
    uintx MinSurvivorRatio                          = 10                                  {product}
    uintx MinTLABSize                               = 2048                                {product}
     intx MonitorBound                              = 0                                   {product}
     bool MonitorInUseLists                         = false                               {product}
     intx MultiArrayExpandLimit                     = 6                                   {C2 product}
     bool MustCallLoadClassInternal                 = false                               {product}
    uintx NUMAChunkResizeWeight                     = 20                                  {product}
    uintx NUMAInterleaveGranularity                 = 2097152                             {product}
    uintx NUMAPageScanRate                          = 256                                 {product}
    uintx NUMASpaceResizeRate                       = 1073741824                          {product}
     bool NUMAStats                                 = false                               {product}
    ccstr NativeMemoryTracking                      = off                                 {product}
     bool NeedsDeoptSuspend                         = false                               {pd product}
     bool NeverActAsServerClassMachine              = false                               {pd product}
     bool NeverTenure                               = false                               {product}
    uintx NewRatio                                  = 2                                   {product}
    uintx NewSize                                  := 10485760                            {product}
    uintx NewSizeThreadIncrease                     = 5320                                {pd product}
     intx NmethodSweepActivity                      = 10                                  {product}
     intx NmethodSweepCheckInterval                 = 5                                   {product}
     intx NmethodSweepFraction                      = 16                                  {product}
     intx NodeLimitFudgeFactor                      = 2000                                {C2 product}
    uintx NumberOfGCLogFiles                        = 0                                   {product}
     intx NumberOfLoopInstrToAlign                  = 4                                   {C2 product}
     intx ObjectAlignmentInBytes                    = 8                                   {lp64_product}
    uintx OldPLABSize                               = 1024                                {product}
    uintx OldPLABWeight                             = 50                                  {product}
    uintx OldSize                                  := 10485760                            {product}
     bool OmitStackTraceInFastThrow                 = true                                {product}
ccstrlist OnError                                   =                                     {product}
ccstrlist OnOutOfMemoryError                        =                                     {product}
     intx OnStackReplacePercentage                  = 140                                 {pd product}
     bool OptimizeFill                              = true                                {C2 product}
     bool OptimizePtrCompare                        = true                                {C2 product}
     bool OptimizeStringConcat                      = true                                {C2 product}
     bool OptoBundling                              = false                               {C2 pd product}
     intx OptoLoopAlignment                         = 16                                  {pd product}
     bool OptoScheduling                            = false                               {C2 pd product}
    uintx PLABWeight                                = 75                                  {product}
     bool PSChunkLargeArrays                        = true                                {product}
     intx ParGCArrayScanChunk                       = 50                                  {product}
    uintx ParGCDesiredObjsFromOverflowList          = 20                                  {product}
     bool ParGCTrimOverflow                         = true                                {product}
     bool ParGCUseLocalOverflow                     = false                               {product}
    uintx ParallelGCBufferWastePct                  = 10                                  {product}
    uintx ParallelGCThreads                         = 8                                   {product}
     bool ParallelGCVerbose                         = false                               {product}
    uintx ParallelOldDeadWoodLimiterMean            = 50                                  {product}
    uintx ParallelOldDeadWoodLimiterStdDev          = 80                                  {product}
     bool ParallelRefProcBalancingEnabled           = true                                {product}
     bool ParallelRefProcEnabled                    = false                               {product}
     bool PartialPeelAtUnsignedTests                = true                                {C2 product}
     bool PartialPeelLoop                           = true                                {C2 product}
     intx PartialPeelNewPhiDelta                    = 0                                   {C2 product}
    uintx PausePadding                              = 1                                   {product}
     intx PerBytecodeRecompilationCutoff            = 200                                 {product}
     intx PerBytecodeTrapLimit                      = 4                                   {product}
     intx PerMethodRecompilationCutoff              = 400                                 {product}
     intx PerMethodTrapLimit                        = 100                                 {product}
     bool PerfAllowAtExitRegistration               = false                               {product}
     bool PerfBypassFileSystemCheck                 = false                               {product}
     intx PerfDataMemorySize                        = 32768                               {product}
     intx PerfDataSamplingInterval                  = 50                                  {product}
    ccstr PerfDataSaveFile                          =                                     {product}
     bool PerfDataSaveToFile                        = false                               {product}
     bool PerfDisableSharedMem                      = false                               {product}
     intx PerfMaxStringConstLength                  = 1024                                {product}
     intx PreInflateSpin                            = 10                                  {pd product}
     bool PreferInterpreterNativeStubs              = false                               {pd product}
     intx PrefetchCopyIntervalInBytes               = 576                                 {product}
     intx PrefetchFieldsAhead                       = 1                                   {product}
     intx PrefetchScanIntervalInBytes               = 576                                 {product}
     bool PreserveAllAnnotations                    = false                               {product}
     bool PreserveFramePointer                      = false                               {pd product}
    uintx PretenureSizeThreshold                    = 0                                   {product}
     bool PrintAdaptiveSizePolicy                   = false                               {product}
     bool PrintCMSInitiationStatistics              = false                               {product}
     intx PrintCMSStatistics                        = 0                                   {product}
     bool PrintClassHistogram                       = false                               {manageable}
     bool PrintClassHistogramAfterFullGC            = false                               {manageable}
     bool PrintClassHistogramBeforeFullGC           = false                               {manageable}
     bool PrintCodeCache                            = false                               {product}
     bool PrintCodeCacheOnCompilation               = false                               {product}
     bool PrintCommandLineFlags                     = false                               {product}
     bool PrintCompilation                          = false                               {product}
     bool PrintConcurrentLocks                      = false                               {manageable}
     intx PrintFLSCensus                            = 0                                   {product}
     intx PrintFLSStatistics                        = 0                                   {product}
     bool PrintFlagsFinal                          := true                                {product}
     bool PrintFlagsInitial                         = false                               {product}
     bool PrintGC                                  := true                                {manageable}
     bool PrintGCApplicationConcurrentTime          = false                               {product}
     bool PrintGCApplicationStoppedTime             = false                               {product}
     bool PrintGCCause                              = true                                {product}
     bool PrintGCDateStamps                        := true                                {manageable}
     bool PrintGCDetails                           := true                                {manageable}
     bool PrintGCID                                 = false                               {manageable}
     bool PrintGCTaskTimeStamps                     = false                               {product}
     bool PrintGCTimeStamps                        := true                                {manageable}
     bool PrintHeapAtGC                             = false                               {product rw}
     bool PrintHeapAtGCExtended                     = false                               {product rw}
     bool PrintHeapAtSIGBREAK                       = true                                {product}
     bool PrintJNIGCStalls                          = false                               {product}
     bool PrintJNIResolving                         = false                               {product}
     bool PrintOldPLAB                              = false                               {product}
     bool PrintOopAddress                           = false                               {product}
     bool PrintPLAB                                 = false                               {product}
     bool PrintParallelOldGCPhaseTimes              = false                               {product}
     bool PrintPromotionFailure                     = false                               {product}
     bool PrintReferenceGC                          = false                               {product}
     bool PrintSafepointStatistics                  = false                               {product}
     intx PrintSafepointStatisticsCount             = 300                                 {product}
     intx PrintSafepointStatisticsTimeout           = -1                                  {product}
     bool PrintSharedArchiveAndExit                 = false                               {product}
     bool PrintSharedDictionary                     = false                               {product}
     bool PrintSharedSpaces                         = false                               {product}
     bool PrintStringDeduplicationStatistics        = false                               {product}
     bool PrintStringTableStatistics                = false                               {product}
     bool PrintTLAB                                 = false                               {product}
     bool PrintTenuringDistribution                 = false                               {product}
     bool PrintTieredEvents                         = false                               {product}
     bool PrintVMOptions                            = false                               {product}
     bool PrintVMQWaitTime                          = false                               {product}
     bool PrintWarnings                             = true                                {product}
    uintx ProcessDistributionStride                 = 4                                   {product}
     bool ProfileInterpreter                        = true                                {pd product}
     bool ProfileIntervals                          = false                               {product}
     intx ProfileIntervalsTicks                     = 100                                 {product}
     intx ProfileMaturityPercentage                 = 20                                  {product}
     bool ProfileVM                                 = false                               {product}
     bool ProfilerPrintByteCodeStatistics           = false                               {product}
     bool ProfilerRecordPC                          = false                               {product}
    uintx PromotedPadding                           = 3                                   {product}
    uintx QueuedAllocationWarningCount              = 0                                   {product}
    uintx RTMRetryCount                             = 5                                   {ARCH product}
     bool RangeCheckElimination                     = true                                {product}
     intx ReadPrefetchInstr                         = 0                                   {ARCH product}
     bool ReassociateInvariants                     = true                                {C2 product}
     bool ReduceBulkZeroing                         = true                                {C2 product}
     bool ReduceFieldZeroing                        = true                                {C2 product}
     bool ReduceInitialCardMarks                    = true                                {C2 product}
     bool ReduceSignalUsage                         = false                               {product}
     intx RefDiscoveryPolicy                        = 0                                   {product}
     bool ReflectionWrapResolutionErrors            = true                                {product}
     bool RegisterFinalizersAtInit                  = true                                {product}
     bool RelaxAccessControlCheck                   = false                               {product}
    ccstr ReplayDataFile                            =                                     {product}
     bool RequireSharedSpaces                       = false                               {product}
    uintx ReservedCodeCacheSize                     = 251658240                           {pd product}
     bool ResizeOldPLAB                             = true                                {product}
     bool ResizePLAB                                = true                                {product}
     bool ResizeTLAB                                = true                                {pd product}
     bool RestoreMXCSROnJNICalls                    = false                               {product}
     bool RestrictContended                         = true                                {product}
     bool RewriteBytecodes                          = true                                {pd product}
     bool RewriteFrequentPairs                      = false                               {pd product}
     intx SafepointPollOffset                       = 256                                 {C1 pd product}
     intx SafepointSpinBeforeYield                  = 2000                                {product}
     bool SafepointTimeout                          = false                               {product}
     intx SafepointTimeoutDelay                     = 10000                               {product}
     bool ScavengeBeforeFullGC                      = true                                {product}
     intx SelfDestructTimer                         = 0                                   {product}
    uintx SharedBaseAddress                         = 0                                   {product}
    ccstr SharedClassListFile                       =                                     {product}
    uintx SharedMiscCodeSize                        = 122880                              {product}
    uintx SharedMiscDataSize                        = 4194304                             {product}
    uintx SharedReadOnlySize                        = 16777216                            {product}
    uintx SharedReadWriteSize                       = 16777216                            {product}
    uintx ShenandoahAllocationThreshold             = 0                                   {product rw}
     bool ShenandoahAlwaysPreTouch                  = false                               {product}
    uintx ShenandoahFreeThreshold                   = 10                                  {product rw}
    uintx ShenandoahFullGCThreshold                 = 3                                   {product rw}
    ccstr ShenandoahGCHeuristics                    = adaptive                            {product}
    uintx ShenandoahGarbageThreshold                = 60                                  {product rw}
    uintx ShenandoahHeapRegionSize                  = 0                                   {product}
     bool ShenandoahLogDebug                        = false                               {product}
     bool ShenandoahLogInfo                         = false                               {product}
     bool ShenandoahLogTrace                        = false                               {product}
     bool ShenandoahLogWarning                      = false                               {product}
     bool ShenandoahOptimizeInstanceFinals          = false                               {product}
     bool ShenandoahOptimizeStableFinals            = false                               {product}
     bool ShenandoahOptimizeStaticFinals            = true                                {product}
    uintx ShenandoahRefProcFrequency                = 5                                   {product}
     bool ShenandoahRegionSampling                  = false                               {product rw}
      int ShenandoahRegionSamplingRate              =                     {product rw}
    uintx ShenandoahUnloadClassesFrequency          = 5                                   {product}
     bool ShowMessageBoxOnError                     = false                               {product}
     intx SoftRefLRUPolicyMSPerMB                   = 1000                                {product}
     bool SpecialEncodeISOArray                     = true                                {C2 product}
     bool SplitIfBlocks                             = true                                {C2 product}
     intx StackRedPages                             = 1                                   {pd product}
     intx StackShadowPages                          = 6                                   {pd product}
     bool StackTraceInThrowable                     = true                                {product}
     intx StackYellowPages                          = 3                                   {pd product}
     bool StartAttachListener                       = false                               {product}
     intx StarvationMonitorInterval                 = 200                                 {product}
     bool StressLdcRewrite                          = false                               {product}
    uintx StringDeduplicationAgeThreshold           = 3                                   {product}
    uintx StringTableSize                           = 60013                               {product}
     bool SuppressFatalErrorMessage                 = false                               {product}
    uintx SurvivorPadding                           = 3                                   {product}
    uintx SurvivorRatio                            := 8                                   {product}
     intx SuspendRetryCount                         = 50                                  {product}
     intx SuspendRetryDelay                         = 5                                   {product}
     intx SyncFlags                                 = 0                                   {product}
    ccstr SyncKnobs                                 =                                     {product}
     intx SyncVerbose                               = 0                                   {product}
    uintx TLABAllocationWeight                      = 35                                  {product}
    uintx TLABRefillWasteFraction                   = 64                                  {product}
    uintx TLABSize                                  = 0                                   {product}
     bool TLABStats                                 = true                                {product}
    uintx TLABWasteIncrement                        = 4                                   {product}
    uintx TLABWasteTargetPercent                    = 1                                   {product}
    uintx TargetPLABWastePct                        = 10                                  {product}
    uintx TargetSurvivorRatio                       = 50                                  {product}
    uintx TenuredGenerationSizeIncrement            = 20                                  {product}
    uintx TenuredGenerationSizeSupplement           = 80                                  {product}
    uintx TenuredGenerationSizeSupplementDecay      = 2                                   {product}
     intx ThreadPriorityPolicy                      = 0                                   {product}
     bool ThreadPriorityVerbose                     = false                               {product}
    uintx ThreadSafetyMargin                        = 52428800                            {product}
     intx ThreadStackSize                           = 0                                   {pd product}
    uintx ThresholdTolerance                        = 10                                  {product}
     intx Tier0BackedgeNotifyFreqLog                = 10                                  {product}
     intx Tier0InvokeNotifyFreqLog                  = 7                                   {product}
     intx Tier0ProfilingStartPercentage             = 200                                 {product}
     intx Tier23InlineeNotifyFreqLog                = 20                                  {product}
     intx Tier2BackEdgeThreshold                    = 0                                   {product}
     intx Tier2BackedgeNotifyFreqLog                = 14                                  {product}
     intx Tier2CompileThreshold                     = 0                                   {product}
     intx Tier2InvokeNotifyFreqLog                  = 11                                  {product}
     intx Tier3BackEdgeThreshold                    = 60000                               {product}
     intx Tier3BackedgeNotifyFreqLog                = 13                                  {product}
     intx Tier3CompileThreshold                     = 2000                                {product}
     intx Tier3DelayOff                             = 2                                   {product}
     intx Tier3DelayOn                              = 5                                   {product}
     intx Tier3InvocationThreshold                  = 200                                 {product}
     intx Tier3InvokeNotifyFreqLog                  = 10                                  {product}
     intx Tier3LoadFeedback                         = 5                                   {product}
     intx Tier3MinInvocationThreshold               = 100                                 {product}
     intx Tier4BackEdgeThreshold                    = 40000                               {product}
     intx Tier4CompileThreshold                     = 15000                               {product}
     intx Tier4InvocationThreshold                  = 5000                                {product}
     intx Tier4LoadFeedback                         = 3                                   {product}
     intx Tier4MinInvocationThreshold               = 600                                 {product}
     bool TieredCompilation                         = true                                {pd product}
     intx TieredCompileTaskTimeout                  = 50                                  {product}
     intx TieredRateUpdateMaxTime                   = 25                                  {product}
     intx TieredRateUpdateMinTime                   = 1                                   {product}
     intx TieredStopAtLevel                         = 4                                   {product}
     bool TimeLinearScan                            = false                               {C1 product}
     bool TraceBiasedLocking                        = false                               {product}
     bool TraceClassLoading                         = false                               {product rw}
     bool TraceClassLoadingPreorder                 = false                               {product}
     bool TraceClassPaths                           = false                               {product}
     bool TraceClassResolution                      = false                               {product}
     bool TraceClassUnloading                       = false                               {product rw}
     bool TraceDynamicGCThreads                     = false                               {product}
     bool TraceGen0Time                             = false                               {product}
     bool TraceGen1Time                             = false                               {product}
    ccstr TraceJVMTI                                =                                     {product}
     bool TraceLoaderConstraints                    = false                               {product rw}
     bool TraceMetadataHumongousAllocation          = false                               {product}
     bool TraceMonitorInflation                     = false                               {product}
     bool TraceParallelOldGCTasks                   = false                               {product}
     intx TraceRedefineClasses                      = 0                                   {product}
     bool TraceSafepointCleanupTime                 = false                               {product}
     bool TraceSuspendWaitFailures                  = false                               {product}
     intx TrackedInitializationLimit                = 50                                  {C2 product}
     bool TransmitErrorReport                       = false                               {product}
     bool TrapBasedNullChecks                       = false                               {pd product}
     bool TrapBasedRangeChecks                      = false                               {C2 pd product}
     intx TypeProfileArgsLimit                      = 2                                   {product}
    uintx TypeProfileLevel                          = 111                                 {pd product}
     intx TypeProfileMajorReceiverPercent           = 90                                  {C2 product}
     intx TypeProfileParmsLimit                     = 2                                   {product}
     intx TypeProfileWidth                          = 2                                   {product}
     intx UnguardOnExecutionViolation               = 0                                   {product}
     bool UnlinkSymbolsALot                         = false                               {product}
     bool Use486InstrsOnly                          = false                               {ARCH product}
     bool UseAES                                    = true                                {product}
     bool UseAESIntrinsics                          = true                                {product}
     intx UseAVX                                    = 2                                   {ARCH product}
     bool UseAdaptiveGCBoundary                     = false                               {product}
     bool UseAdaptiveGenerationSizePolicyAtMajorCollection  = true                                {product}
     bool UseAdaptiveGenerationSizePolicyAtMinorCollection  = true                                {product}
     bool UseAdaptiveNUMAChunkSizing                = true                                {product}
     bool UseAdaptiveSizeDecayMajorGCCost           = true                                {product}
     bool UseAdaptiveSizePolicy                     = true                                {product}
     bool UseAdaptiveSizePolicyFootprintGoal        = true                                {product}
     bool UseAdaptiveSizePolicyWithSystemGC         = false                               {product}
     bool UseAddressNop                             = true                                {ARCH product}
     bool UseAltSigs                                = false                               {product}
     bool UseAutoGCSelectPolicy                     = false                               {product}
     bool UseBMI1Instructions                       = true                                {ARCH product}
     bool UseBMI2Instructions                       = true                                {ARCH product}
     bool UseBiasedLocking                          = true                                {product}
     bool UseBimorphicInlining                      = true                                {C2 product}
     bool UseBoundThreads                           = true                                {product}
     bool UseCLMUL                                  = true                                {ARCH product}
     bool UseCMSBestFit                             = true                                {product}
     bool UseCMSCollectionPassing                   = true                                {product}
     bool UseCMSCompactAtFullCollection             = true                                {product}
     bool UseCMSInitiatingOccupancyOnly             = false                               {product}
     bool UseCRC32Intrinsics                        = true                                {product}
     bool UseCodeCacheFlushing                      = true                                {product}
     bool UseCompiler                               = true                                {product}
     bool UseCompilerSafepoints                     = true                                {product}
     bool UseCompressedClassPointers               := true                                {lp64_product}
     bool UseCompressedOops                        := true                                {lp64_product}
     bool UseConcMarkSweepGC                        = false                               {product}
     bool UseCondCardMark                           = false                               {C2 product}
     bool UseCountLeadingZerosInstruction           = true                                {ARCH product}
     bool UseCountTrailingZerosInstruction          = true                                {ARCH product}
     bool UseCountedLoopSafepoints                  = false                               {C2 product}
     bool UseCounterDecay                           = true                                {product}
     bool UseDivMod                                 = true                                {C2 product}
     bool UseDynamicNumberOfGCThreads               = false                               {product}
     bool UseFPUForSpilling                         = true                                {C2 product}
     bool UseFastAccessorMethods                    = false                               {product}
     bool UseFastEmptyMethods                       = false                               {product}
     bool UseFastJNIAccessors                       = true                                {product}
     bool UseFastStosb                              = true                                {ARCH product}
     bool UseG1GC                                   = false                               {product}
     bool UseGCLogFileRotation                      = false                               {product}
     bool UseGCOverheadLimit                        = true                                {product}
     bool UseGCTaskAffinity                         = false                               {product}
     bool UseHeavyMonitors                          = false                               {product}
     bool UseInlineCaches                           = true                                {product}
     bool UseInterpreter                            = true                                {product}
     bool UseJumpTables                             = true                                {C2 product}
     bool UseLWPSynchronization                     = true                                {product}
     bool UseLargePages                             = false                               {pd product}
     bool UseLargePagesInMetaspace                  = false                               {product}
     bool UseLargePagesIndividualAllocation        := false                               {pd product}
     bool UseLockedTracing                          = false                               {product}
     bool UseLoopCounter                            = true                                {product}
     bool UseLoopInvariantCodeMotion                = true                                {C1 product}
     bool UseLoopPredicate                          = true                                {C2 product}
     bool UseMathExactIntrinsics                    = true                                {C2 product}
     bool UseMaximumCompactionOnSystemGC            = true                                {product}
     bool UseMembar                                 = false                               {pd product}
     bool UseMontgomeryMultiplyIntrinsic            = true                                {C2 product}
     bool UseMontgomerySquareIntrinsic              = true                                {C2 product}
     bool UseMulAddIntrinsic                        = true                                {C2 product}
     bool UseMultiplyToLenIntrinsic                 = true                                {C2 product}
     bool UseNUMA                                   = false                               {product}
     bool UseNUMAInterleaving                       = false                               {product}
     bool UseNewLongLShift                          = false                               {ARCH product}
     bool UseOSErrorReporting                       = false                               {pd product}
     bool UseOldInlining                            = true                                {C2 product}
     bool UseOnStackReplacement                     = true                                {pd product}
     bool UseOnlyInlinedBimorphic                   = true                                {C2 product}
     bool UseOptoBiasInlining                       = true                                {C2 product}
     bool UsePSAdaptiveSurvivorSizePolicy           = true                                {product}
     bool UseParNewGC                               = false                               {product}
     bool UseParallelGC                            := true                                {product}
     bool UseParallelOldGC                          = true                                {product}
     bool UsePerfData                               = true                                {product}
     bool UsePopCountInstruction                    = true                                {product}
     bool UseRDPCForConstantTableBase               = false                               {C2 product}
     bool UseRTMDeopt                               = false                               {ARCH product}
     bool UseRTMLocking                             = false                               {ARCH product}
     bool UseSHA                                    = false                               {product}
     bool UseSHA1Intrinsics                         = false                               {product}
     bool UseSHA256Intrinsics                       = false                               {product}
     bool UseSHA512Intrinsics                       = false                               {product}
     intx UseSSE                                    = 4                                   {product}
     bool UseSSE42Intrinsics                        = true                                {product}
     bool UseSerialGC                               = false                               {product}
     bool UseSharedSpaces                           = false                               {product}
     bool UseShenandoahGC                           = false                               {product}
     bool UseSignalChaining                         = true                                {product}
     bool UseSquareToLenIntrinsic                   = true                                {C2 product}
     bool UseStoreImmI16                            = false                               {ARCH product}
     bool UseStringDeduplication                    = false                               {product}
     bool UseSuperWord                              = true                                {C2 product}
     bool UseTLAB                                   = true                                {pd product}
     bool UseThreadPriorities                       = true                                {pd product}
     bool UseTypeProfile                            = true                                {product}
     bool UseTypeSpeculation                        = true                                {C2 product}
     bool UseUTCFileTimestamp                       = true                                {product}
     bool UseUnalignedLoadStores                    = true                                {ARCH product}
     bool UseVMInterruptibleIO                      = false                               {product}
     bool UseXMMForArrayCopy                        = true                                {product}
     bool UseXmmI2D                                 = false                               {ARCH product}
     bool UseXmmI2F                                 = false                               {ARCH product}
     bool UseXmmLoadAndClearUpper                   = true                                {ARCH product}
     bool UseXmmRegToRegMoveAll                     = true                                {ARCH product}
     bool VMThreadHintNoPreempt                     = false                               {product}
     intx VMThreadPriority                          = -1                                  {product}
     intx VMThreadStackSize                         = 0                                   {pd product}
     intx ValueMapInitialSize                       = 11                                  {C1 product}
     intx ValueMapMaxLoopSize                       = 8                                   {C1 product}
     intx ValueSearchLimit                          = 1000                                {C2 product}
     bool VerifyMergedCPBytecodes                   = true                                {product}
     bool VerifySharedSpaces                        = false                               {product}
     intx WorkAroundNPTLTimedWaitHang               = 1                                   {product}
    uintx YoungGenerationSizeIncrement              = 20                                  {product}
    uintx YoungGenerationSizeSupplement             = 80                                  {product}
    uintx YoungGenerationSizeSupplementDecay        = 8                                   {product}
    uintx YoungPLABSize                             = 4096                                {product}
     bool ZeroTLAB                                  = false                               {product}
     intx hashCode                                  = 5                                   {product}
Connected to the target VM, address: '127.0.0.1:55760', transport: 'socket'
2019-12-26T17:05:53.205+0800: 0.806: [GC (Allocation Failure) [PSYoungGen: 8192K->1016K(9216K)] 8192K->1553K(19456K), 0.0016892 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
2019-12-26T17:05:53.376+0800: 0.976: [GC (Allocation Failure) [PSYoungGen: 9208K->992K(9216K)] 9745K->2319K(19456K), 0.0014377 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
2019-12-26T17:05:53.539+0800: 1.140: [GC (Allocation Failure) [PSYoungGen: 9184K->1000K(9216K)] 10511K->3082K(19456K), 0.0019212 secs] [Times: user=0.08 sys=0.00, real=0.00 secs] 
2019-12-26T17:05:53.593+0800: 1.193: [GC (Allocation Failure) --[PSYoungGen: 8826K->8826K(9216K)] 16028K->16318K(19456K), 0.0020696 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
2019-12-26T17:05:53.595+0800: 1.196: [Full GC (Ergonomics) [PSYoungGen: 8826K->6137K(9216K)] [ParOldGen: 7491K->6470K(10240K)] 16318K->12607K(19456K), [Metaspace: 8221K->8221K(1056768K)], 0.0183229 secs] [Times: user=0.11 sys=0.00, real=0.02 secs] 

```



#### 5.1.6、日志位置 (-Xloggc:)

> **不会追加，只会替换** 

```
-Xms20M -Xmx20M -Xmn10M -XX:SurvivorRatio=8 
-verbose:gc 
-XX:+PrintGCDetails 
-XX:+PrintGCDateStamps 
-XX:+PrintGCTimeStamps  
-Xloggc:D:\programFiles\java-1.8.0-openjdk\log\gc.log

```





### 5.2、开启一个远程支持访问的 



| 参数                                          | 类型 | **描述**                                                     |
| --------------------------------------------- | ---- | ------------------------------------------------------------ |
| -Dcom.sun.management.jmxremote                | 布尔 | 默认为true                                                   |
| -Dcom.sun.management.jmxremote.port           | 数字 | 监听端口号，方便远程访问                                     |
| -Dcom.sun.management.jmxremote.authenticate   | 布尔 | 是否需要开启用户认证,默认开启，指定了JMX 是否启用鉴权（需要用户名，密码鉴权） |
| -Dcom.sun.management.jmxremote.ssl            | 布尔 | 是否对连接开启SSL加密，默认开启                              |
| -Dcom.sun.management.jmxremote.access.file    | 路径 | 配置用户权限文件路径，默认路径`JRE_HOME/lib/management/jmxremote.access` |
| -Dcom.sun.management.jmxremote. password.file | 路径 | 用户名和密码，默认路径`JRE_HOME/lib/management/ jmxremote.password` |



#### 5.2.1、启动JVM监控，不配置用户名和密码



> **一般情况下，不用配置用户名和密码，防火墙可以指定某些ip才能访问** 



```shell
-Dcom.sun.management.jmxremote 
-Dcom.sun.management.jmxremote.port=10200

-Dcom.sun.management.jmxremote.authenticate=false 
-Dcom.sun.management.jmxremote.ssl=false
```



![1577339440496](https://raw.githubusercontent.com/HealerJean123/HealerJean123.github.io/master/blogImages/1577339440496.png)







#### 5.2.2、配置用户名和密码(一般没必要) 



##### 1、密码配置 

将以下信息保存到相应的文件里面，比如`jmxremote.password`，具体设置可参考 `${JAVA_HOME}/jre/lib/management/jmxremote.password.template`。 



```
healerjean  123456
monitorRole 123456
controlRole 123456

```



##### 2、用户权限分配 

将上面的信息保存到相应的文件里面，比如`jmxremote.access`。关于用户和权限的配置可以参见`${JAVA_HOME}/jre/lib/management/jmxremote.access`文件  



```
healerjean  readwrite
monitorRole readonly
controlRole readwrite
```



##### 3、参数配置 



+ Linux权限配置 

> chmod 600 jmxremote.access
>
> chmod 600 jmxremote.password



+ windos权限配置  



右键单击文件 jmxremote.password，弹出菜单中选“属性”，再点“安全”/“高级”/“更改权限”/“包括可从该对象的父项继承的权限”(弹出窗口中选“删除”以删除所有访问权限)；    

再选“添加”/“高级”/“立即查找”，选中你的用户（如HealerJean），点“确定”；  权限项目窗口中勾选“完全控制”，点“确定”。



+ 配置参数访问

```shell
-Dcom.sun.management.jmxremote 
-Dcom.sun.management.jmxremote.port=10200
 
-Dcom.sun.management.jmxremote.ssl=false
-Dcom.sun.management.jmxremote.authenticate=true
-Dcom.sun.management.jmxremote.password.file=D:\programFiles\java-1.8.0-openjdk\jre\lib\management\auth\jmxremote.password
-Dcom.sun.management.jmxremote.access.file=D:\programFiles\java-1.8.0-openjdk\jre\lib\management\auth\jmxremote.access
```









### 5.3、其他参数

#### 5.3.1、Java堆区 



| 参数                | 说明                                 | 默认值      | 用法                                                         |
| ------------------- | ------------------------------------ | ----------- | ------------------------------------------------------------ |
| `-Xms`              | 堆区内存初始内存分配的大小           | 系统的1/64  | 通常为默认即可，但有可能真的按照这样的一个规则分配时，设计出的软件还没有能够运行得起来就挂了。所以仍需按照实际情况进行分配。 |
| `-Xmx`              | 堆区内存可被分配的最大上限           | 系统的1/4   | 通常会将` -Xms` 与` -Xmx`两个参数的配置相同的值，其目的是为了能够在java垃圾回收机制清理完堆区后不需要重新分隔计算堆区的大小而浪费资源。 |
| `-XX:newSize`       | 新生代初始内存的大小                 |             | 应该小于 `-Xms`的值；                                        |
| `-XX:MaxnewSize`    | 新生代可被分配的内存的最大上限       |             | 应该小于 `-Xmx`的值；                                        |
| `-Xmn`              | 年轻代大小                           |             | 这个参数则是对 `-XX:newSize`、`-XX:MaxnewSize`两个参数的同时配置   ，`-XX:newSize = -XX:MaxnewSize　=　-Xmn`**((Sun官方建议年轻代的大小为整个堆的3/8左右))** |
| `-XX:SurvivorRatio` | 年轻代中Eden区与Survivor区的大小比值 | 一般设置为8 | 设置年轻代中Eden区与Survivor区的大小比值。-XX:SurvivorRatio=8，则两个Survivor区与一个Eden区的比值为2:8，一个Survivor区占整个年轻代的1/10 |
| `-XX:NewRatio`      | 设置年轻代与年老代的比值             |             | -XX:NewRatio=4:。设置为4，则年轻代与年老代所占比值为1：4，年轻代占整个堆栈的1/5，一般不使用 |





#### 5.3.2、栈区（每个线程的大小 ）    



​		操作系统分配给每个进程的内存是有限制的，虚拟机提供了参数来控制非堆区（`MaxPermSize`）和Java堆(`Xmx)`区这两部分的最大值        

​		**操作系统`剩余的内存`减去`Xmx（最大堆区容量）`和`MaxPermSize（最大方法区容量）`，，程序计数器内存消耗很小可以忽略掉，如果虚拟机进程本身消耗的内存不计算在内，剩下的就给了虚拟机栈和本地方法栈了。**     

​		每个线程分配到的栈容量越大，可以建立的线程数就越少，建立线程时就越容易将资源耗尽。    

​		栈深度在大多数情况下达到1000到2000没有问题，对于正常的方法调用（包括递归），这个深度完全够用了，但是如果是建立多线程导致的内存溢出，在不能减少线程数，或者更换虚拟机的情况下，就只能通过减少最大堆（这样可以让栈区多一些）、减少线程分配的栈容量（如果当前线程占用的栈资源允许的情况下）   



| 参数   | 说明                 | 默认值 | 用法                                                         |
| ------ | -------------------- | ------ | ------------------------------------------------------------ |
| `-Xss` | 设置每个线程的栈大小 | 1M     | JDK5.0以后每个线程栈大小为1M，以前每个线程栈大小为256K。更具应用的线程所需内存大小进行调整。在相同物理内存下，减小这个值能生成更多的线程。但是操作系统对一个进程内的线程数还是有限制的，不能无限生成，经验值在3000~5000左右。 |





#### 5.3.3、持久代 （也叫，方法区，非堆区）



>   持久代（非堆区，方法区）一般固定大小为64m   



| 参数              | 说明                 | 默认值 | 用法 |
| ----------------- | -------------------- | ------ | ---- |
| `-XX:PermSize`    | 非堆区初始化内存大小 |        |      |
| `-XX:MaxPermSize` | 非堆区最大的内存大小 |        |      |



#### 5.3.4、垃圾收集器选择  



![WX20180411-142826@2x](https://raw.githubusercontent.com/HealerJean/HealerJean.github.io/master/blogImages/WX20180411-142826@2x.png) 



| 参数                      | 收集器名称        | 收集算法  | 方式 | 收集对象 | 用法                                                         |
| ------------------------- | ----------------- | --------- | ---- | -------- | ------------------------------------------------------------ |
| `-XX:+UseSerialGC`        | Serial            | 复制      | 串行 | 新生代   | 虚拟机运行在Client模式的默认值，打开此开关参数后，使用Serial+Serial Old收集器组合进行垃圾收集。 |
| `-XX:+UseParNewGC`        | ParNew            | 复制      | 并行 | 新生代   | 开启此参数使用`ParNew` &` serial old`搜集器                  |
| `-XX:+UseParallelG`       | parallel Scavenge | 复制      | 并行 | 新生代   | 开启此参数使用·`parallel scavenge` & `parallel old`搜集器（server模式默认值） |
|                           | serial old        | 标记-整理 | 串行 | 老年代   |                                                              |
| `-XX:+UseParalledlOldGC`  | Parallel Old      | 标记-整理 | 并行 | 老年代   | 打开此开关参数后，使用Parallel Scavenge+Parallel Old收集器组合进行垃圾收集。 |
| `-XX:+UseConcMarkSweepGC` | CMS               | 标记-清除 | 并发 | 老年代   | 打开此开关参数后，使用ParNew+CMS+Serial Old收集器组合进行垃圾收集。Serial Old作为CMS收集器出现Concurrent Mode Failure的备用垃圾收集器。 |



#### 5.4.5、通用参数  



| 参数                         | 说明                 | 默认值 | 用法                                                         |
| ---------------------------- | -------------------- | ------ | ------------------------------------------------------------ |
| `XX:MaxTenuringThreshold`    | 垃圾最大年龄         | 15     | 如果设置为0的话，则年轻代对象不经过Survivor区，直接进入年老代。对于年老代比较多的应用，可以提高效率。         如果将此值设置为一个较大值，则年轻代对象会在Survivor区进行多次复制，这样可以增加对象再年轻代的存活时间，增加在年轻代即被回收的概率 |
| `-XX:PretenureSizeThreshold` | 晋升年老代的对象大小 | 0：不管多大都是先在eden中分配内存   | 如设为10M，则超过10M的对象将不在eden区分配，而直接进入年老代。 |



#### 5.3.6、并行收集器参数  

| 参数                    | 说明                         | 默认值            | 用法                                                         |
| :---------------------- | ---------------------------- | ----------------- | ------------------------------------------------------------ |
| `-XX:ParallelGCThreads` | 指定垃圾收集的线程数量       | 默认与CPU个数相等 |                                                              |
| `-XX:GCTimeRatio`       | 置垃圾收集时间占总时间的比率 |                   | 设置系统的吞吐量。比如设为99，则GC时间比为1/1+99=1%，也就是要求吞吐量为99%。垃圾收集所花费的时间是年轻一代和老年代收集的总时间；如果没有满足吞吐量目标，则增加新生代的内存大小以尽量增加用户程序运行的时间； |
| `-XX:MaxGCPauseMillis`  | 设置垃圾回收的最长时间       |                   | 若无法满足设置值，则会优先缩小新生代大小，仍无法满足的话则会牺牲吞吐量。 |



#### 5.3.7、并发收集器参数   



| 参数                                 | 说明                                                         | 默认值 | 用法                                                         |
| :----------------------------------- | ------------------------------------------------------------ | ------ | ------------------------------------------------------------ |
| `-XX:CMSInitiatingOccupancyFraction` | 设置CMS预留内存空间                                          |        | 触发CMS收集器的内存比例。比如60%的意思就是说，当内存达到60%，就会开始进行CMS并发收集。 |
| `-XX:UseCMSCompactAtFullCollection`  | 是否在每一次CMS收集器清理垃圾后送一次内存整理。              | true   | 目前默认就是true了，默认每次GC直接压缩                       |
| `-XX:UseCMSCompactAtFullCollection`  | 上一次CMS并发GC执行过后，到底还要再执行多少次full GC才会做压缩，从而触发一次内存整理 |        |                                                              |



## 6、垃圾收集  



### 6.1、哪些需要回收 ，哪些不需要回收 

#### 6.1.1、不需要回收 

> <font color="red">程序计时器，虚拟机栈，本地方法栈</font>这3个区域都是线程所私有的，随着线程而生，而死。 关于栈的话，基本上就是在运行方法的时候开启一个栈帧。他们的内存大小(Xss)和声明周期是已知的，因此这几个区域内存分配和回收都具备确定性，不需要过多考虑回收问题，因为他们在方法结束者是线程结束，内存自然的就被回收了



#### 6.1.2、需要回收的 

>JAVA堆和方法区 则是需要被垃圾收集器回收的，方法区回收效率不高，具体看上面方法区





### 6.2、判断对象是否活着

#### 6.2.1、引用计数法 

> 解释：给对象添加一个计时器，每当引用的时候加1，当引用失效时候减1，任何时候为0的对象就是不能再被使用的。（书上说，这样表达不太好）    
>
> 
>
> **Java虚拟机没有使用它来管理内存，因为它很难解决对象之间相互引用的问题**   



##### 6.2.1.1、测试代码

```
-XX:+PrintGCDetails
```



```java
public class Jvm01ReferenceCountingGC {

    public Object instance = null;
    private static final int _1MB = 1024;

    /**
     * 占点内存，以便在日志中看清楚是否被回收
     */
    private byte[] bigSize = new byte[1 * _1MB];


    public static void main(String[] args) {
        Jvm01ReferenceCountingGC objA = new Jvm01ReferenceCountingGC();
        Jvm01ReferenceCountingGC objB = new Jvm01ReferenceCountingGC();

        objA.instance = objB;
        objB.instance = objA;

        // A引用B B引用A
        //猜想，如果是jvm采用的是引用计数法的话，如果引用计数法， 因为他们互相引用这对方，导致他们的引用计数都不为0，
        System.gc(); //垃圾收集器回收内存
        //结果：JVM的内存由6676K->400K说明了a,b两个对象的内存还是被回收了，说明idea的虚拟机并不是通过引用计数法来判断对象是否存活。
    }

```

##### 6.1.2、idea查看GC日志



```
[GC (System.gc()) [PSYoungGen: 3901K->1112K(75776K)] 3901K->1120K(249344K), 0.0013425 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
[Full GC (System.gc()) [PSYoungGen: 1112K->0K(75776K)] [ParOldGen: 8K->917K(173568K)] 1120K->917K(249344K), [Metaspace: 3206K->3206K(1056768K)], 0.0054112 secs] [Times: user=0.00 sys=0.00, real=0.01 secs] 
Heap
 PSYoungGen      total 75776K, used 1951K [0x000000076b600000, 0x0000000770a80000, 0x00000007c0000000)
  eden space 65024K, 3% used [0x000000076b600000,0x000000076b7e7c68,0x000000076f580000)
  from space 10752K, 0% used [0x000000076f580000,0x000000076f580000,0x0000000770000000)
  to   space 10752K, 0% used [0x0000000770000000,0x0000000770000000,0x0000000770a80000)
 ParOldGen       total 173568K, used 917K [0x00000006c2200000, 0x00000006ccb80000, 0x000000076b600000)
  object space 173568K, 0% used [0x00000006c2200000,0x00000006c22e5478,0x00000006ccb80000)
 Metaspace       used 3213K, capacity 4496K, committed 4864K, reserved 1056768K
  class space    used 304K, capacity 388K, committed 512K, reserved 1048576K


```



<font color="red"> 这就说明JDK8的HotSpot虚拟机并没有采用引用计数算法来标记内存，它对上述代码中的两个死亡对象的引用进行了回收。( 1120K->917K  因为内存变小，肯定是回收了，要不然能变么) 具体看下面</font>



#### 6.2.2、可达性分析算法 

> 解释:这个算法的基本思路就是通过一系列名为GC Roots的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链(Reference Chain)，当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的，下图对象object5, object6, object7虽然有互相判断，但它们到GC Roots是不可达的，所以它们将会判定为是可回收对象。

![WX20180409-141558@2x](https://raw.githubusercontent.com/HealerJean/HealerJean.github.io/master/blogImages/WX20180409-141558@2x.png)

    ##### 3.2.2.1、可以作为GC Roots的对象包括下面几种 

```
虚拟机栈(栈桢中的本地变量表)中的引用的对象
本地方法栈中JNI（Native方法）的引用的对象
方法区中的类静态属性引用的对象（方法区的回收）
方法区中的常量引用的对象（方法区的回收）
```



### 6.3、垃圾收集一定非死不可吗 



> 即使在可达性分析算法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑”阶段，<font color="red">  要真正宣告一个对象死亡，至少要经历两次标记过程</font>:

1、如果对象在进行可达性分析后发现没有与GC Roots 相连接的引用链，那它将会被第一次标记并且进行一次筛选，       

2、第二次筛选的条件是此对象是否有必要执行finalize() 方法。**当对象没有覆盖finalize() 方法，或者finalize() 方法已经被虚拟机调用过**，虚拟机将这两种情况都视为“没有必要执行”。这里理解吧，就是说finalize中添加的方法，有可能会影响对象的生命（可以在这个里面救活，如果不救的话，都会执行垃圾收集器）     

   

当一个对象可被回收时，如果需要执行该对象的 finalize() 方法， 那么就有可能在该方法中让对象重新被引用，从而实现自救。 **自救只能进行一次**，如果回收的对象之前调用了 finalize() 方法自救，后面回收时不会调用 finalize() 方法。   



```java
package com.hlj.jvm.GC;

/*
 * @Description
 * @Author HealerJean
 * @Date 2018/4/9  下午3:30.
 *
 *此代码演示了两点
 * 对象可以在GC时自我拯救
 * 这种自救只会有一次，因为一个对象的finalize方法只会被自动调用一次
 * */
public class FinalizeEscapeGC {
    public static FinalizeEscapeGC SAVE_HOOK=null;
    public void isAlive(){
        System.out.println("yes我还活着");
    }

    public void finalize() throws Throwable{
        super.finalize();
        System.out.println("执行finalize方法");
        FinalizeEscapeGC.SAVE_HOOK=this;//自救
    }

    public static void main(String[] args) throws InterruptedException{
        SAVE_HOOK=new FinalizeEscapeGC();


        //对象的第一次回收
        SAVE_HOOK=null;
        System.gc();
        //因为finalize方法的优先级很低所以暂停0.5秒等它
        Thread.sleep(500);
        if(SAVE_HOOK!=null){
            SAVE_HOOK.isAlive();
        }else{
            System.out.println("no我死了");
        }


        //下面的代码和上面的一样，但是这次自救却失败了，因为finalize方法已经调用过一次，而且它只能执行一次
        //对象的第二次回收
        SAVE_HOOK=null;
        System.gc();
        Thread.sleep(500);
        if(SAVE_HOOK!=null){
            SAVE_HOOK.isAlive();
        }else{
            System.out.println("no我死了");
        }
    }
}
```



**运行结果，说明第一次成功逃脱，finalize为对象逃脱的最后一次机会**

```
执行finalize方法
yes我还活着
no我死了
```



### 6.4、垃圾收集算法





**解释：不同平台的虚拟机操作内存的方法是不同的，这里主要介绍下几种算法的思想和发展过程**



#### 6.4.1、标记-清除算法



> 很明显，两个阶段，标记和清除踏实最基础的算法，因为后续的手机算法都是基于这种思路并对他的不足进行改进而得到的
> 不足有两处
> 1、效率问题：这两个过程效率都不高
> 2、空间问题：标记清除会产生大量不连续的碎片，碎片太多费配给大的对象的时候，无法找到连续的控件而不得不触发另一次垃圾收集动作

![WX20180409-165031@2x](https://raw.githubusercontent.com/HealerJean/HealerJean.github.io/master/blogImages/WX20180409-165031@2x.png)

#### 6.4.2、复制算法 



> 为了解决上面的效率问题，就出现了复制，它将内存分为大小相等的两块，每次只使用其中一块，`当这一块的内存满了`，就会将里面活着的对象复制到另一块上面，然后再把已经使用过的空间一次清理掉（牛逼了，相当于的夫妻二人打架，满了就跑）
>
> 这样就不需要考虑是否存在碎片了，但是但是，它他妈的把内存缩小了一半，这代价太高了



![WX20180409-165738@2x](https://raw.githubusercontent.com/HealerJean/HealerJean.github.io/master/blogImages/WX20180409-165738@2x.png)

##### 6.4.2.1、使用

> 现在的商业虚拟机都采用这种收集算法手机`新生代`，IBM公司研究到其实新生代中的对象98%都是早上出生，晚上就挂了。所以其实不需要1：1来配置，而是分成3块，一块较大的和两块较小的 比为8：1：1。       
>
> 
>
> 每次使用的时候，都是使用一个快大的和一块小的，当垃圾收集器回收的时候，就会把这两个上面存活的对象放到另外一个小的上面。然后清理刚刚的那两个空间。 这个时候，如果继续使用的话，就会继续放到大的上面。也就是说，只会浪费10%的空间   
>
> 从实际出发，其实我们不能保证每次都只有10%的对象存活，但是当它这个小的空间不够用的时候，会依赖其他内存进行分配担保。这个时候这些对象就会进入`老年代`。关于担保后面讲吧，哈哈，是不是很简单呢



#### 6.4.3、标记-整理算法

> ​     <font color="red">  复制算法在存活率特别高的时候，效率就会降低，更关键的是，老年代存活率高，假如所有对象对100%存活，那么需要有额外的空间来进行担保。所以在老年代一般不能使用复制算法。</font>       老人不是喜欢收拾东西吗，哈哈，标记整理吧    
>
> 
>
> 这里不是讲标记的对象之间进行清理，而是先将可用的对象都像一边移动，然后之间清理掉除它以外的内容

![WX20180409-171221@2x](https://raw.githubusercontent.com/HealerJean/HealerJean.github.io/master/blogImages/WX20180409-171221@2x.png)



#### 6.4.4、分代收集算法  



> 当前商业虚拟机都采用这种算法来收集，这种算法将对象存活周期的不同而将Java堆分为新生代和老年代，  



1. **新生代总每次都有大量的对象死去，只有少量存活，就使用复制算法，这样就付出存活少量对象的复制成本就可以完成收集，**

   

2. **老年代因为存活率高，没有额外的空间为它担保就必须使用标记-清除或者是标记-整理算法。**



### 6.5、垃圾收集器 



#### 6.5.1、关注点：

@：停顿时间 （垃圾收集器垃圾的时候用户线程的停顿时间），**停顿时间越短就适合需要与用户交互的程序；良好的响应速度能提升用户体验；**       

@：吞吐量：**高吞吐量则可以高效率地利用CPU时间，尽快完成运算的任务；主要适合在后台计算而不需要太多交互的任务；**      

@：覆盖区（Footprint）：**在达到前面两个目标的情况下，尽量减少堆的内存空间；可以获得更好的空间局部性；**



***响应时间*是提交请求和返回该请求的响应之间使用的时间。示例包括：**

1、**数据库**查询花费的时间     

2、将字符回显到终端上花费的时间     

3、访问 Web 页面花费的时间

***吞吐量*是对单位时间内完成的工作量的量度。示例包括：**

1、每分钟的数据库事务       

2、每秒传送的文件千字节数    

3、每秒读或写的文件千字节数    

4、每分钟的 Web 服务器命中数

```
一个例子，比如一个理发店，原先只有一个理发师，因为穷，只买的一张理发椅子，和一个长凳用来方便等待的人休息。理发师一次只能处理一个客户，其他等待的用户显得很不耐烦，外面打算进来理发的人也放弃了这家店理发的打算。。。   

有一天，理发师有钱了，他多买了2个理发椅子，这样，他可以同时给3个人理发，当其中一个人理到一定阶段需要调整或者定型的时候，他就转到另外一个客户去修剪头发，依次类推，这样，他发现一天他可以理的人数比以前增多了，但是还会有一些后来的客户抱怨等待时间太长。   

后来，理发师打算招聘2名学徒帮助他一起干活，这样，他发现每天的理发效率增加了将近2倍，而且客户的等待时间明显也减少了许多。但是成本增多了，理发用具，洗发水，发工资，这让他觉得开个理发店也要精打细算：）
```



#### 6.5.2、垃圾收集器的划分  



> 如果收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体表现，Java虚拟机堆垃圾收集器如何实现并没有任何规定，因此不同的厂家，不同版本的虚拟机所提供的垃圾收集器可能会有很大差别，并且一般都是提供参数，用户根据自己的特定和要求组合出各个年代所用的收集器。   



##### 6.5.2.1、串行、并行、并发垃圾收集的区别  



1、串行 

> ​	**单线程收集，进行垃圾收集时，必须暂停所有工作线程，直到完成；即会"Stop The World"； 相当于是妈妈在打扫房间，让我们乖乖在凳子上站着，等妈妈打扫完成。这种在用户不可见的情况下把用户正常的工作的线程全部关掉，这对于很多应用来说是不能够接受的**  



2、并行（Parallel）

> **指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态；如`ParNew`、`Parallel Scavenge`、`Parallel Old`；**



3、并发（Concurrent）

> **指用户线程与垃圾收集线程同时执行（但不一定是并行的，可能会交替执行）；用户程序在继续运行，而垃圾收集程序线程运行于另一个CPU上；     如CMS、G1（也有并行）；**  



##### 6.5.2.2、收集器的搭配使用 



@：新生代收集器：Serial、Parallel Scavenge；ParNew、      

@：老年代收集器：Serial Old、Parallel Old、CMS；    

@：整堆收集器：G1；



![WX20180411-142826@2x](https://raw.githubusercontent.com/HealerJean/HealerJean.github.io/master/blogImages/WX20180411-142826@2x.png)



#### 6.5.3、垃圾收集器

 

##### 6.5.3.1、Serial收集器 (串行收集器)

###### 6.5.3.1.1、收集对象：新生代  

###### 6.5.3.1.2、采用算法：复制算法

###### 6.5.3.1.3、JVM参数

```java
 -XX:+UseSerialGC：   添加该参数来显式的使用串行垃圾收集器；
```



###### 6.5.3.1.4、使用说明

> ​	**进行垃圾收集时，必须暂停所有工作线程，直到完成； 相当于是妈妈在打扫房间，让我们乖乖在凳子上站着，等妈妈打扫完成。这种在用户不可见的情况下把用户正常的工作的线程全部关掉，这对于很多应用来说是不能够接受的**       



1、它现在依然是`client模式下的虚拟机默认新生代的收集器`，简单而且高效，因为它是单线程的，没有线程加护的开销，专心做事	**总之 ：Serial垃圾收集器在client模式下的虚拟机来说是一个不错的选择**。      

**2、在用户的桌面应用场景中，分配给虚拟机的内存不会很大，停顿时间非常少，只要这种听得不是频繁发生。这是可以接受的**



##### 6.5.3.2、ParNew收集器    (并行收集器)

###### 6.5.3.2.1、收集对象：新生代  

###### 6.5.3.2.2、采用算法：复制算法

###### 6.5.3.2.3、JVM参数  

```
"-XX:+UseParNewGC"：强制指定使用ParNew；    
"-XX:ParallelGCThreads"：指定垃圾收集的线程数量，ParNew默认开启的收集线程与CPU的数量相同；
```

###### 6.5.3.2.4、使用说明

1、其实它是serial的多线程版本，与serial相比并没有太多的创新之处，<font color ="red">但是它是server模式下迅疾中首选的新生代收集器，但是不是默认的哦，其中有一个性能更重要的原因是，除了serial外，目前只有它能够CMS垃圾收集器配合工作</font>       

2、指定使用CMS后，会默认使用ParNew作为新生代收集器；  



##### 6.5.3.3、parallel Scavenge ((并行收集器，吞吐量收集器)  

###### 6.5.3.3.1、收集对象：新生代  

###### 6.5.3.3.2、采用算法：复制算法

###### 6.5.3.3.3、JVM参数   

```java
-XX:+UseParallelGC   明确指定使用Parallel Scavenge收集器
```

###### 6.5.3.3.4、使用说明     

> **它的特点是与其他的垃圾收集器关注点不同，CMS等收集器所关注的是尽可能缩短垃圾收集器收集时候的用户线程的停顿时间，但是它的目标是达到一个可控制的吞吐量，**  



是JAVA虚拟机在Server模式下的默认值（比如我的电脑就是），  使用Server模式后，`JDK1.5`及之前，`Java`虚拟机使用`Parallel Scavenge`收集器（新生代）+ Serial Old收集器（老年代）   ` JDK1.6`之后有`Parallel Old`收集器可搭配  的收集器组合进行内存回收。     



1、吞吐量   ：垃圾收集时间越少，吞吐量余越高，**<font color="red">（高吞吐量目标，即减少垃圾收集时间，让用户代码获得更长的运行时间）</font>**

> 公式： 吞吐量=运行用户代码时间  /（运行用户代码时间+垃圾收集时间）  
>
> 比如虚拟机总共运行了100分支，垃圾收集花掉1分钟，那么吞吐量就是99%  高的吞吐量就是可以高效的利用cpu时间      



2、使用场景   ：主要适应主要适合在后台运算而不需要太多交互的任务，不是与用户交互

> ​    <font color="red"> 
> 比如需要与用户交互的程序，良好的响应速度能提升用户的体验；而高吞吐量则可以最高效率地利用CPU时间，尽快地完成程序的运算任务等。例如，那些执行批量处理、订单处理、工资支付、科学计算的应用程序； </font>        





###### 6.5.3.3.5、配合使用的JVM参数 

1、`-XX:MaxGCPauseMillis` ：设置每次年轻代垃圾回收的最长时间（更关注垃圾收集停顿时间）

> "-XX:MaxGCPauseMillis" 默认值是 200 毫秒    
>
> 垃圾收集器将尽可能的保证内存回收花费的时间不超过该值，不过千万不要认为把这个参数的值设置的小一点就会让垃圾收集速度变得快。 
>
> 但也可能会使得吞吐量下降；因为可能导致垃圾收集发生得更频繁，GC停顿时间的缩短是以牺牲吞吐量和和新生代空间来换取的，假如我们将这个值设置的比较小，JVM为了达到这个要求会把生代调小一下，比如由500M调成40M0，收集300M肯定比收集500M快吧，但是这也让垃圾收集变的更加频繁  。原来10秒收集一次，停顿100毫秒。现在变成5秒收集一次，每次停顿70毫秒 ，  停顿时间在下降但是吞吐量也在下降,导致youngGC的频率大大增高。所以我们一般并不设定这个参数 
>
> 



2、`-XX:GCTimeRatio`：设置垃圾收集时间占总时间的比率（更关注吞吐量 ）

> 这个值相当于就是一个吞吐量的值，默认是99  ，就是允许1%（1/1+99） 的垃圾收集时间      
>
> 垃圾收集所花费的时间是年轻一代和老年代收集的总时间；如果没有满足吞吐量目标，则增加新生代的内存大小以尽量增加用户程序运行的时间；





##### 6.5.3.4、Serial Old收集器 （串行收集器）

###### 6.5.3.4.1、收集对象：老年代  

###### 6.5.3.4.2、采用算法：标记-整理

###### 6.5.3.4.3、JVM参数   

###### 6.5.3.4.4、使用说明 

> - **主要用于Client模式，在JDK1.5及之前，与Parallel Scavenge收集器搭配使用（JDK1.6有Parallel Old收集器可搭配）**   
>
> - **作为CMS收集器的后备预案，在并发收集发生Concurrent Mode Failure时使用**



    

##### 6.5.3.4、Parallel Old收集器  （并行收集器）

###### 6.5.3.4.1、收集对象：老年代  

###### 6.5.3.4.2、采用算法：标记-整理

###### 6.5.3.4.3、JVM参数   

###### 6.5.3.4.4、使用说明 

> **JDK1.6及之后用来代替老年代的Serial Old收集器， 特别是在Server模式，多CPU的情况下；这样在注重吞吐量以及CPU资源敏感的场景，就有了Parallel Scavenge加Parallel Old收集器的"给力"应用组合；**

 

##### 6.5.3.5、`CMS`收集器（Concurrent Mark Sweep）  

###### 6.5.3.5.1、收集对象：老年代  

###### 6.5.3.5.2、采用算法：标记-清除

###### 6.5.3.5.3、JVM参数   

###### 6.5.3.5.4、使用说明  

> **以获取最短回收停顿时间为目标  ， 并发收集(不进行压缩操作，产生内存碎片)、低停顿， 需要更多的内存（看后面的缺点）**

![1576228989934](https://raw.githubusercontent.com/HealerJean123/HealerJean123.github.io/master/blogImages/1576228989934.png)



**使用场景**：   

与用户交互较多的场景；希望系统停顿时间最短，注重服务的响应速度；以给用户带来较好的体验；如常见WEB、B/S系统的服务器上的应用  。*CMS收集器*是一种以获取最短回收停顿时间为目标的收集器；





###### 6.5.3.5.5、CMS过程

**1、初始标记：**   

> 在这个阶段，需要虚拟机停顿正在执行的任务，官方的叫法`STW(Stop The Word)`。这个过程从垃圾回收的"根对象"开始         
>
> ​     有两个目标一是标记老年代中所有的GC Roots；二是标记被年轻代中活着的对象引用的对象。  **仅标记`GC Roots`能直接关联到的对象，这样极大的缩短了初始标记时间；** 



![1576229270539](https://raw.githubusercontent.com/HealerJean123/HealerJean123.github.io/master/blogImages/1576229270539.png)

**2、并发标记**  

> 。该阶段可以划分为三小阶段：`并发标记 -> 并发预清理 -> 并发可中止预清理`三个小阶段。

**2.1、并发标记**

> **对于初始标记后的所有对象，开始向下遍历，标记，此时由于`GC root`已经确定，GC线程已经可以和工作线程同时进行，此时已经不用`STW`。**
>
> 
>
> 这个阶段会遍历整个老年代并且标记所有存活的对象，从“初始化标记”阶段找到的`GC Roots`开始。并发标记的特点是和应用程序线程同时运行。**并不是老年代的所有存活对象都会被标记，因为标记的同时应用程序会改变一些对象的引用等。**   
>
> **并发标记阶段，应用程序的线程和并发标记的线程并发执行，所以用户不会感受到停顿。**    

![1576229435530](https://raw.githubusercontent.com/HealerJean123/HealerJean123.github.io/master/blogImages/1576229435530.png)



**2.1、并发预清理**   

> 正如上一个阶段所说，对象的引用在用户应用运行过程中一直在产生变化，那么只要引用发生变化，JVM中将用于存储变化对象的这部分堆空间（Card）标记为脏的（dirty）（这一过程也叫做Card Marking）。



![1577091483799](https://raw.githubusercontent.com/HealerJean123/HealerJean123.github.io/master/blogImages/1577091483799.png)





**该阶段称为预清理阶段，在该阶段结束时，会把脏的Card给清理为干净的状态，如下图所示：**   



  ![1577091600832](https://raw.githubusercontent.com/HealerJean123/HealerJean123.github.io/master/blogImages/1577091600832.png)



**2.2、并发可终止预清理**

> 这个阶段尝试着去承担下一个阶段Final Remark阶段足够多的工作。这个阶段持续的时间依赖好多的因素，由于这个阶段是重复的做相同（并发标记）的事情直到发生abort的条件（比如：重复的次数、多少量的工作、持续的时间等等）之一才会停止。     



**ps:此阶段最大持续时间为5秒，之所以可以持续5秒，另外一个原因也是为了期待这5秒内能够发生一次ygc，清理年轻带的引用，是的下个阶段的重新标记阶段，扫描年轻带指向老年代的引用的时间减少；**



  

**3、重新标记**   

> 但是由于并发标记阶段时间较长，在并发标记阶段还会有新的垃圾出现，    
> **为了修正并发标记期间因用户程序继续运作而导致标记变动的那一部分对象的标记记录,**发现那些被并发标记错过的对象；需要"Stop The World"。   
>
> 
>
> 因为并发标记是和应用程序并发执行的，在标记线程完成对某个对象的跟踪那刻，应用程序可能对对象进行了更新。   **且停顿时间比初始标记稍长，但远比并发标记短；采用多线程并行执行来提升效率；** 



**4、并发清除** 

> **收集那些在标记阶段没有标记的对象，**消亡对象所占的空间会被添加到释放列表里用于重新分配注意：存活的对象不会被移动。



**整个过程中耗时最长的并发标记和并发清除都可以与用户线程一起工作；所以总体上说，CMS收集器的内存回收过程与用户线程一起并发执行；并发收集、低停顿**





###### 6.5.3.5.5、缺点  



**1、容易产生空间碎片，导致无法分配大对象，标记-清除造成**      

`CMS回收器`采用的基础算法是`Mark-Sweepbi`标记清理。所有CMS不会整理、压缩堆空间。这样就会有一个问题：经过`CMS`收集的堆会产生空间碎片。<font color="red">  `CMS`不对堆空间整理压缩节约了垃圾回收的停顿时间</font>，**但也带来的堆空间的浪费。为了解决堆空间浪费问题**，`CMS回收器`不再采用简单的指针指向一块可用堆空间来为下次对象分配使用。而是把一些未分配的空间汇总成一个列表，当JVM分配对象空间的时候，会搜索这个列表找到足够大的空间来hold住这个对象。产生大量不连续的内存碎片会导致分配大内存对象时，无法找到足够的连续内存，从而需要提前触发另一次Full GC动作     



**2、需要更多的CPU资源    并发造成**      

为了让应用程序不停顿，`CMS线程和应用程序线程并发执行`，这样就需要有更多的CPU   ，**CMS收集器对CPU资源非常敏感是指在并发阶段**，它虽然不会导致用户线程停顿，但因为占用一部分CPU资源，还是会导致应用程序变慢（可以处理的数据就会变慢，用户线程相当于有点停顿），总吞吐量降低。并且，重新标记阶段，为空保证`STW`快速完成，也要用到更多的甚至所有的CPU资源。当然，多核多CPU也是未来的趋势！    

**CMS默认启动的回收线程数是（CPU数量+3）/4，也就是当CPU在4个以上时，并发回收时垃圾收集线程不少于25%的CPU资源，随着CPU数量的增加而下降。**     



**3、无法处理浮动垃圾,可能出现"Concurrent Mode Failure"失败， 并发造成**       

浮动垃圾（Floating Garbage）： 在并发清除时，由于CMS并发清理阶段用户线程还在运行着，伴随程序运行自然就还会有新的垃圾不断产生（一边打扫房间，一遍丢新的垃圾），这部分垃圾出现在标记过程之后，CMS无法在当次收集中处理掉它们，只好留待下一次GC时再清理掉。这一部分垃圾就称为“浮动垃圾”。       

 这使得并发清除时需要预留一定的内存空间，不能像其他收集器在老年代几乎填满再进行收集；也要可以认为CMS所需要的空间比其他垃圾收集器大；    **如果CMS预留内存空间无法满足程序需要，就会出现一次"`Concurrent Mode Failure"`失败，而导致另一次Full GC的产生，触发serial old Gc。** **CMS的做法是老年代空间占用率达到某个阈值时触发垃圾收集，有一个参数`CMSInitiatingOccupancyFraction`设置一个百分比，表明达到这个值就进行垃圾回收**   



```
 "-XX:CMSInitiatingOccupancyFraction"：设置CMS预留内存空间；
      JDK1.5默认值为68%；
      JDK1.6变为大约92%；       
      
      老年代增长不是太快，可以适当调高参数-XX：CMSInitiatingOccupancyFraction的值来提高触发百分比，以便降低内存回收次数从而获取更好的性能        

      CMSInitiatingOccupancyFraction参数要设置一个合理的值，设置大了，再放浮动垃圾，一下子就内存满了，所以容易导致大量”concurrent mode Failure”失败，性能反而降低，因为设置的太高表示可以容纳的浮动垃圾越多。    
      设置的小了，又会增加CMS频率，所以要根据应用的运行情况来选取一个合理的值。如果发现这两个参数设置大了会导致full gc，设置小了会导致频繁的CMS GC，说明你的老年代空间过小，应该增加老年代空间的大小了。
```





###### 6.5.3.5.6、JVM参数  



1、`CMSInitiatingOccupancyFraction` 上面介绍了       

2、`UseCMSCompactAtFullCollection`   `CMSFullGCsBeforeCompaction`，减少碎片化

`UseCMSCompactAtFullCollection` 与 `CMSFullGCsBeforeCompaction` 是搭配使用的；前者目前默认就是true了，默认每次GC直接压缩,也就是关键在后者上。

`CMSFullGCsBeforeCompaction` 说的是，在上一次CMS并发GC执行过后，到底还要再执行多少次full GC才会做压缩。**默认是0，即每次full gc都对老生代进行碎片整理压缩**；这个参数就是用来配置降低full GC压缩的频率，以期减少某些full GC的暂停时间。     





## 7、JVM工具使用 



| 名称   | 全称                           | 主要作用                                                     |
| :----- | :----------------------------- | :----------------------------------------------------------- |
| jps    | jvm process status tool        | 显示指定系统内所有的hotspot虚拟机进程                        |
| jstat  | jvm statistics monitoring tool | 用于收集hotspot虚拟机各方面的运行数据                        |
| jinfo  | configuration info for java    | 实时查看和调整虚拟机的各项参数                               |
| jmap   | memory map for java            | 生成虚拟机的内存转储快照（heapdump文件）                     |
| jhat   | jvm heap dump browser          | 用于分析heapmap文件，它会建立一个http/html服务器让用户可以在浏览器上查看分析结果 |
| jstack | stack trace for java           | 显示虚拟机的线程快照，定位死循环，线程阻塞，死锁等问题       |



### 7.1、`jps` ：(jvm  process status 虚拟机进程状态)



| 命令    | 说明                                  |
| ------- | ------------------------------------- |
| jps - l | 进程号、输出主类或者jar的完全路径名、 |
| jps -v  | 输出jvm参数                           |
| jps -q  | 只显示进程号                          |



#### 7.1.1、jps -l ：进程号、输出主类或者jar的完全路径名、  



```java
package com.hlj.moudle.Jvm04_Command;
import java.util.Scanner;

public class Jvm04_01jps {

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        sc.nextLine();
    }
}

```



```shell
$ jps -l
14992 com.caucho.server.resin.Resin
16864 org.jetbrains.jps.cmdline.Launcher
15892 org.jetbrains.idea.maven.server.RemoteMavenServer
6916 org.jetbrains.jps.cmdline.Launcher
6980 sun.tools.jps.Jps
13688 org.jetbrains.kotlin.daemon.KotlinCompileDaemon
14684 com.hlj.moudle.Jvm04_Command.Jvm04_01jps
5948

$ jps -l | grep Jvm
14684 com.hlj.moudle.Jvm04_Command.Jvm04_01jps

```





#### 7.1.2、jps –v：输出jvm参数(查看已经运行的main的JVM参数)



```
-verbose:gc -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8 
```

```java
package com.hlj.moudle.Jvm04_Command;
import java.util.Scanner;

public class Jvm04_01jps {

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        sc.nextLine();
    }
}
```

```shell
$ jps -v | grep Jvm04
18228 Jvm04_01jps -Dvisualvm.id=15978156520281 -verbose:gc -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8 -javaagent:D:\programFiles\IntelliJ IDEA 2018.3.5\lib\idea_rt.jar=52554:D:\programFiles\IntelliJ IDEA 2018.3.5\bin -Dfile.encoding=UTF-8

```



#### 7.1.3、jps -q ：值显示java进程号，什么都看不出来 

```java
package com.hlj.moudle.Jvm04_Command;
import java.util.Scanner;

public class Jvm04_01jps {

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        sc.nextLine();
    }
}
```



```shell
$ jps -q
14992
15892
18228
6916
13304
13688
13628
5948

```





#### 7.1.4、使用Linux命令查看进程以及参数配置 

```shell
 ps -aux |grep scf-ma
```



```shell
[work@vm10-123-3-2 bin]$ ps -aux |grep scf-ma
work     12566  0.5  4.5 11541924 1483512 ?    Sl   Jan02  37:54 /usr/local/service/app/scf/scf-manager/jdk1.8.0_202/bin/java -Xmn256M -Xmx1024M -Xms1024M -XX:MaxPermSize=256M -XX:PermSize=256M -XX:SurvivorRatio=8 -XX:+UseConcMarkSweepGC -XX:CMSFullGCsBeforeCompaction=50 -XX:+UseCMSCompactAtFullCollection -XX:MaxTenuringThreshold=10 -verbose:gc -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -XX:+PrintGCDateStamps -XX:+PrintFlagsFinal -Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.port=8393 -Dcom.sun.management.jmxremote.ssl=false -Dcom.sun.management.jmxremote.authenticate=false -Xloggc:/usr/local/service/log/scf/scf-manager/gc.log -Xdebug -Xrunjdwp:transport=dt_socket,server=y,suspend=n,address=19137 -Dlog4j2.isThreadContextMapInheritable=true -Djava.util.logging.manager=com.caucho.log.LogManagerImpl -Djava.system.class.loader=com.caucho.loader.SystemClassLoader -Djava.endorsed.dirs=/usr/local/service/app/scf/scf-manager/jdk1.8.0_202/jre/lib/endorsed:/usr/local/service/app/scf/scf-manager/resin-pro-4.0.58/endorsed -Djavax.management.builder.initial=com.caucho.jmx.MBeanServerBuilderImpl -Djava.awt.headless=true -Dresin.home=/usr/local/service/app/scf/scf-manager/resin-pro-4.0.58 -server com.caucho.server.resin.Resin --root-directory /usr/local/service/app/scf/scf-manager/resin-pro-4.0.58 -conf ./../conf/resin.xml -server scf-manager start
```





### 7.2、`jstat` ：(JVM Statistics Monitoring Tool虚拟机统计信息监控工具)



> 用于监视虚拟机各种运行状态信息的命令行工具，可以显示本地或者是远程虚拟机进程中的类加载，内存，垃圾收集，在没有GUI图形页面，踏实运行期定位虚拟机性能的首选工具  



| 命令                     | 说明                                                         |
| ------------------------ | ------------------------------------------------------------ |
| **jstat -class**         | 用于查看类加载情况的统计，显示加载class的数量，及所占空间等信息。 |
| jstat -compiler          | JIT,查看HotSpot中即时编译器编译情况的统计                    |
| **jstat -gc**            | GC堆状态，查看JVM中堆的垃圾收集情况的统计，可以显示gc的信息，查看gc的次数，及时间。其中最后五项，分别是young gc的次数，young gc的时间，full gc的次数，full gc的时间，gc的总时间。 |
| **jstat -gccapacity**    | 各区大小，查看新生代、老生代及持久代的存储容量情况，可以显示，VM内存中三代（young,old,perm）对象的使用和占用大小 |
| jstat -gccause           | 最近一次GC统计和原因，查看垃圾收集的统计情况（这个和-gcutil选项一样），如果有发生垃圾收集，它还会显示最后一次及当前正在发生垃圾收集的原因 |
| **jstat -gcnew**         | 新区统计，查看新生代垃圾收集的情况，年轻代对象的信息         |
| **jstat -gcnewcapacity** | 新区大小，显示关于metaspace大小的统计信息。                  |
| **jstat -gcold**         | 老年代垃圾回收统计，用于查看老生代及持久代发生GC的情况，老年代对象的信息 |
| **jstat -gcoldcapacity** | 老区大小，用于查看老生代的容量，old对象的信息及其占用量      |
| jstat -gcpermcapacity    | 永久区大小，用于查看持久代的容量，perm对象的信息及其占用量   |
| **jstat -gcutil**        | GC统计汇总，查看新生代、老生代及持代垃圾收集的情况           |
| jstat -printcompilation  | HotSpot编译统计，当前VM执行的信息                            |



#### 7.2.1、`jstat -class pid` ：查看类加载情况的统计



```shell
[work@vm10-123-3-2 bin]$ ./jstat -class 12566
Loaded  Bytes  Unloaded  Bytes     Time   
 17604 34620.3        0     0.0      20.28
```



| 参数     | 说明            |
| -------- | --------------- |
| Loaded   | 加载class的数量 |
| Bytes    | 所占用空间大小  |
| Unloaded | 未加载数量      |
| Bytes    | 未加载占用空间  |
| Time     | 时间            |



#### 7.2.2、`jstat -gc  pid time num`：实时监控GC容量  



> **每3秒收集一次进程为12566 的垃圾收集状况，一共查询100次**



```shell
[work@vm10-123-3-2 bin]$ ./jstat -gc 12566 3000 100
 S0C    S1C    S0U    S1U      EC       EU        OC         OU       MC     MU    CCSC   CCSU   YGC     YGCT    FGC    FGCT     GCT   
26176.0 26176.0  0.0   1859.9 209792.0 159325.8  786432.0   168717.4  116168.0 110226.9 13108.0 12151.5    283    6.863   5      0.230    7.093
26176.0 26176.0  0.0   1859.9 209792.0 34511.3   786432.0   168717.4  116168.0 110226.9 13108.0 12151.5    283    6.863   5      0.230    7.093
26176.0 26176.0  0.0   1859.9 209792.0 34513.3   786432.0   168717.4  116168.0 110226.9 13108.0 12151.5    283    6.863   5      0.230    7.093
26176.0 26176.0  0.0   1859.9 209792.0 36273.8   786432.0   168717.4  116168.0 110226.9 13108.0 12151.5    283    6.863   5      0.230    7.093
26176.0 26176.0  0.0   1859.9 209792.0 36273.8   786432.0   168717.4  116168.0 110226.9 13108.0 12151.5    283    6.863   5      0.230    7.093
26176.0 26176.0  0.0   1859.9 209792.0 36273.8   786432.0   168717.4  116168.0 110226.9 13108.0 12151.5    283    6.863   5      0.230    7.093
26176.0 26176.0  0.0   1859.9 209792.0 36273.8   786432.0   168717.4  116168.0 110226.9 13108.0 12151.5    283    6.863   5      0.230    7.093
26176.0 26176.0  0.0   1859.9 209792.0 36275.9   786432.0   168717.4  116168.0 110226.9 13108.0 12151.5    283    6.863   5      0.230    7.093
26176.0 26176.0  0.0   1859.9 209792.0 36275.9   786432.0   168717.4  116168.0 110226.9 13108.0 12151.5    283    6.863   5      0.230    7.093
26176.0 26176.0  0.0   1859.9 209792.0 36288.9   786432.0   168717.4  116168.0 110226.9 13108.0 12151.5    283    6.863   5      0.230    7.093
26176.0 26176.0  0.0   1859.9 209792.0 36288.9   786432.0   168717.4  116168.0 110226.9 13108.0 12151.5    283    6.863   5      0.230    7.093
26176.0 26176.0  0.0   1859.9 209792.0 36288.9   786432.0   168717.4  116168.0 110226.9 13108.0 12151.5    283    6.863   5      0.230    7.093
26176.0 26176.0  0.0   1859.9 209792.0 36288.9   786432.0   168717.4  116168.0 110226.9 13108.0 12151.5    283    6.863   5      0.230    7.093
```

![1578378375256](https://raw.githubusercontent.com/HealerJean123/HealerJean123.github.io/master/blogImages/1578378375256.png)



| 参数               | 说明（单位是KB）                                             |
| ------------------ | ------------------------------------------------------------ |
| S0C、S1C、S0U、S1U | Survivor 0/1区容量（Capacity）和使用量（Used）               |
| EC、EU             | Eden区容量和使用量                                           |
| OC、OU             | 年老代容量和使用量                                           |
| MC                 | 元空间commited容量，**是commited，并不是capacity，**         |
| MU                 | 元空间used的容量                                             |
| CCSC               | 压缩类空间class space 中 commited容量， **是commited，并不是capacity** |
| CCSU               | 压缩类空间class space 中 used容量                            |
| YGC、YGCT          | 年轻代GC次数和GC耗时                                         |
| FGC、FGCT          | Full GC次数和Full GC耗时                                     |
| GCT                | GC总耗时                                                     |





#### 7.2.3、`jstat -gcutil  pid time num`：实时监控GC百分比

> **每3秒收集一次进程为12566 的垃圾收集状况，一共查询100次**



```shell
[work@vm10-123-3-2 bin]$ ./jstat -gcutil 12566 3000 100
  S0     S1     E      O      M     CCS    YGC     YGCT    FGC    FGCT     GCT   
  0.00   7.11  66.31  21.45  94.89  92.70    283    6.863     5    0.230    7.093
  0.00   7.11  66.31  21.45  94.89  92.70    283    6.863     5    0.230    7.093
  0.00   7.11  66.31  21.45  94.89  92.70    283    6.863     5    0.230    7.093
  0.00   7.11  66.31  21.45  94.89  92.70    283    6.863     5    0.230    7.093
  0.00   7.11  66.31  21.45  94.89  92.70    283    6.863     5    0.230    7.093
  0.00   7.11  66.31  21.45  94.89  92.70    283    6.863     5    0.230    7.093
  0.00   7.11  66.31  21.45  94.89  92.70    283    6.863     5    0.230    7.093
  0.00   7.11  66.31  21.45  94.89  92.70    283    6.863     5    0.230    7.093
  0.00   7.11  66.31  21.45  94.89  92.70    283    6.863     5    0.230    7.093
  0.00   7.11  66.32  21.45  94.89  92.70    283    6.863     5    0.230    7.093
```

![1578378744168](https://raw.githubusercontent.com/HealerJean123/HealerJean123.github.io/master/blogImages/1578378744168.png)



| 参数  | 说明                                                         |
| ----- | ------------------------------------------------------------ |
| S0 S1 | Survivor 0/1 占用百分比                                      |
| E     | Eden 所占百分比                                              |
| O     | 老年代 所占百分比                                            |
| M     | 元数据区已使用的占当前容量百分比，MC/MU计算出来的            |
| CCS   | 压缩类空间使用的占当前容量百分比，NoKlass Metaspace的使用率，也就是CCSU/CCSC算出来的 |
| YGC   | 年轻代GC次数                                                 |
| YGCT  | 年轻代GC时间                                                 |
| FGC   | 老年代GC次数                                                 |
| FGCT  | 老年代GC时间                                                 |
| GCT   | GC总耗时                                                     |



#### 7.2.4、`jstat -gcnewcapacity pid`: 年轻代内存统计    



```shell
[work@vm10-123-3-2 bin]$ ./jstat -gcnewcapacity 12566
  NGCMN      NGCMX       NGC      S0CMX     S0C     S1CMX     S1C       ECMX        EC      YGC   FGC 
  262144.0   262144.0   262144.0  26176.0  26176.0  26176.0  26176.0   209792.0   209792.0   284     5
```

![1578381601165](https://raw.githubusercontent.com/HealerJean123/HealerJean123.github.io/master/blogImages/1578381601165.png)  



| 参数         | 说明                     |
| ------------ | ------------------------ |
| NGCMN、NGCMX | 年轻代最小容量、最大容量 |
| NGC          | 当前年轻代容量           |
| S0CMX、S1CMX | Survivor0/1 最大容量     |
| S0C、S1C     | 当前Survivor0/1 容量     |
| ECMX         | Eden最大容量             |
| EC           | 当前Eden容量             |
| YGC          | 年轻代gc次数             |
| FGC          | 老年代gc次数             |



#### 7.2.5 、`jstat -gcnew pid`：年轻代垃圾回收统计

```shell
[work@vm10-123-3-2 bin]$ ./jstat -gcnew 12566
 S0C    S1C    S0U    S1U   TT MTT  DSS      EC       EU     YGC     YGCT  
26176.0 26176.0    0.0 1859.9 10  10 13088.0 209792.0 209614.9    283    6.863
```

| 参数     | 说明                                   |
| -------- | -------------------------------------- |
| S0C、S1C | Survivor 0/1 容量大小                  |
| S0U、S1U | Survivor 0/1 使用量大小                |
| TT       | 对象在年轻代存活的次数                 |
| MTT      | 对象在新生代存活的最大次数             |
| DSS      | 当前期望的Survivor大小（伊甸园区已满） |
| EC、EU   | Eden 容量和使用量大小                  |
| YGC      | 年轻代gc次数                           |
| YGCT     | 年轻代gc时消耗时间                     |



#### 7.2.6、`jstat -gcoldcapacity  pid`：老年代内存统计  



```shell
[work@vm10-123-3-2 bin]$ ./jstat -gcoldcapacity 12566   
   OGCMN       OGCMX        OGC         OC       YGC   FGC    FGCT     GCT   
   786432.0    786432.0    786432.0    786432.0   284     5    0.230    7.117
```



| 参数         | 说明                     |
| ------------ | ------------------------ |
| OGCMN、OGCMX | 老年代最小容量、最大容量 |
| OGC          | 老年代当前容量           |
| OC           | 老年代当前容量           |
| YGC          | 年轻代gc次数             |
| FGC          | 老年代gc次数             |
| FGCT         | 老年代gc时消耗时间       |
| GCT          | gc消耗总时间             |



#### 7.2.7、`jstat -gcold  pid `：老年代垃圾回收统计  

```shell
[work@vm10-123-3-2 bin]$ ./jstat -gcold 12566        
   MC       MU      CCSC     CCSU       OC          OU       YGC    FGC    FGCT     GCT   
116168.0 110279.2  13108.0  12151.5    786432.0    168717.5    284     5    0.230    7.117
```



| 参数   | 说明                                                         |
| ------ | ------------------------------------------------------------ |
| MC     | 元空间commited容量，**是commited，并不是capacity**           |
| MU     | 元空间used的容量                                             |
| CCSC   | 压缩类空间class space 中 commited容量， **是commited，并不是capacity**** |
| CCSU   | 压缩类空间class space 中 used容量                            |
| OC、OU | 老年代容量、老年代使用容量                                   |
| YGC    | 年轻代gc次数                                                 |
| FGC    | 老年代gc次数                                                 |
| FGCT   | 老年代gc时消耗时间                                           |
| GCT    | gc消耗总时间                                                 |



#### 7.2.8、`jstat -gcmetacapacity   pid`：元数据内存统计 



```shell
[work@vm10-123-3-2 bin]$ ./jstat -gcmetacapacity 12566
   MCMN       MCMX        MC       CCSMN      CCSMX       CCSC     YGC   FGC    FGCT     GCT   
       0.0  1153024.0   116168.0        0.0  1048576.0    13108.0   284     5    0.230    7.117
```



| 参数   | 说明                                                         |
| ------ | ------------------------------------------------------------ |
| MCMN   | 最小元数据容量（0）                                          |
| MCMX   | 最大元数据容量：元空间 reserved值                            |
| MC     | 元空间commited容量，**是commited，并不是capacity**           |
| CCSM、 | 最小压缩类空间容量(0)                                        |
| CCSMX  | 最大压缩类空间容量（压缩类空间class space 中 reserved的内存大小） |
| CCSC   | 压缩类空间class space 中 commited容量， **是commited，并不是capacity** |
| YGC    | 年轻代gc次数                                                 |
| FGC    | 老年代gc次数                                                 |
| FGCT   | 老年代gc时消耗时间                                           |
| GCT    | gc消耗总时间                                                 |



### 7.3、`jstack  pid`：显示虚拟机的线程快照，定位死循环、线程阻塞、死锁等问题 



```shell
$ jstack 21048
```



#### 7.3.1、死循环 

```java
public class Jvm04_01jps {

    public static void main(String[] args) throws InterruptedException {
       method();
    }

    public static void method(){
        while (true) {

        }
    }
}
```

![1578384566064](https://raw.githubusercontent.com/HealerJean123/HealerJean123.github.io/master/blogImages/1578384566064.png)





#### 7.3.2、object.wait（）， 

```java
class TestTask implements Runnable {
    @Override
    public void run() {

        synchronized (this) {
            try {
                //等待被唤醒
                wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }

    }
}

public class Test {

    public static void main(String[] args) throws InterruptedException {

        ExecutorService ex = Executors.newFixedThreadPool(1);
        ex.execute(new TestTask());

    }
}
```



![1578384656158](https://raw.githubusercontent.com/HealerJean123/HealerJean123.github.io/master/blogImages/1578384656158.png)



#### 7.3.3、死锁 

```java
class TestTask implements Runnable {
    private Object obj1;
    private Object obj2;
    private int order;

    public TestTask(int order, Object obj1, Object obj2) {
        this.order = order;
        this.obj1 = obj1;
        this.obj2 = obj2;
    }

    public void test1() throws InterruptedException {
        synchronized (obj1) {
            //建议线程调取器切换到其它线程运行
            Thread.yield();
            synchronized (obj2) {
                System.out.println("test。。。");
            }

        }
    }
    public void test2() throws InterruptedException {
        synchronized (obj2) {
            Thread.yield();
            synchronized (obj1) {
                System.out.println("test。。。");
            }

        }
    }

    @Override
    public void run() {

        while (true) {
            try {
                if(this.order == 1){
                    this.test1();
                }else{
                    this.test2();
                }
                
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }

    }
}

public class Test {

    public static void main(String[] args) throws InterruptedException {
        Object obj1 = new Object();
        Object obj2 = new Object();

        ExecutorService ex = Executors.newFixedThreadPool(10);
        // 起10个线程
        for (int i = 0; i < 10; i++) {
            int order = i%2==0 ? 1 : 0;
            ex.execute(new TestTask(order, obj1, obj2));
        }

    }
}
```



![1578384692827](https://raw.githubusercontent.com/HealerJean123/HealerJean123.github.io/master/blogImages/1578384692827.png)



### 7.4、jinfo：实时查看Java系统和调整JVM的各项参数

>jinfo 是 JDK 自带的命令，可以用来查看正在运行的 java 应用程序的扩展参数，包括Java System属性和JVM命令行参数；也可以动态的修改正在运行的 JVM 一些参数。



#### 7.4.1、`jinfo  pid`：输出当前 jvm 进程的全部参数和系统属性 



```shell
[work@vm10-123-3-2 bin]$ ./jinfo 12566
Attaching to process ID 12566, please wait...
Debugger attached successfully.
Server compiler detected.
JVM version is 25.202-b08
Java System Properties:

com.sun.management.jmxremote.authenticate = false
java.runtime.name = OpenJDK Runtime Environment
java.vm.version = 25.202-b08
sun.boot.library.path = /usr/local/service/app/scf/scf-manager/jdk1.8.0_202/jre/lib/amd64
javax.management.builder.initial = com.caucho.jmx.MBeanServerBuilderImpl
java.vendor.url = https://adoptopenjdk.net/
java.vm.vendor = Oracle Corporation
path.separator = :
java.rmi.server.randomIDs = true
file.encoding.pkg = sun.io
java.vm.name = OpenJDK 64-Bit Server VM
sun.os.patch.level = unknown
sun.java.launcher = SUN_STANDARD
user.country = US
user.dir = /usr/local/service/app/scf/scf-manager/resin-pro-4.0.58/bin
java.vm.specification.name = Java Virtual Machine Specification
com.sun.management.jmxremote.port = 8393
java.runtime.version = 1.8.0_202-b08
java.awt.graphicsenv = sun.awt.X11GraphicsEnvironment
os.arch = amd64
java.endorsed.dirs = /usr/local/service/app/scf/scf-manager/jdk1.8.0_202/jre/lib/endorsed:/usr/local/service/app/scf/scf-manager/resin-pro-4.0.58/endorsed
line.separator = 

java.io.tmpdir = /tmp
java.vm.specification.vendor = Oracle Corporation
java.util.logging.manager = com.caucho.log.LogManagerImpl
java.naming.factory.url.pkgs = com.caucho.naming
os.name = Linux
resin.home = /usr/local/service/app/scf/scf-manager/resin-pro-4.0.58
sun.jnu.encoding = UTF-8
java.system.class.loader = com.caucho.loader.SystemClassLoader
java.library.path = /usr/local/service/app/scf/scf-manager/jdk1.8.0_202/jre/lib/amd64/server:/usr/local/service/app/scf/scf-manager/jdk1.8.0_202/jre/lib/amd64:/usr/local/service/app/scf/scf-manager/jdk1.8.0_202/jre/../lib/amd64:/usr/local/service/app/scf/scf-manager/resin-pro-4.0.58/libexec64:/usr/local/service/app/scf/scf-manager/jdk1.8.0_202/jre/lib/amd64/server:/usr/local/service/app/scf/scf-manager/jdk1.8.0_202/jre/lib/amd64:/usr/local/service/app/scf/scf-manager/jdk1.8.0_202/lib/amd64:/usr/java/packages/lib/amd64:/usr/lib64:/lib64:/lib:/usr/lib
java.specification.name = Java Platform API Specification
java.class.version = 52.0
sun.management.compiler = HotSpot 64-Bit Tiered Compilers
os.version = 3.10.0-514.26.2.el7.x86_64
user.home = /home/work
user.timezone = 
java.awt.printerjob = sun.print.PSPrinterJob
file.encoding = UTF-8
java.specification.version = 1.8
user.name = work
java.class.path = /usr/local/service/app/scf/scf-manager/resin-pro-4.0.58/lib/resin.jar:.:/usr/local/service/app/scf/scf-manager/jdk1.8.0_202/lib/tools.jar:/usr/local/service/app/scf/scf-manager/jdk1.8.0_202/lib/rt.jar:/usr/local/service/app/scf/scf-manager/resin-pro-4.0.58/lib/eclipselink-2.4.0.jar:/usr/local/service/app/scf/scf-manager/resin-pro-4.0.58/lib/javax.faces-2.1.24.jar:/usr/local/service/app/scf/scf-manager/resin-pro-4.0.58/lib/webservices-extra-api.jar:/usr/local/service/app/scf/scf-manager/resin-pro-4.0.58/lib/javamail-141.jar:/usr/local/service/app/scf/scf-manager/resin-pro-4.0.58/lib/webutil.jar:/usr/local/service/app/scf/scf-manager/resin-pro-4.0.58/lib/javaee-16.jar:/usr/local/service/app/scf/scf-manager/resin-pro-4.0.58/lib/resin.jar:/usr/local/service/app/scf/scf-manager/resin-pro-4.0.58/lib/pro.jar:/usr/local/service/app/scf/scf-manager/resin-pro-4.0.58/lib/resin-eclipselink.jar:/usr/local/service/app/scf/scf-manager/resin-pro-4.0.58/lib/activation.jar
java.naming.factory.initial = com.caucho.naming.InitialContextFactoryImpl
com.sun.management.jmxremote = 
java.vm.specification.version = 1.8
sun.arch.data.model = 64
sun.java.command = com.caucho.server.resin.Resin --root-directory /usr/local/service/app/scf/scf-manager/resin-pro-4.0.58 -conf ./../conf/resin.xml -server scf-manager start
java.home = /usr/local/service/app/scf/scf-manager/jdk1.8.0_202/jre
user.language = en
java.specification.vendor = Oracle Corporation
awt.toolkit = sun.awt.X11.XToolkit
com.sun.management.jmxremote.ssl = false
java.vm.info = mixed mode
java.version = 1.8.0_202
java.ext.dirs = /usr/local/service/app/scf/scf-manager/jdk1.8.0_202/jre/lib/ext:/usr/java/packages/lib/ext
sun.boot.class.path = /usr/local/service/app/scf/scf-manager/jdk1.8.0_202/jre/lib/resources.jar:/usr/local/service/app/scf/scf-manager/jdk1.8.0_202/jre/lib/rt.jar:/usr/local/service/app/scf/scf-manager/jdk1.8.0_202/jre/lib/sunrsasign.jar:/usr/local/service/app/scf/scf-manager/jdk1.8.0_202/jre/lib/jsse.jar:/usr/local/service/app/scf/scf-manager/jdk1.8.0_202/jre/lib/jce.jar:/usr/local/service/app/scf/scf-manager/jdk1.8.0_202/jre/lib/charsets.jar:/usr/local/service/app/scf/scf-manager/jdk1.8.0_202/jre/lib/jfr.jar:/usr/local/service/app/scf/scf-manager/jdk1.8.0_202/jre/classes
java.awt.headless = true
java.vendor = AdoptOpenJdk
file.separator = /
java.vendor.url.bug = https://github.com/AdoptOpenJDK/openjdk-build/issues
sun.io.unicode.encoding = UnicodeLittle
sun.cpu.endian = little
log4j2.isThreadContextMapInheritable = true
sun.cpu.isalist = 

VM Flags:
Non-default VM flags: -XX:CICompilerCount=12 -XX:CMSFullGCsBeforeCompaction=50 -XX:InitialHeapSize=1073741824 -XX:+ManagementServer -XX:MaxHeapSize=1073741824 -XX:MaxNewSize=268435456 -XX:MaxTenuringThreshold=10 -XX:MinHeapDeltaBytes=196608 -XX:NewSize=268435456 -XX:OldPLABSize=16 -XX:OldSize=805306368 -XX:+PrintFlagsFinal -XX:+PrintGC -XX:+PrintGCDateStamps -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -XX:SurvivorRatio=8 -XX:+UseCMSCompactAtFullCollection -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseConcMarkSweepGC -XX:+UseParNewGC 
Command line:  -Xmn256M -Xmx1024M -Xms1024M -XX:MaxPermSize=256M -XX:PermSize=256M -XX:SurvivorRatio=8 -XX:+UseConcMarkSweepGC -XX:CMSFullGCsBeforeCompaction=50 -XX:+UseCMSCompactAtFullCollection -XX:MaxTenuringThreshold=10 -verbose:gc -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -XX:+PrintGCDateStamps -XX:+PrintFlagsFinal -Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.port=8393 -Dcom.sun.management.jmxremote.ssl=false -Dcom.sun.management.jmxremote.authenticate=false -Xloggc:/usr/local/service/log/scf/scf-manager/gc.log -Xdebug -Xrunjdwp:transport=dt_socket,server=y,suspend=n,address=19137 -Dlog4j2.isThreadContextMapInheritable=true -Djava.util.logging.manager=com.caucho.log.LogManagerImpl -Djava.system.class.loader=com.caucho.loader.SystemClassLoader -Djava.endorsed.dirs=/usr/local/service/app/scf/scf-manager/jdk1.8.0_202/jre/lib/endorsed:/usr/local/service/app/scf/scf-manager/resin-pro-4.0.58/endorsed -Djavax.management.builder.initial=com.caucho.jmx.MBeanServerBuilderImpl -Djava.awt.headless=true -Dresin.home=/usr/local/service/app/scf/scf-manager/resin-pro-4.0.58
```



#### 7.4.2、`jinfo -flag `： 开启/关闭、设置对应名称的参数、显示Jvm参数值包括默认值 

> 使用 jinfo 可以在不重启虚拟机的情况下，可以动态的修改 jvm 的参数。尤其在线上的环境特别有用。  



##### 7.4.2.1、`./jinfo  -flags  pid`打印所有JVM参数（包括默认值 ）



```shell
[work@vm10-123-3-2 bin]$ ./jinfo  -flags  12566
Attaching to process ID 12566, please wait...
Debugger attached successfully.
Server compiler detected.
JVM version is 25.202-b08
Non-default VM flags: 
-XX:CICompilerCount=12 
-XX:CMSFullGCsBeforeCompaction=50 
-XX:InitialHeapSize=1073741824 
-XX:+ManagementServer 
-XX:MaxHeapSize=1073741824 
-XX:MaxNewSize=268435456 
-XX:MaxTenuringThreshold=10 
-XX:MinHeapDeltaBytes=196608 
-XX:NewSize=268435456 
-XX:OldPLABSize=16 
-XX:OldSize=805306368 
-XX:+PrintFlagsFinal 
-XX:+PrintGC 
-XX:+PrintGCDateStamps 
-XX:+PrintGCDetails 
-XX:+PrintGCTimeStamps 
-XX:SurvivorRatio=8 
-XX:+UseCMSCompactAtFullCollection 
-XX:+UseCompressedClassPointers 
-XX:+UseCompressedOops 
-XX:+UseConcMarkSweepGC 
-XX:+UseParNewGC 
Command line:  -Xmn256M -Xmx1024M -Xms1024M -XX:MaxPermSize=256M -XX:PermSize=256M -XX:SurvivorRatio=8 -XX:+UseConcMarkSweepGC -XX:CMSFullGCsBeforeCompaction=50 -XX:+UseCMSCompactAtFullCollection -XX:MaxTenuringThreshold=10 -verbose:gc -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -XX:+PrintGCDateStamps -XX:+PrintFlagsFinal -Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.port=8393 -Dcom.sun.management.jmxremote.ssl=false -Dcom.sun.management.jmxremote.authenticate=false -Xloggc:/usr/local/service/log/scf/scf-manager/gc.log -Xdebug -Xrunjdwp:transport=dt_socket,server=y,suspend=n,address=19137 -Dlog4j2.isThreadContextMapInheritable=true -Djava.util.logging.manager=com.caucho.log.LogManagerImpl -Djava.system.class.loader=com.caucho.loader.SystemClassLoader -Djava.endorsed.dirs=/usr/local/service/app/scf/scf-manager/jdk1.8.0_202/jre/lib/endorsed:/usr/local/service/app/scf/scf-manager/resin-pro-4.0.58/endorsed -Djavax.management.builder.initial=com.caucho.jmx.MBeanServerBuilderImpl -Djava.awt.headless=true -Dresin.home=/usr/local/service/app/scf/scf-manager/resin-pro-4.0.58
[work@vm10-123-3-2 bin]$ 
```





##### 7.4.2.2、**显示指定的Jvm参数值（包括默认值）。**

```shell
$ jinfo -flag MaxTenuringThreshold 21048
-XX:MaxTenuringThreshold=15


$ jinfo -flag PrintGCDetails  21048
-XX:-PrintGCDetails

```

```shell
java -XX:+PrintFlagsFinal -version | grep MetaspaceSiz
```



##### 7.4.2.3、**开启或者关闭日志** 

```shell
jinfo -flag +PrintGC 21048
jinfo -flag +PrintGCDetails 21048


jinfo -flag -PrintGC 21048
jinfo -flag -PrintGCDetails 21048
```

##### 7.4.2.4、**指定参数的值** 

```shell
jinfo -flag MaxTenuringThreshold=10 21048
```



### 7.5、`jmap`：生成虚拟机的堆转储快照（heapdump文件）

| 命令        | 说明                                                         |
| ----------- | ------------------------------------------------------------ |
| jmap -heap  | 显示java堆详细信息，如使用哪种收集器、参数配置、分代情况等，在Linux/Solaris平台下有效 |
| jmap -histo | 显示堆对象简单的统计报表                                     |
| jmap -dump  | 打印整个堆快照                                               |



#### 7.5.1、`jmap -heap pid` ：显示Java堆详细信息

```shell
Attaching to process ID 3764, please wait...
Debugger attached successfully.
Server compiler detected.
JVM version is 25.171-b11

using thread-local object allocation.
Parallel GC with 8 thread(s) //采用Parallel GC 

Heap Configuration:
   MinHeapFreeRatio         = 0    //JVM最小空闲比率 可由-XX:MinHeapFreeRatio=<n>参数设置， jvm heap 在使用率小于 n 时 ,heap 进行收缩
   MaxHeapFreeRatio         = 100  //JVM最大空闲比率 可由-XX:MaxHeapFreeRatio=<n>参数设置， jvm heap 在使用率大于 n 时 ,heap 进行扩张 
   MaxHeapSize              = 2095054848 (1998.0MB) //JVM堆的最大大小 可由-XX:MaxHeapSize=<n>参数设置
   NewSize                  = 44040192 (42.0MB) //JVM新生代的默认大小 可由-XX:NewSize=<n>参数设置
   MaxNewSize               = 698351616 (666.0MB) //JVM新生代的最大大小 可由-XX:MaxNewSize=<n>参数设置
   OldSize                  = 88080384 (84.0MB) //JVM老生代的默认大小 可由-XX:OldSize=<n>参数设置 
   NewRatio                 = 2 //新生代：老生代（的大小）=1:2 可由-XX:NewRatio=<n>参数指定New Generation与Old Generation heap size的比例。
   SurvivorRatio            = 8 //survivor:eden = 1:8,即survivor space是新生代大小的1/(8+2)[因为有两个survivor区域] 可由-XX:SurvivorRatio=<n>参数设置
   MetaspaceSize            = 21807104 (20.796875MB) //元空间的默认大小，超过此值就会触发Full GC 可由-XX:MetaspaceSize=<n>参数设置
   CompressedClassSpaceSize = 1073741824 (1024.0MB) //类指针压缩空间的默认大小 可由-XX:CompressedClassSpaceSize=<n>参数设置
   MaxMetaspaceSize         = 17592186044415 MB //元空间的最大大小 可由-XX:MaxMetaspaceSize=<n>参数设置
   G1HeapRegionSize         = 0 (0.0MB) //使用G1垃圾收集器的时候，堆被分割的大小 可由-XX:G1HeapRegionSize=<n>参数设置

Heap Usage:
PS Young Generation //新生代区域分配情况
Eden Space: //Eden区域分配情况
   capacity = 89653248 (85.5MB)
   used     = 8946488 (8.532035827636719MB)
   free     = 80706760 (76.96796417236328MB)
   9.978989272089729% used
From Space: //其中一个Survivor区域分配情况
   capacity = 42467328 (40.5MB)
   used     = 15497496 (14.779563903808594MB)
   free     = 26969832 (25.720436096191406MB)
   36.49275037977431% used
To Space:  //另一个Survivor区域分配情况
   capacity = 42991616 (41.0MB)
   used     = 0 (0.0MB)
   free     = 42991616 (41.0MB)
   0.0% used
PS Old Generation //老生代区域分配情况
   capacity = 154664960 (147.5MB)
   used     = 98556712 (93.99100494384766MB)
   free     = 56108248 (53.508995056152344MB)
   63.722715216167906% used

1819 interned Strings occupying 163384 bytes.

```



#### 7.5.2、 `jmap -histo` pid：显示堆对象简单的统计报表， 

> jmap -histo pid  
> jmap -histo:live pid ：使用live，JVM会先触发fullgc，然后再统计信息。所以如果不是很有必要的话，不要去执行





+ **`jmap -histo:live pid>a.log`    可以将其保存到文本中去，在一段时间后，使用文本对比工具，可以对比出GC回收了哪些对象。**      

+  **然而这个只知道哪些对象有多少个，占用了多大的内存，但不知道由什么对象创建的。下一步需要使用命令jmap -dump将快照打印出来出来，使用内存分析工具进一步明确它是由谁引用的、由什么对象。** 



| 符号         | 说明                           |
| ------------ | ------------------------------ |
| B            | byte                           |
| C            | char                           |
| D            | double                         |
| F            | float                          |
| I            | int                            |
| J            | long                           |
| Z            | boolean                        |
| [            | [ 代表数组， [I 就相当于 int[] |
| [L+ 类名表示 | 对象用 [L+ 类名表示            |



```
instances（实例数）、bytes（大小）、classs name（类名）。它基本是按照使用使用大小逆序排列的。   
```



```shell
$ jmap -histo:live 21048

 num     #instances         #bytes  class name
----------------------------------------------
   1:          4915         554288  [C
   2:           679         262448  [B
   3:          4767         114408  java.lang.String
   4:           681          77752  java.lang.Class
   5:           681          46520  [Ljava.lang.Object;
   6:           791          31640  java.util.TreeMap$Entry
   7:           419          13408  java.util.HashMap$Node
   8:           203          12992  java.net.URL
   9:           262          12272  [Ljava.lang.String;
  10:           290          11600  java.lang.ref.Finalizer
  11:           133           7688  [I
  12:           166           6640  java.util.LinkedHashMap$Entry
  13:            67           6432  java.util.jar.JarFile$JarFileEntry
  14:            75           6000  [Ljava.util.WeakHashMap$Entry;
  15:            99           5544  sun.misc.URLClassPath$JarLoader
  16:            21           5328  [Ljava.util.HashMap$Node;
  17:            72           4608  java.util.jar.JarFile
  18:           109           4360  java.lang.ref.SoftReference
  19:            74           4144  sun.nio.cs.UTF_8$Encoder
  20:           256           4096  java.lang.Integer
  21:            72           4032  java.util.zip.ZipFile$ZipFileInputStream
  22:           166           3984  java.io.ExpiringCache$Entry
  23:           123           3936  java.util.Hashtable$Entry
  24:            66           3696  java.util.zip.ZipFile$ZipFileInflaterInputStream
  25:            75           3600  java.util.WeakHashMap
  26:           104           3328  java.util.concurrent.ConcurrentHashMap$Node
  27:            66           3168  java.util.zip.Inflater
  28:             8           3008  java.lang.Thread
  29:            69           2760  sun.nio.cs.UTF_8$Decoder
  30:            82           2624  java.lang.ref.ReferenceQueue
  31:            72           2304  java.util.zip.ZipCoder
  32:            26           2080  java.lang.reflect.Constructor
  33:            15           1968  [Ljava.util.concurrent.ConcurrentHashMap$Node;
  34:            39           1872  sun.util.locale.LocaleObjectCache$CacheEntry
  35:            72           1728  java.util.ArrayDeque
  36:            66           1584  java.util.zip.ZStreamRef
  37:             1           1568  [[B
  38:            37           1480  java.io.ObjectStreamField
  39:            87           1392  java.lang.Object
  40:            29           1392  java.util.HashMap
  41:            84           1344  java.lang.ref.ReferenceQueue$Lock
  42:            19           1216  java.util.concurrent.ConcurrentHashMap
  43:             9           1184  [Ljava.util.Hashtable$Entry;
  44:             2           1064  [Ljava.lang.invoke.MethodHandle;
  45:             1           1040  [Ljava.lang.Integer;
  46:             1           1040  [[C
  47:            19            760  sun.util.locale.BaseLocale$Key
  48:             8            640  [S
  49:            19            608  java.util.Locale
  50:            19            608  sun.util.locale.BaseLocale
  51:            18            576  java.io.File
  52:            13            520  java.security.AccessControlContext
  53:            19            456  java.util.Locale$LocaleKey
  54:            17            408  java.util.jar.Attributes$Name
  55:            13            392  [Ljava.io.ObjectStreamField;
  56:             1            384  com.intellij.rt.execution.application.AppMainV2$1
  57:             1            384  java.lang.ref.Finalizer$FinalizerThread
  58:             6            384  java.nio.DirectByteBuffer
  59:            16            384  sun.misc.MetaIndex
  60:             1            376  java.lang.ref.Reference$ReferenceHandler
  61:             9            360  java.io.FileDescriptor
  62:             6            336  java.nio.DirectLongBufferU
  63:            14            336  java.util.LinkedList$Node
  64:            10            320  java.lang.OutOfMemoryError
  65:             3            312  [D
  66:            13            312  sun.reflect.NativeConstructorAccessorImpl
  67:             2            296  [J
  68:            15            280  [Ljava.lang.Class;
  69:             5            280  sun.util.calendar.ZoneInfo
  70:            11            264  java.util.ArrayList
  71:             8            256  java.util.LinkedList
  72:             8            256  java.util.Vector
  73:             3            240  [Ljava.lang.ThreadLocal$ThreadLocalMap$Entry;
  74:             5            240  java.util.Hashtable
  75:             6            240  java.util.WeakHashMap$Entry
  76:            13            208  sun.reflect.DelegatingConstructorAccessorImpl
  77:             5            200  java.security.ProtectionDomain
  78:             6            192  java.io.FileInputStream
  79:             6            192  java.lang.ThreadLocal$ThreadLocalMap$Entry
  80:             4            192  java.util.Properties
  81:             4            192  java.util.TreeMap
  82:             2            160  [[Ljava.lang.String;
  83:             4            160  java.lang.ClassLoader$NativeLibrary
  84:             5            160  java.security.CodeSource
  85:             5            160  sun.util.locale.provider.LocaleProviderAdapter$Type
  86:             3            144  java.nio.HeapByteBuffer
  87:             6            144  sun.misc.PerfCounter
  88:             3            144  sun.misc.URLClassPath
  89:             2            128  java.io.ExpiringCache$1
  90:             4            128  java.util.Stack
  91:             1            120  java.net.SocksSocketImpl
  92:             5            120  java.util.Collections$UnmodifiableRandomAccessList
  93:             5            120  sun.misc.FloatingDecimal$PreparedASCIIToBinaryBuffer
  94:             2            112  java.lang.Package
  95:             2            112  java.util.LinkedHashMap
  96:             2            112  java.util.ResourceBundle$CacheKey
  97:             4             96  java.lang.RuntimePermission
  98:             2             96  java.lang.ThreadGroup
  99:             3             96  java.lang.ref.WeakReference
 100:             2             96  java.util.ResourceBundle$BundleReference
 101:             1             96  sun.misc.Launcher$AppClassLoader
 102:             3             96  sun.net.spi.DefaultProxySelector$NonProxyInfo
 103:             2             96  sun.nio.cs.StreamEncoder
 104:             1             88  java.net.DualStackPlainSocketImpl
 105:             1             88  sun.misc.Launcher$ExtClassLoader
 106:             5             80  [Ljava.security.Principal;
 107:             2             80  java.io.BufferedWriter
 108:             2             80  java.io.ExpiringCache
 109:             5             80  java.lang.ThreadLocal
 110:             5             80  java.security.ProtectionDomain$Key
 111:             2             80  sun.misc.FloatingDecimal$BinaryToASCIIBuffer
 112:             3             72  java.lang.ThreadLocal$ThreadLocalMap
 113:             3             72  java.net.Proxy$Type
 114:             3             72  java.util.Arrays$ArrayList
 115:             3             72  java.util.Collections$SynchronizedSet
 116:             1             72  java.util.ResourceBundle$RBClassLoader
 117:             3             72  java.util.concurrent.atomic.AtomicLong
 118:             3             72  sun.misc.FloatingDecimal$ExceptionalBinaryToASCIIBuffer
 119:             1             72  sun.util.locale.provider.JRELocaleProviderAdapter
 120:             1             64  [F
 121:             2             64  [Ljava.lang.Thread;
 122:             2             64  java.io.FileOutputStream
 123:             2             64  java.io.FilePermission
 124:             2             64  java.io.PrintStream
 125:             2             64  java.lang.ClassValue$Entry
 126:             2             64  java.lang.VirtualMachineError
 127:             2             64  java.lang.ref.ReferenceQueue$Null
 128:             2             64  java.security.BasicPermissionCollection
 129:             2             64  java.security.Permissions
 130:             4             64  java.util.HashSet
 131:             2             64  java.util.ResourceBundle$LoaderReference
 132:             2             48  java.io.BufferedOutputStream
 133:             1             48  java.io.BufferedReader
 134:             2             48  java.io.File$PathStatus
 135:             2             48  java.io.FilePermissionCollection
 136:             2             48  java.io.OutputStreamWriter
 137:             2             48  java.net.InetAddress$Cache
 138:             2             48  java.net.InetAddress$Cache$Type
 139:             1             48  java.net.SocketInputStream
 140:             1             48  java.nio.HeapCharBuffer
 141:             2             48  java.nio.charset.CoderResult
 142:             3             48  java.nio.charset.CodingErrorAction
 143:             2             48  sun.misc.NativeSignalHandler
 144:             2             48  sun.misc.Signal
 145:             2             48  sun.misc.URLClassPath$FileLoader
 146:             3             48  sun.net.www.protocol.jar.Handler
 147:             1             48  sun.nio.cs.StreamDecoder
 148:             1             48  sun.nio.cs.US_ASCII$Decoder
 149:             1             48  sun.util.locale.provider.LocaleResources$ResourceReference
 150:             1             40  [Lsun.util.locale.provider.LocaleProviderAdapter$Type;
 151:             1             40  java.io.BufferedInputStream
 152:             1             40  java.util.ResourceBundle$1
 153:             1             40  sun.nio.cs.StandardCharsets$Aliases
 154:             1             40  sun.nio.cs.StandardCharsets$Cache
 155:             1             40  sun.nio.cs.StandardCharsets$Classes
 156:             1             40  sun.nio.cs.ext.ExtendedCharsets
 157:             1             32  [Ljava.lang.OutOfMemoryError;
 158:             2             32  [Ljava.lang.StackTraceElement;
 159:             1             32  [Ljava.lang.ThreadGroup;
 160:             1             32  [Ljava.net.Proxy$Type;
 161:             1             32  java.io.WinNTFileSystem
 162:             1             32  java.lang.ArithmeticException
 163:             2             32  java.lang.Boolean
 164:             1             32  java.lang.NullPointerException
 165:             1             32  java.net.InetAddress$InetAddressHolder
 166:             1             32  java.net.Socket
 167:             2             32  java.nio.ByteOrder
 168:             2             32  java.util.concurrent.atomic.AtomicInteger
 169:             1             32  java.util.concurrent.atomic.AtomicReferenceFieldUpdater$AtomicReferenceFieldUpdaterImpl
 170:             1             32  sun.instrument.InstrumentationImpl
 171:             1             32  sun.nio.cs.StandardCharsets
 172:             1             32  sun.util.locale.provider.LocaleResources
 173:             1             32  sun.util.locale.provider.LocaleServiceProviderPool
 174:             1             24  [Ljava.io.File$PathStatus;
 175:             1             24  [Ljava.lang.ClassValue$Entry;
 176:             1             24  [Ljava.net.InetAddress$Cache$Type;
 177:             1             24  [Ljava.security.ProtectionDomain;
 178:             1             24  [Lsun.launcher.LauncherHelper;
 179:             1             24  java.io.InputStreamReader
 180:             1             24  java.lang.ClassValue$Version
 181:             1             24  java.lang.StringBuilder
 182:             1             24  java.lang.invoke.MethodHandleImpl$4
 183:             1             24  java.lang.reflect.ReflectPermission
 184:             1             24  java.net.Inet4Address
 185:             1             24  java.net.Inet6AddressImpl
 186:             1             24  java.net.Proxy
 187:             1             24  java.util.BitSet
 188:             1             24  java.util.Collections$EmptyMap
 189:             1             24  java.util.Collections$SetFromMap
 190:             1             24  java.util.Locale$Cache
 191:             1             24  java.util.ResourceBundle$Control$CandidateListCache
 192:             1             24  sun.instrument.TransformerManager
 193:             1             24  sun.launcher.LauncherHelper
 194:             1             24  sun.misc.JarIndex
 195:             1             24  sun.nio.cs.ISO_8859_1
 196:             1             24  sun.nio.cs.ThreadLocalCoders$1
 197:             1             24  sun.nio.cs.ThreadLocalCoders$2
 198:             1             24  sun.nio.cs.US_ASCII
 199:             1             24  sun.nio.cs.UTF_16
 200:             1             24  sun.nio.cs.UTF_16BE
 201:             1             24  sun.nio.cs.UTF_16LE
 202:             1             24  sun.nio.cs.UTF_8
 203:             1             24  sun.util.locale.BaseLocale$Cache
 204:             1             24  sun.util.locale.provider.TimeZoneNameProviderImpl
 205:             1             16  [Ljava.lang.Throwable;
 206:             1             16  [Ljava.security.cert.Certificate;
 207:             1             16  [Lsun.instrument.TransformerManager$TransformerInfo;
 208:             1             16  java.io.FileDescriptor$1
 209:             1             16  java.lang.CharacterDataLatin1
 210:             1             16  java.lang.ClassValue$Identity
 211:             1             16  java.lang.Runtime
 212:             1             16  java.lang.String$CaseInsensitiveComparator
 213:             1             16  java.lang.System$2
 214:             1             16  java.lang.Terminator$1
 215:             1             16  java.lang.invoke.MemberName$Factory
 216:             1             16  java.lang.invoke.MethodHandleImpl$2
 217:             1             16  java.lang.invoke.MethodHandleImpl$3
 218:             1             16  java.lang.ref.Reference$1
 219:             1             16  java.lang.ref.Reference$Lock
 220:             1             16  java.lang.reflect.ReflectAccess
 221:             1             16  java.net.InetAddress$2
 222:             1             16  java.net.URLClassLoader$7
 223:             1             16  java.nio.Bits$1
 224:             1             16  java.nio.charset.CoderResult$1
 225:             1             16  java.nio.charset.CoderResult$2
 226:             1             16  java.security.ProtectionDomain$2
 227:             1             16  java.security.ProtectionDomain$JavaSecurityAccessImpl
 228:             1             16  java.util.Collections$EmptyIterator
 229:             1             16  java.util.Collections$EmptyList
 230:             1             16  java.util.Collections$EmptySet
 231:             1             16  java.util.Hashtable$EntrySet
 232:             1             16  java.util.ResourceBundle$Control
 233:             1             16  java.util.WeakHashMap$KeySet
 234:             1             16  java.util.jar.JavaUtilJarAccessImpl
 235:             1             16  java.util.zip.ZipFile$1
 236:             1             16  sun.misc.ASCIICaseInsensitiveComparator
 237:             1             16  sun.misc.FloatingDecimal$1
 238:             1             16  sun.misc.Launcher
 239:             1             16  sun.misc.Launcher$Factory
 240:             1             16  sun.misc.Perf
 241:             1             16  sun.misc.Unsafe
 242:             1             16  sun.net.spi.DefaultProxySelector
 243:             1             16  sun.net.www.protocol.file.Handler
 244:             1             16  sun.reflect.ReflectionFactory
 245:             1             16  sun.util.calendar.Gregorian
 246:             1             16  sun.util.locale.provider.AuxLocaleProviderAdapter$NullProvider
 247:             1             16  sun.util.locale.provider.SPILocaleProviderAdapter
 248:             1             16  sun.util.locale.provider.TimeZoneNameUtility$TimeZoneNameGetter
 249:             1             16  sun.util.resources.LocaleData
 250:             1             16  sun.util.resources.LocaleData$LocaleDataResourceBundleControl
Total         16750        1270808


```



#### 7.5.3、`jmap -dump ,format = b file = heap.tdump pid` ：打印整个堆快照

> 这个命令执行，JVM会将整个heap的信息dump写入到一个文件，**heap如果比较大的话，就会导致这个过程比较耗时。执行的过程中为了保证dump的信息是可靠的，所以会暂停应用**(STW)，**进行FULL GC**。所以建议如果不是很有必要的话，不要去执行。      
>
> 
>
> format = b 是表打印二进制文件，    
>
> -live， 此事只统计活的对象数量.

```shell
jmap -dump ,format = b file = heap.tdump pid
jmap -dump:live,format=b,file=heap.tdump 
```



##### 7.5.3.1、打印堆快照的其他方式  

虚拟机启动时如果指定了` -XX:+HeapDumpOnOutOfMemoryError `选项, 则在抛出 OutOfMemoryError 时, 会自动执行堆转储

```shell
-XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/path
```



##### 7.5.3.2、使用说明 

**这个文件使用工具进行分析，这个非常关键，具体分析，看后面的内容**



```shell
$ jmap -dump:format=b,file=333.tdump 12316
Dumping heap to D:\programFiles\java-1.8.0-openjdk\bin\333.tdump ...
Heap dump file created

```

![1578451779900](https://raw.githubusercontent.com/HealerJean123/HealerJean123.github.io/master/blogImages/1578451779900.png)



### 7.6、`jhat ` ：浏览器分析dump文件  

#### 7.6.1、`jhat -J-Xmx1024m D:/javaDump.tdump` 浏览器分析dump文件

>说明： -J是向java虚拟机传一个参数，如-mx768m是指定虚拟机可用最大的内存为768M。如果映像文件很大，你要指定一个很大的值，否则在分析过程中就会有OutOfMemeryError的错误。 
>
>+ jhat是一个Java堆复制浏览器。这个工具分析Java堆复制文件（`jmap  -dump` 出来的 heap文件. ）。jhat 命令解析Java堆转储文件,并启动一个 web server. 然后用浏览器来查看/浏览使用名 `
>
>
>+ jhat 命令支持预先设计的查询, 比如显示某个类的所有实例. 还支持 对象查询语言(OQL, Object Query Language)。 OQL有点类似SQL,专门用来查询堆转储。 OQL相关的帮助信息可以在 jhat 命令所提供的服务器页面最底部. 如果使用默认端口, 则OQL帮助信息页面为: <http://localhost:7000/oqlhelp/>



```shell
$ jhat -J-Xmx1024m 333.tdump
Reading from 333.tdump...
Dump file created Wed Jan 08 10:39:57 CST 2020
Snapshot read, resolving...
Resolving 55284 objects...
Chasing references, expect 11 dots...........
Eliminating duplicate references...........
Snapshot resolved.
Started HTTP server on port 7000
Server is ready.

```



[http://localhost:7000/](http://localhost:7000/)



![1578454068275](https://raw.githubusercontent.com/HealerJean123/HealerJean123.github.io/master/blogImages/1578454068275.png)



#### 7.6.2、开始分析浏览器中的dump文件 

##### 7.6.2.1、显示出堆中所包含的所有的类[<http://localhost:7000/allClassesWithPlatform/>]()  

![1578454494175](https://raw.githubusercontent.com/HealerJean123/HealerJean123.github.io/master/blogImages/1578454494175.png) 



##### 7.6.2.2、从根集能引用到的对象    

![1578454634899](https://raw.githubusercontent.com/HealerJean123/HealerJean123.github.io/master/blogImages/1578454634899.png)

##### 7.6.2.3、显示平台包括的所有类的实例数量    

![1578454754576](https://raw.githubusercontent.com/HealerJean123/HealerJean123.github.io/master/blogImages/1578454754576.png)



##### 7.6.2.4、堆实例的分布表  

![1578454696168](https://raw.githubusercontent.com/HealerJean123/HealerJean123.github.io/master/blogImages/1578454696168.png)

##### 7.6.2.5、执行对象查询语句



![1578454707109](https://raw.githubusercontent.com/HealerJean123/HealerJean123.github.io/master/blogImages/1578454707109.png)





```
jhat中的OQL（对象查询语言） 
如果需要根据某些条件来过滤或查询堆的对象，这是可能的，可以在jhat的html页面中执行OQL，来查询符合条件的对象

基本语法： 
select <javascript expression to select>
[from [instanceof] <class name> <identifier>]
[where <javascript boolean expression to filter>]

解释： 
(1)class name是java类的完全限定名，如：java.lang.String, java.util.ArrayList, [C是char数组, [Ljava.io.File是java.io.File[]
(2)类的完全限定名不足以唯一的辨识一个类，因为不同的ClassLoader载入的相同的类，它们在jvm中是不同类型的
(3)instanceof表示也查询某一个类的子类，如果不明确instanceof，则只精确查询class name指定的类
(4)from和where子句都是可选的
(5)java域表示：obj.field_name；java数组表示：array[index]

举例： 
（1）查询长度大于100的字符串
select s from java.lang.String s where s.count > 100
（2）查询长度大于256的数组
select a from [I a where a.length > 256
（3）显示匹配某一正则表达式的字符串
select a.value.toString() from java.lang.String s where /java/(s.value.toString())
（4）显示所有文件对象的文件路径
select file.path.value.toString() from java.io.File file
（5）显示所有ClassLoader的类名
select classof(cl).name from instanceof java.lang.ClassLoader cl
（6）通过引用查询对象
select o from instanceof 0xd404d404 o

built-in对象 -- heap 
(1)heap.findClass(class name) -- 找到类
select heap.findClass("java.lang.String").superclass
(2)heap.findObject(object id) -- 找到对象
select heap.findObject("0xd404d404")
(3)heap.classes -- 所有类的枚举
select heap.classes
(4)heap.objects -- 所有对象的枚举
select heap.objects("java.lang.String")
(5)heap.finalizables -- 等待垃圾收集的java对象的枚举
(6)heap.livepaths -- 某一对象存活路径
select heaplivepaths(s) from java.lang.String s
(7)heap.roots -- 堆根集的枚举

辨识对象的函数 
(1)classof(class name) -- 返回java对象的类对象
select classof(cl).name from instanceof java.lang.ClassLoader cl
(2)identical(object1,object2) -- 返回是否两个对象是同一个实例
select identical(heap.findClass("java.lang.String").name, heap.findClass("java.lang.String").name)
(3)objectid(object) -- 返回对象的id
select objectid(s) from java.lang.String s
(4)reachables -- 返回可从对象可到达的对象
select reachables(p) from java.util.Properties p -- 查询从Properties对象可到达的对象
select reachables(u, "java.net.URL.handler") from java.net.URL u -- 查询从URL对象可到达的对象，但不包括从URL.handler可到达的对象
(5)referrers(object) -- 返回引用某一对象的对象
select referrers(s) from java.lang.String s where s.count > 100
(6)referees(object) -- 返回某一对象引用的对象
select referees(s) from java.lang.String s where s.count > 100
(7)refers(object1,object2) -- 返回是否第一个对象引用第二个对象
select refers(heap.findObject("0xd4d4d4d4"),heap.findObject("0xe4e4e4e4"))
(8)root(object) -- 返回是否对象是根集的成员
select root(heap.findObject("0xd4d4d4d4")) 
(9)sizeof(object) -- 返回对象的大小
select sizeof(o) from [I o
(10)toHtml(object) -- 返回对象的html格式
select "<b>" + toHtml(o) + "</b>" from java.lang.Object o
(11)选择多值
select {name:t.name?t.name.toString():"null",thread:t} from instanceof java.lang.Thread t

数组、迭代器等函数 
(1)concat(enumeration1,enumeration2) -- 将数组或枚举进行连接
select concat(referrers(p),referrers(p)) from java.util.Properties p
(2)contains(array, expression) -- 数组中元素是否满足某表达式
select p from java.util.Properties where contains(referres(p), "classof(it).name == 'java.lang.Class'")
返回由java.lang.Class引用的java.util.Properties对象
built-in变量
it -- 当前的迭代元素
index -- 当前迭代元素的索引
array -- 被迭代的数组
(3)count(array, expression) -- 满足某一条件的元素的数量
select count(heap.classes(), "/java.io./(it.name)")
(4)filter(array, expression) -- 过滤出满足某一条件的元素
select filter(heap.classes(), "/java.io./(it.name)")
(5)length(array) -- 返回数组长度
select length(heap.classes())
(6)map(array,expression) -- 根据表达式对数组中的元素进行转换映射
select map(heap.classes(),"index + '-->' + toHtml(it)")
(7)max(array,expression) -- 最大值, min(array,expression)
select max(heap.objects("java.lang.String"),"lhs.count>rhs.count")
built-in变量
lhs -- 左边元素
rhs -- 右边元素
(8)sort(array,expression) -- 排序
select sort(heap.objects('[C'),'sizeof(lhs)-sizeof(rhs)')
(9)sum(array,expression) -- 求和
select sum(heap.objects('[C'),'sizeof(it)')
(10)toArray(array) -- 返回数组
(11)unique(array) -- 唯一化数组

```





## 8、虚拟机参数怎么配置   



### 8.1、理论知识   

![1578294958942](https://raw.githubusercontent.com/HealerJean123/HealerJean123.github.io/master/blogImages/1578294958942.png)



- Java整个堆大小设置，Xmx 和 Xms设置为老年代存活对象的3-4倍，即FullGC之后的老年代内存占用的3-4倍
- 年轻代Xmn的设置为老年代存活对象的1-1.5倍。
- 老年代的内存大小设置为老年代存活对象的2-3倍。
- 永久代 PermSize和MaxPermSize设置为老年代存活对象的1.2-1.5倍。



### 8.2、实战理论 

#### 8.2.1、 确定老年代运行大小     



> **注意：CMS GC是会造成2次的FullGC次数增加，因为它会两次STW，**  



##### 8.2.1.1、GC日志 （稳妥方式 ）

> JVM参数中添加GC日志，GC日志中会记录每次FullGC之后各代的内存大小，观察老年代GC之后的空间大小。**可观察一段时间内（比如2天）的FullGC之后的内存情况**，根据多次的FullGC之后的老年代的空间大小数据来预估FullGC之后老年代的存活对象大小（可根据多次FullGC之后的内存大小取平均值）   ，





##### 8.2.1.2、强制触发FULL GC （谨慎使用，考虑腾出一台服务器暂时不给用户使用）

> 运行一段时间后，考虑强制触发full gc ，这样就知道稳定运行中老年代的大小，这样获取的数据也必将准确，如果不适用这个命令，直接用后面 jstat gc 查看到的老年代内存是不准的，可能偏大。   
>
> 
>
> 注意：强制触发FullGC，会造成线上服务停顿（STW），要谨慎，建议的操作方式为，在强制FullGC前先把服务节点摘除，FullGC之后再将服务挂回可用节点，对外提供服务 ，然后在不同时间段触发FullGC，**根据多次FullGC之后的老年代内存情况来预估FullGC之后的老年代存活对象大小**   



**触发Full GC 的方法**   

+  ` jmap -dump:live,format=b,file=heap.tdump <pid>` 将当前的存活对象dump到文件，此时会触发FullGC  
+    `jmap -histo:live <pid>` 打印每个class的实例数目,内存占用,类全名信息.live子参数加上后,只统计活的对象数量. 此时会触发FullGC





###### **1、运行系统，等运行稳定，使用jstat看到内存分配**   

> 刚上线的新服务，不知道该设置多大的内存的时候，可以先多设置一点内存，然后根据GC之后的情况来进行分析。



```shell
./jstat -gc 12566 1000 100
```



```shell
[work@vm10-123-3-2 bin]$ ./jstat -gc 12566 1000 100
 S0C    S1C    S0U    S1U      EC       EU        OC         OU       MC     MU    CCSC   CCSU   YGC     YGCT    FGC    FGCT     GCT   
26176.0 26176.0 296.0   0.0   209792.0 169909.3  786432.0   149381.5  116424.0 109474.4 13108.0 11988.5    340    8.121   6      0.570    8.691
26176.0 26176.0 296.0   0.0   209792.0 169909.3  786432.0   149381.5  116424.0 109474.4 13108.0 11988.5    340    8.121   6      0.570    8.691
26176.0 26176.0 296.0   0.0   209792.0 169909.3  786432.0   149381.5  116424.0 109474.4 13108.0 11988.5    340    8.121   6      0.570    8.691
26176.0 26176.0 296.0   0.0   209792.0 169909.3  786432.0   149381.5  116424.0 109474.4 13108.0 11988.5    340    8.121   6      0.570    8.691
26176.0 26176.0 296.0   0.0   209792.0 169922.4  786432.0   149381.5  116424.0 109474.4 13108.0 11988.5    340    8.121   6      0.570    8.691

```



![1578463100026](https://raw.githubusercontent.com/HealerJean123/HealerJean123.github.io/master/blogImages/1578463100026.png)





+ 年轻代GC平均耗时：8.121s/340 = 0.023秒 = 23毫秒  
+ 老年代GC平均耗时 0.57/6 =0.095秒 =  95毫秒
+ 查看年轻代GC频率，可以再线上直接使用该命令进行推导 ，很简单。看看多长时间GC一次  



###### **2、jmap，查看堆内存情况**   



```shell
./jmap -heap 12566
```



```shell
[work@vm10-123-3-2 bin]$ ./jmap -heap 12566
Attaching to process ID 12566, please wait...
Debugger attached successfully.
Server compiler detected.
JVM version is 25.202-b08

using parallel threads in the new generation.
using thread-local object allocation.
Concurrent Mark-Sweep GC

Heap Configuration:
   MinHeapFreeRatio         = 40
   MaxHeapFreeRatio         = 70
   MaxHeapSize              = 1073741824 (1024.0MB)
   NewSize                  = 268435456 (256.0MB)
   MaxNewSize               = 268435456 (256.0MB)
   OldSize                  = 805306368 (768.0MB)
   NewRatio                 = 2
   SurvivorRatio            = 8
   MetaspaceSize            = 21807104 (20.796875MB)
   CompressedClassSpaceSize = 1073741824 (1024.0MB)
   MaxMetaspaceSize         = 17592186044415 MB
   G1HeapRegionSize         = 0 (0.0MB)

Heap Usage:
New Generation (Eden + 1 Survivor Space):
   capacity = 241631232 (230.4375MB)
   used     = 26757744 (25.518173217773438MB)
   free     = 214873488 (204.91932678222656MB)
   11.073793639391782% used
Eden Space:
   capacity = 214827008 (204.875MB)
   used     = 26537600 (25.3082275390625MB)
   free     = 188289408 (179.5667724609375MB)
   12.353009170988408% used
From Space:
   capacity = 26804224 (25.5625MB)
   used     = 220144 (0.2099456787109375MB)
   free     = 26584080 (25.352554321289062MB)
   0.8213033886002445% used
To Space:
   capacity = 26804224 (25.5625MB)
   used     = 0 (0.0MB)
   free     = 26804224 (25.5625MB)
   0.0% used
concurrent mark-sweep generation:
   capacity = 805306368 (768.0MB)
   used     = 152967632 (145.8813018798828MB)
   free     = 652338736 (622.1186981201172MB)
   18.99496118227641% used

42801 interned Strings occupying 4704176 bytes.
```



+ 老年代占用内存`145M`左右，按照整个堆大小是老年代的3-4倍计算的话，  设置各代内存的情况如下  



```
-Xms=640m -Xmx=640m Xmn=256m  

老年代大小为 640 - 256 = 384  384/145 = 2.6倍 符号推荐情况 
```



###### 3、测试成果 ：运行7.1.1命令，查看gc频率是否正常，满足需要



结果分析 ：整体的GC耗时减少。但GC频率比之前的2G时的要多了一些。  



### 8.3、总结：



+ **在内存比较小的机器上**，可以按照上述的方式来进行内存的调优， 找到一个在GC频率和GC耗时上都可接受的一个内存设置，可以用较小的内存满足当前的服务需要。**但内存比较大的机器上**，可以相对给服务多增加一点内存，可以减少GC的频率，GC的耗时相应会增加一些。









## 问题  



## 2、String 

### 2.1、String.intern()分析 -结合2看



@：JDK1.6：复制的是字符串，返回常量池字符串地址

@：JDK1.7：复制的是引用，返回引用



> 判断这个常量是否存在于常量池。      
>
>   如果存在     
>
>    判断存在内容是引用还是常量，    
>
>     如果是引用，    
>
>      **<font color="red">返回引用地址指向堆空间对象  </font>**，    
>
>     如果是常量，    
>
>      **<font color="red">直接返回常量池常量  </font>**    
>
>   如果不存在，   
>
>    将当前对象引用复制到常量池,并且返回的是当前对象的引用    
>
> **结合 2 分析** 


```java

String a1 = "AA";
System.out.println(a1 == a1.intern()); //true

String a2 = new String("B") + new String("B");
a2.intern();
String a3 = new String("B") + new String("B");
System.out.println(a2 == a3.intern());//true 
System.out.println(a3 == a3.intern());//false


String a4 = new String("C") + new String("C");
System.out.println(a4 == a4.intern()); //true
```



### 2.2、创建字符串分析 

#### 结1、只在常量池上创建常量 

```java
    String a1 = "AA";
```

#### 结2、只在堆上创建对象  

```java
String a2 = new String("A") + new String("A");
```

#### 结3、在堆上创建对象，在常量池上创建常量

```java
    String a3 = new String("AA");
```

#### 结4、在堆上创建对象，在常量池上创建引用

```java
String a4 = new String("A") + new String("A");//只在堆上创建对象AA
a4.intern();//将该对象AA的引用保存到常量池上
```





#### 2.2.1、创建字符串分析开始



##### 2.1.1、直接使用双引号`" "`创建字符串  



>判断这个常量是否存在于常量池，     
>
>  如果存在，      
>
>   **判断这个常量是存在的引用还是常量**，     
>
>     **<font color="red">如果是引用，返回引用地址指向的堆空间对象，  </font>**   
>
>    如果是常量，则直接返回常量池常量，      
>
>  如果不存在，     
>
>    在常量池中创建该常量，并返回此常量



```java
String a1 = "AA";//在常量池上创建常量AA
String a2 = "AA";//直接返回已经存在的常量AA
System.out.println(a1 == a2); //true
```



```java
String a3 = new String("AA");    //在堆上创建对象AA，在常量池创建对象AA
a3.intern(); //发现在常量池已经有了字符串AA，所以不做操作，返回字符串AA的地址
String a4 = "AA"; //常量池上存在字符串AA，所以使用常量池中的对象
System.out.println(a3 == a4); //false,   
```



##### 2.1.2、new String创建字符串



>1、首先在堆上创建对象(无论堆上是否存在相同字面量的对象       
>
>2、然后判断常量池上是否存在字符串的字面量，     
>
>  如果不存在     
>
>   在常量池上创建常量     
>
>  如果存在    
>
>   不做任何操作



```java
String a1 = new String("AA");
String a2 = new String("AA");
System.out.println(a1 == a2); //false

```

```java
//如果常量池上不存在常量AA,也不存在引用AA，则创建常量AA
String a1 = new String("AA");
System.out.println(a1 == a1.intern()); //false // a1是堆上"AA"对象的地址，a1.intern()是字符串常量池中字符串AA对象的地址，所以返回false
```



##### 2.1.3、双引号相加 

>判断这两个常量、相加后的常量在常量池上是否存在          
>
>​            如果不存在      
>
>   则在常量池上创建相应的常量     
>
>  如果存在      
>
>   判断这个常量是存在的引用还是常量，      
>
>    如果是引用，返回引用地址指向的堆空间对象，    
>
>    如果是常量，则直接返回常量池常量，



```java
String a1 = "AA" + "BB";//在常量池上创建常量AA、BB和AABB，并返回AABB
```

```java
//常量池上存在常量AABB
String a2 = "AABB";
String a3 = "AA" + "BB";
System.out.println(a2 == a3); //true
```



```java
//常量池上存在引用AABB
String a4 = new String("AA") + new String("BB"); //在堆上创建对象AA、BB和AABB，在常量池上创建常量AA和BB
a4.intern(); //常量池没有AABB，复制a4的引用到常量池，然后返回a4的引用
String a5 = "AA" + "BB";  //常量池中已经有了AABB的引用，则a5指向的是a4的引用
System.out.println(a4 == a5); //true 
```



##### 2.1.4、两个new String相加 

>  首先会创建这两个对象以及相加后的对象       
>
>  然后判断常量池中是否存在这两个对象的字面量常量        
>
>   如果存在      
>
>    不做任何操作      
>
>   如果不存在     
>
>    则在常量池上创建对应常       



```java
//常量AA不存在，所以第一步在常量池中创建了常量AA
String a2 = new String("AA") + new String("BB");
String a3 = new String("A") + new String("A"); //创建对象AA，
System.out.println(a3 == a3.intern()); //false  //AA已经在常量池存在了，所以a3.intern() 直接返回字符串AA的地址，然后和引用a3比较，肯定不相等
```



```java
//只在堆上创建AABB对象，没有在常量池中创建常量AABB
String a2 = new String("AA") + new String("BB");
System.out.println(a2 == a2.intern()); //true 
```





#### 2.2.2、String创建字符串的问题 



```java
String s1 = "a";
String s2 = "a" + "b";
System.out.println(s2 == "ab");//true

String s3 = s1 + "b";
System.out.println(s3 == "ab");//false

```

##### 2.2.2.1、理解说明 

> ```
> String s = new String("a");
> ```
>
> 这相当于在java堆内存中创建一个对象
>
> 
>
> ```
> String s = "a" + "b";
> ```
>
> java的编译器会为该语句进行优化，变成String s = "ab"；放入的是常量池



##### 2.2.2.2、解答疑问 

`s3 = s1 + "b";`由于编译器不能在编译过程中确定s1的值，所以在这一步相当于String s3 = new String("ab");所以s3对象是堆内存中的对象，所以与常量池中的"ab"对比，自然答案是false。    



加入把s1变成一个常量，`s3 == "ab"` 就会为true

```java
final String s1 = "a";
String s2 = "a" + "b";
String s3 = s1 + "b";

System.out.println(s2 == "ab");//true
System.out.println(s3 == "ab");//true
```





#### 2.2.3、String.intern()问题 



##### 2.2.3.1、jdk1.6  ：复制的是字符串

```java
String s1 = new String("aaa")+new String("bbb");
s1.intern();
String s2 = "aaabbbb";
System.out.println(s1==s2); //false 引用和字符串比较
```



##### 2.2.4.2、jdk1.7 ：复制的是引用

```java
String s1 = new String("aaa")+new String("bbb");
s1.intern();
String s2 = "aaabbb";
System.out.println(s1==s2); //true 引用和引用比较 
```



```java
String s1 = new String("aaa")+new String("bbb");
String s2 = "aabbcc";
s1.intern(); //已经存在了字符串，不会受到影响了
System.out.println(s1==s2); //false 
```



## 3、包装类：Integer内存分配 



### 3.1、两个 new Integer() 变量比较 ，永远是 false

> 生成的是堆内存对象，引用地址不相等 ，比较为false

```java

@Test
public void test1() {
    Integer i = new Integer(100);
    Integer j = new Integer(100);
    System.out.print(i == j);  //false
}
```



### 3.2、Integer变量 和 new Integer() 变量比较 ，永远为 false

>而 new Integer() 的变量指向 堆中 新建的对象
>
>Integer j = 100; -128到127，常量池，之外的也是堆中，但是和new 的不一样

```java
 public void test2() {
        Integer i = new Integer(100);
        Integer j = 100;
        System.out.print(i == j);  //false 常量池和堆中的对象比较

        Integer i2 = new Integer(128);
        Integer j2 = 128;
        System.out.println(i2 == j2); //堆中建立的不同对象的比较
    }
```



### 3.3、 2、两个Integer 变量比较，-128到127 之间为true

>java对于-128到127之间的数，会进行缓存，在常量池存储。

```java
public void test3() {
    Integer i = 100;
    Integer j = 100;
    System.out.println(i == j); //true

    Integer i2 = 128;
    Integer j2 = 128;
    System.out.println(i2 == j2); //false
}
```





### 4.3、4、int 变量 与 Integer、 new Integer() 比较时，只要两个的值是相等，则为true



>包装类Integer 和 基本数据类型int 比较时，java会自动拆包装为int ，然后进行比较，实际上就变为两个int变量的比较。    
>
>int是基本数据类型，不能在对中创建数据，所以堆中的Integer拆箱（xx.intValue）为int类型的数据，然后进行比较int和integer(无论new否)比，都为true，**因为会把Integer自动拆箱为int再去比，也就是栈内存中的拆箱后进行比较**

```java
@Test
public void test4() {
    Integer i = new Integer(100);
    int j = 100;
    System.out.print(i == j); //true
}
```











****

**如果满意，请打赏博主任意金额，感兴趣的请下方留言吧。可与博主自由讨论哦**

|**支付包** | **微信** |**微信公众号**|
|:-------:|:-------:|:------:|
|**![支付宝](https://raw.githubusercontent.com/HealerJean123/HealerJean123.github.io/master/assets/img/tctip/alpay.jpg)** | **![微信](https://raw.githubusercontent.com/HealerJean123/HealerJean123.github.io/master/assets/img/tctip/weixin.jpg)** |**![微信公众号](https://raw.githubusercontent.com/HealerJean123/HealerJean123.github.io/master/assets/img/my/qrcode_for_gh_a23c07a2da9e_258.jpg)**|



**<!-- Gitalk 评论 start  -->**

**<link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">**
<script src="https://unpkg.com/gitalk@latest/dist/gitalk.min.js"></script> 
<div id="gitalk-container"></div>    
 <script type="text/javascript">
    var gitalk = new Gitalk({
		clientID: `1d164cd85549874d0e3a`,
		clientSecret: `527c3d223d1e6608953e835b547061037d140355`,
		repo: `HealerJean123.github.io`,
		owner: 'HealerJean123',
		admin: ['HealerJean123'],
		id: 'JGr01MDyOu56VQWX',
    });
    gitalk.render('gitalk-container');
</script> 

**<!-- Gitalk end -->**

