---
title: 1、Java虚拟机内存分配和溢出
date: 2018-04-08 15:33:00
tags: 
- JVM
category: 
- JVM
description: Java虚拟机内存分配和溢出
---
<!-- image url 
https://raw.githubusercontent.com/HealerJean/HealerJean.github.io/master/blogImages
　　首行缩进
<font color="red">  </font>
-->

## 前言

由于虚拟机自动内存管理机制的帮助下，不需要为每一个new出来的对象，去写delete/free代码。不容易出现内存泄漏和内存溢出的问题，

<font color="red">**但是如果一旦出现问题，那将是非常可怕的** </font>，如果不了解虚拟机是怎么使用内存的，那么排查错误将会成为一项非常艰难的工资。


## 误区
经常有人讲java内存区分为堆内存和栈内存，这种分发比较粗糙，只能说明大多数程序员最密切的就是这两块


在多线程环境下，每个线程拥有一个栈和一个程序计数器。栈和程序计数器用来保存线程的执行历史和线程的执行状态，是线程私有的资源。其他的资源（比如堆、地址空间、全局变量）是由同一个进程内的多个线程共享。


## 1、Java虚拟机内存分配

### 1.1、程序计数器（线程私有）

较小的内存空间，可以当做当前线程所执行字节码的行号指示器，每个线程都有自己的行号指示器，互补干扰，因此这部分内存区域也叫作私有区域

### 1.2、Java虚拟机栈（线程私有）

这里其实就是程序员通俗意义上的栈区，<font color="red">存放基本的数据类型和，对象的引用。（函数多的参数值，局部变量）
 </font>
 <br/>
 <font color="red">每次在方法执行的同时，都会创建一个栈帧，用来存储局部变量表，操作数栈（可以理解成数字），动态链接、方法出入口等信息。每一个方法执行的时候，就对应着一个栈帧在虚拟机栈中入栈和出栈的过程 </font>

#### 1.1、这个区域出现的异常情况有两种

1、如果虚拟机请求栈深度大于虚拟机所允许的深度，将抛出 StackOverflowError异常

2、如果虚拟机栈可以动态扩展（当前大部分虚拟机都可以）如果扩展时无法申请到足够的内存，将飘出OutOfMemoryError


### 1.3、本地方法栈（线程私有）

本地方法栈和虚拟机栈区别是，虚拟机栈为执行的java方法服务，而本地方法栈为Native方法服务。它也会抛出StackOverflowError和OutOfMemoryError异常

### 1.4、Java堆（线程共享）

Java堆是被所有线程共享的区域，在虚拟机启动时候创建，<font color="red">  此区域的唯一目标就是存放对象实例和数组，</font>
<font color="red"> Java堆是垃圾收集器管理的主要区域 </font>


### 1.5、方法区（线程共享）
虽然Java虚拟机将方法区描述为作为堆区的一个逻辑部分，但是它有一个别名叫非堆区域    



方法去也是各个线程共享的内存区域，它用于<font color="red">存储以被虚拟机加载的类信息，常亮，静态变量(static),以及访问修饰符，字段描述，方法描述等</font>，即时编译后的代码等数据。，也叫永久代

#### 1.5.1、运行时常量池  



用于存放编译器生成的各种字面量和符号引用    

java语言并不要求常亮一定只有编译时期才能产生，运行期间也可能将新的常亮返放入池中，这种
这种特性被用的最多的就是`String的intern()`方法


### 图解


1、所有的内存

![WX20180409-110305@2x](https://raw.githubusercontent.com/HealerJean/HealerJean.github.io/master/blogImages/WX20180409-110305@2x.png)


![WX20190207-190335@2x](https://raw.githubusercontent.com/HealerJean/HealerJean.github.io/master/blogImages/WX20190207-190335@2x.png)


## 2、实战 OutOfMemoryError异常

### 2.1、java堆溢出


```java
 -Xms20m -Xmx20m
```
#### 2.1.1、测试代码
```java
package com.hlj.moudle.jvm001.service;

/**
 * @Description Java堆溢出
 * @Author HealerJean
 * @Date 2019/2/7  下午5:12.

   JVM   -Xms20m -Xmx20m

 */

import java.util.ArrayList;
import java.util.List;

public class Jvm01HeadOOM {


    static class OOMObject{}

    public static void main(String[] args) {
        List<OOMObject> oomObjects = new ArrayList<>();

        while (true){
            oomObjects.add(new OOMObject());
        }
    }
}

```

过一段时间之后报下面错误

```java
Exception in thread "main" java.lang.OutOfMemoryError: Java heap space
	at java.util.Arrays.copyOf(Arrays.java:3210)
	at java.util.Arrays.copyOf(Arrays.java:3181)
	at java.util.ArrayList.grow(ArrayList.java:265)
	at java.util.ArrayList.ensureExplicitCapacity(ArrayList.java:239)
	at java.util.ArrayList.ensureCapacityInternal(ArrayList.java:231)
	at java.util.ArrayList.add(ArrayList.java:462)
	at com.hlj.jvm.memory.JavaHeap.main(JavaHeap.java:19)

Process finished with exit code 1
```

#### 2.1.2、异常分析和解决

可以看到上面的提示`Java heap space` java堆内存
如果出现上面的异常，从代码上看是否存在某些对象生命周期过长，持有状态时间过长的情况，尝试减少程序运行期的的内存消耗


### 2.2、虚拟机栈和本地方法栈溢出

-Xss128k：设置每个线程的栈大小。JDK5.0以后每个线程栈大小为1M，以前每个线程栈大小为256K。更具应用的线程所需内存大小进行调整。在相同物理内存下，减小这个值能生成更多的线程。但是操作系统对一个进程内的线程数还是有限制的，不能无限生成，经验值在3000~5000左右。


```java
 -Xss128k
```

```java
package com.hlj.moudle.jvm001.service;



/*

 * @Description 虚拟机栈和本地方法栈溢出
 * @Author HealerJean
 * @Date 2019/2/7  下午6:24.

  JvmAgs : -Xss128k

 */
public class Jvm02JavaVMStackSOF {
    private int stackLength = 1;//栈内存

    public void stackLeak() {
        stackLength++;
        stackLeak();
    }

    public static void main(String[] args) throws Throwable {
        Jvm02JavaVMStackSOF oom = new Jvm02JavaVMStackSOF();
        try {
            oom.stackLeak();
        } catch (Throwable e) {
            System.out.println("stack length：" + oom.stackLength);
            throw e;
        }
    }
}
```

#### 2.2.2、异常分析

```java
stack length：1547
Exception in thread "main" java.lang.StackOverflowError
	at com.hlj.moudle.jvm001.service.JavaVMStackSOF.stackLeak(JavaVMStackSOF.java:15)
	at com.hlj.moudle.jvm001.service.JavaVMStackSOF.stackLeak(JavaVMStackSOF.java:15)
	at com.hlj.moudle.jvm001.service.JavaVMStackSOF.stackLeak(JavaVMStackSOF.java:15)
```

答案：
操作系统分配给每个进程的内存是有限制的，虚拟机提供了参数来控制方法区（非堆区）和Java堆区这两部分的最大值（MaxPermSize和Xmx）
<br/>

操作系统剩余的内存减去`Xmx（最大堆区容量）`和`MaxPermSize（最大方法区容量）`，，程序计数器内存消耗很小可以忽略掉，如果虚拟机进程本身消耗的内存不计算在内，剩下的就给了虚拟机栈和本地方法栈了。<br/>

每个线程分配到的栈容量越大，可以建立的线程数就越少，建立线程时就越容易将资源耗尽。<br/>

栈深度在大多数情况下达到1000到2000没有问题，对于正常的方法调用（包括递归），这个深度完全够用了，但是如果是建立多线程导致的内存溢出，在不能减少线程数，或者更换虚拟机的情况下，就只能通过减少最大堆（这样可以让栈区多一些）、减少线程分配的栈容量（如果当前线程占用的栈资源允许的情况下）

### 2、3、方法区和运行时常亮溢出


```java
package com.hlj.moudle.jvm001.service;


import java.util.ArrayList;
import java.util.List;

/**
 * @Description 3、 方法区和运行时常亮溢出
 * @Author HealerJean
 * @Date 2019/2/7  下午6:47.

  VM Args： -XX:PermSize=10M -XX:MaxPermSize=10M


 */
public class Jvm03RuntimeConstantPoolOOM {

    public static void main(String[] args) {
        // 使用 List 保持着常量池引用，避免 Full GC 回收常量池行为
        List<String> list = new ArrayList<String>();
        // 10MB 的 PermSize 在 integer 范围内足够产生 OOM 了
        int i = 0;
        while (true) {
            list.add(String.valueOf(i++).intern());
        }
    }
}


```


<br/><br/><br/>
如果满意，请打赏博主任意金额，感兴趣的请下方留言吧。可与博主自由讨论哦

|支付包 | 微信|微信公众号|
|:-------:|:-------:|:------:|
|![支付宝](https://raw.githubusercontent.com/HealerJean/HealerJean.github.io/master/assets/img/tctip/alpay.jpg) | ![微信](https://raw.githubusercontent.com/HealerJean/HealerJean.github.io/master/assets/img/tctip/weixin.jpg)|![微信公众号](https://raw.githubusercontent.com/HealerJean/HealerJean.github.io/master/assets/img/my/qrcode_for_gh_a23c07a2da9e_258.jpg)|




<!-- Gitalk 评论 start  -->

<link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk@latest/dist/gitalk.min.js"></script> 
<div id="gitalk-container"></div>    
 <script type="text/javascript">
    var gitalk = new Gitalk({
		clientID: `1d164cd85549874d0e3a`,
		clientSecret: `527c3d223d1e6608953e835b547061037d140355`,
		repo: `HealerJean.github.io`,
		owner: 'HealerJean',
		admin: ['HealerJean'],
		id: 'TTOEr7JyLy2zFRbh',
    });
    gitalk.render('gitalk-container');
</script> 

<!-- Gitalk end -->

