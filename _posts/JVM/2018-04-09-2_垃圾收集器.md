---
title: 2、垃圾收集器
date: 2018-04-09 13:33:00
tags: 
- JVM
category: 
- JVM
description: 垃圾收集器
---
<!-- image url 
https://raw.githubusercontent.com/HealerJean123/HealerJean123.github.io/master/blogImages
　　首行缩进
<font color="red">  </font>
-->

## 前言

垃圾收集器GC ，同通常需要考虑3个事情

+ 1、那些内存需要回收
+ 2、什么时候回收
+ 3、如何回收

 
### 1、不需要回收的

<font color="red">  程序计时器，虚拟机栈，本地方法栈</font>这3个区域都是线程所私有的，随着线程而生，而死。 关于栈的话，基本上就是在运行方法的时候开启一个栈帧。他们的内存大小和声明周期是已知的，因此这几个区域内存分配和回收都具备确定性，不需要过多考虑回收问题，因为他们在方法结束者是线程结束，内存自然的就被回收了

### 2、需要回收的

JAVA堆和方法去 则是需要被垃圾收集器回收的


## 1、判断对象是否活着

### 1.1、引用计数法

解释：给对象添加一个计时器，每当引用的时候加1，当引用失效时候减1，任何时候为0的对象就是不能再被使用的。（书上说，这样表达不太好）

<br/>
java虚拟机没有使用它来管理内存，因为它很难解决对象之间相互引用的问题

#### 1.1.1、测试代码

```
package com.hlj.jvm.GC;

/**
 * @Description
 * @Author HealerJean
 * @Date 2018/4/9  下午1:38.
 */
public class ReferenceCountingGC {

    public Object instance = null;

    private static  final int _1MB=1024 * 1024 ;

	/**
	 占点内存，以便在日志中看清楚是否被回收
	 */	
    private byte[] bigSize = new byte[1 * _1MB];

    public static void main(String[] args) {
        ReferenceCountingGC objA = new ReferenceCountingGC();
        ReferenceCountingGC objB = new ReferenceCountingGC();

        objA.instance = objB;
        objB.instance = objA;

        //加入这个时候发生GC，如果是jvm采用的是引用计数法的话，objA和objB不能被回收，
        // 因为他们互相引用这对方，导致他们的引用计数都不为0，
        // 于是引用计数算法，不能通知GC收集器回收他们
        System.gc();
         }
}
```

#### 1.1.2、idea查看GC日志


```
-XX:+PrintGCDetails

```

```
-XX:+PrintGC 输出GC日志
-XX:+PrintGCDetails 输出GC的详细日志
-XX:+PrintGCTimeStamps 输出GC的时间戳（以基准时间的形式）
-XX:+PrintGCDateStamps 输出GC的时间戳（以日期的形式，如 2013-05-04T21:53:59.234+0800）
-XX:+PrintHeapAtGC 在进行GC的前后打印出堆的信息
-Xloggc:../logs/gc.log 日志文件的输出路径
```

![WX20180409-135324@2x](https://raw.githubusercontent.com/HealerJean123/HealerJean123.github.io/master/blogImages/WX20180409-135324@2x.png)


#### 1.1.3、运行

>名称通过收集器而定
1、这里的收集器是Parallel Scavenge。新生代为PSYoungGen，老年代为ParOldGen，Metaspace代表元空间（JDK 8中用来替代永久代PermGen）。 
2、如果收集器为ParNew收集器，新生代为ParNew，Parallel New Generation <br/>
3、如果收集器是Serial收集器，新生代为DefNew，Default New Generation<br/>

```
[GC (System.gc()) [PSYoungGen: 5980K->2752K(76288K)] 5980K->2760K(251392K), 0.0023918 secs] [Times: user=0.01 sys=0.00, real=0.00 secs] 
[Full GC (System.gc()) [PSYoungGen: 2752K->0K(76288K)] [ParOldGen: 8K->2621K(175104K)] 2760K->2621K(251392K), [Metaspace: 3139K->3139K(1056768K)], 0.0057354 secs] [Times: user=0.02 sys=0.00, real=0.01 secs] 
Heap
 PSYoungGen      total 76288K, used 1966K [0x000000076ab00000, 0x0000000770000000, 0x00000007c0000000)
  eden space 65536K, 3% used [0x000000076ab00000,0x000000076aceba38,0x000000076eb00000)
  from space 10752K, 0% used [0x000000076eb00000,0x000000076eb00000,0x000000076f580000)
  to   space 10752K, 0% used [0x000000076f580000,0x000000076f580000,0x0000000770000000)
 ParOldGen       total 175104K, used 2621K [0x00000006c0000000, 0x00000006cab00000, 0x000000076ab00000)
  object space 175104K, 1% used [0x00000006c0000000,0x00000006c028f420,0x00000006cab00000)
 Metaspace       used 3146K, capacity 4496K, committed 4864K, reserved 1056768K
  class space    used 344K, capacity 388K, committed 512K, reserved 1048576K
```
<font color="red"> 这就说明JDK8的HotSpot虚拟机并没有采用引用计数算法来标记内存，它对上述代码中的两个死亡对象的引用进行了回收。(因为内存变小，肯定是回收了，要不然能变么) 具体看下面</font>



1、可以看到上面有两种GC类型：GC和Full GC，有Full表示这次GC是发生了Stop-The-World（即在执行垃圾收集算法时,Java应用程序的其他所有除了垃圾收集收集器线程之外的线程都被挂起，因为执行了`System.gc();`）
<br/>

新生代GC（Minor GC）：指发生在新生代的垃圾收集动作，因为Java对象大多都具备朝生夕灭的特性，所以Minor GC非常频繁，一般回收速度非常快。
老年代GC（Major GC/Full GC）：指发生在老年代的GC，出现了Major GC，经常会伴随至少一次的Minor GC，Major GC的速度一般会比Minor GC慢10倍以上。

 
<br/>

```
[GC (System.gc()) [PSYoungGen: 5980K->2752K(76288K)] 5980K->2760K(251392K), 0.0023918 secs] [Times: user=0.01 sys=0.00, real=0.00 secs] 
```
2、上面方括号内部的5980K->2752K(76288K)，表示GC前该内存区域已使用容量->GC后该内存区域已使用容量，后面圆括号里面的76288K为该内存区域的总容量。<br/>

方括号外面的5980K->2760K(251392K)，表示GC前Java堆已使用容量->GC后Java堆已使用容量，后面圆括号里面的251392K为Java堆总容量。


```
[Times: user=0.01 sys=0.00, real=0.00 secs] 
```
3、[Times: user=0.01 sys=0.00, real=0.00 secs] 

+ 分别表示用户消耗的CPU时间，
+ 内核态消耗的CPU时间
+ 操作从开始到结束所经过的墙钟时间（Wall Clock Time），

CPU时间和墙钟时间的差别是，墙钟时间包括各种非运算的等待耗时，例如等待磁盘I/O、等待线程阻塞，而CPU时间不包括这些耗时。






### 2、可达性分析算法

> 解释:这个算法的基本思路就是通过一系列名为GC Roots的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链(Reference Chain)，当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的，下图对象object5, object6, object7虽然有互相判断，但它们到GC Roots是不可达的，所以它们将会判定为是可回收对象。

![WX20180409-141558@2x](https://raw.githubusercontent.com/HealerJean123/HealerJean123.github.io/master/blogImages/WX20180409-141558@2x.png)

可以作为GC Roots的对象包括下面几种

	.	虚拟机栈(栈桢中的本地变量表)中的引用的对象
	.	本地方法栈中JNI（Native方法）的引用的对象
	.	方法区中的类静态属性引用的对象
	.	方法区中的常量引用的对象



## 2、垃圾收集，一定非死不可吗

解释：

即使在可达性分析算法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑”阶段，<font color="red">  要真正宣告一个对象死亡，至少要经历两次标记过程</font>:

+ 如果对象在进行可达性分析后发现没有与GC Roots 相连接的引用链，那它将会被第一次标记并且进行一次筛选，
+ 筛选的条件是此对象是否有必要执行finalize() 方法。当对象没有覆盖finalize() 方法，或者finalize() 方法已经被虚拟机调用过，虚拟机将这两种情况都视为“没有必要执行”。这样就会被垃圾收集器调用回收。如下


```
package com.hlj.jvm.GC;

/*
 * @Description
 * @Author HealerJean
 * @Date 2018/4/9  下午3:30.
 *
 *此代码演示了两点
 * 对象可以在GC时自我拯救
 * 这种自救只会有一次，因为一个对象的finalize方法只会被自动调用一次
 * */
public class FinalizeEscapeGC {
    public static FinalizeEscapeGC SAVE_HOOK=null;
    public void isAlive(){
        System.out.println("yes我还活着");
    }

    public void finalize() throws Throwable{
        super.finalize();
        System.out.println("执行finalize方法");
        FinalizeEscapeGC.SAVE_HOOK=this;//自救
    }

    public static void main(String[] args) throws InterruptedException{
        SAVE_HOOK=new FinalizeEscapeGC();


        //对象的第一次回收
        SAVE_HOOK=null;
        System.gc();
        //因为finalize方法的优先级很低所以暂停0.5秒等它
        Thread.sleep(500);
        if(SAVE_HOOK!=null){
            SAVE_HOOK.isAlive();
        }else{
            System.out.println("no我死了");
        }


        //下面的代码和上面的一样，但是这次自救却失败了，因为finalize方法已经调用过一次，而且它只能执行一次
        //对象的第二次回收
        SAVE_HOOK=null;
        System.gc();
        Thread.sleep(500);
        if(SAVE_HOOK!=null){
            SAVE_HOOK.isAlive();
        }else{
            System.out.println("no我死了");
        }
    }
}
```

运行结果，说明第一次成功逃脱，finalize为对象逃脱的最后一次机会

```
执行finalize方法
yes我还活着
no我死了

```


## 3、回收方法区

大部分都认为方法区（也叫永久代）是没有垃圾回收的，Java虚拟机规范中也说过不要求虚拟机在方法区实现垃圾收集，而且在方法区中进行垃圾收集性价比很低。一帮情况下载新生代中回收的性价比比较高

### 3.1、回收内容

废弃常亮和无用的类，当然回收是可以，而不是一定能够回收 

#### 3.1.2、无用的类

（1）该类所有的实例都已经被回收，即Java堆中不存在该类的任何实例； 
（2）加载该类的ClassLoader已经被回收； 
（3）该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。

#### 3.1.3、回收方法和场景

##### 1、回收方法

虚拟机可以对满足上述3个条件的无用类进行回收，这里说的仅仅是“可以”，而不是和对象一样，不使用了就必然会回收。是否对类进行回收，HotSpot虚拟机提供了-Xnoclassgc参数进行控制，还可以使用-verbose:class及-XX:+TraceClassLoading、 -XX:+TraceClassUnLoading查看类的加载和卸载信息。

###### 回收场景

2、在大量使用反射、动态代理、CGLib等bytecode框架的场景，以及动态生成JSP和OSGi**这类频繁自定义ClassLoader的场景**都需要虚拟机具备类卸载的功能，以保证永久代不会溢出。


## 4、垃圾收集算法

不同平台的虚拟机操作内存的方法是不同的，这里主要介绍下几种算法的思想和发展过程

### 4.1、标记-清除算法

> 很明显，两个阶段，标记和清除踏实最基础的算法，因为后续的手机算法都是基于这种思路并对他的不足进行改进而得到的
> 不足有两处
> 1、效率问题：这两个过程效率都不高
> 2、空间问题：标记清除会产生大量不连续的碎片，碎片太多费配给大的对象的时候，无法找到连续的控件而不得不触发另一次垃圾收集动作

![WX20180409-165031@2x](https://raw.githubusercontent.com/HealerJean123/HealerJean123.github.io/master/blogImages/WX20180409-165031@2x.png)


### 4.2、复制算法

>为了解决上面的效率问题，就出现了复制，它将内存分为大学相等的两块，每次只使用其中一块，`当这一块的内存满了`，就会将里面活着的对象复制到另一块上面，然后再把已经使用过的空间一次清理掉（牛逼了，相当于的夫妻二人大家，满了就跑）
>
>这样就不需要考虑是否存在碎片了，但是但是，它他妈的把内存缩小了一半，这代价太高了


![WX20180409-165738@2x](https://raw.githubusercontent.com/HealerJean123/HealerJean123.github.io/master/blogImages/WX20180409-165738@2x.png)


#### 4.2.1、使用

>现在的商业虚拟机都采用这种收集算法手机`新生代`，IBM公司研究到其实新生代中的对象98%都是早上出生，晚上就挂了。所以其实不需要1：1来配置，而是分成3块，一块较大的和两块较小的 比为8：1：1。
><br/>
>每次使用的时候，都是使用一个快大的和一块小的，当垃圾收集器回收的时候，就会把这两个上面存活的对象放到另外一个小的上面。然后清理刚刚的那两个空间。 这个时候，如果继续使用的话，就会继续放到大的上面。也就是说，只会浪费10%的空间
><br/>
>从实际出发，其实我们不能保证每次都只有10%的对象存活，但是当它这个小的空间不够用的时候，会依赖其他内存进行分配担保。这个时候这些对象就会进入`老年代`。关于担保后面讲吧，哈哈，是不是很简单呢


### 4.3、标记-整理算法

><font color="red">  复制算法在存活率特别高的时候，效率就会降低，更关键的是，老年代存活率高，假如所有对象对100%存活，那么需要有额外的空间来进行担保。所以在老年代一般不能使用这种算法。</font>老人不是喜欢收拾东西吗，哈哈，标记整理吧
>
>这里不是讲标记的对象之间进行清理，而是先将可用的对象都像一边移动，然后之间清理掉除它以外的内容

![WX20180409-171221@2x](https://raw.githubusercontent.com/HealerJean123/HealerJean123.github.io/master/blogImages/WX20180409-171221@2x.png)



### 4.4、分代收集算法

> 当前商业虚拟机都采用这种算法来收集，这种算法将对象存活周期的不同而将Java堆分为新生代和老年代，
> 1、在新生代总每次都有大量的对象死去，只有少量存活，就使用复制算法，这样就付出存活少量对象的复制成本就可以完成收集，
> 
> 2、但是老年代因为存活率高，没有额外的空间为它担保就必须使用标记-清除或者是标记-整理算法。



<br/><br/><br/>
如果满意，请打赏博主任意金额，感兴趣的请下方留言吧。可与博主自由讨论哦

|支付包 | 微信|微信公众号|
|:-------:|:-------:|:------:|
|![支付宝](https://raw.githubusercontent.com/HealerJean123/HealerJean123.github.io/master/assets/img/tctip/alpay.jpg) | ![微信](https://raw.githubusercontent.com/HealerJean123/HealerJean123.github.io/master/assets/img/tctip/weixin.jpg)|![微信公众号](https://raw.githubusercontent.com/HealerJean123/HealerJean123.github.io/master/assets/img/my/qrcode_for_gh_a23c07a2da9e_258.jpg)|




<!-- Gitalk 评论 start  -->

<link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk@latest/dist/gitalk.min.js"></script> 
<div id="gitalk-container"></div>    
 <script type="text/javascript">
    var gitalk = new Gitalk({
		clientID: `1d164cd85549874d0e3a`,
		clientSecret: `527c3d223d1e6608953e835b547061037d140355`,
		repo: `HealerJean123.github.io`,
		owner: 'HealerJean123',
		admin: ['HealerJean123'],
		id: 'GIGpj1NIXBs21OGz',
    });
    gitalk.render('gitalk-container');
</script> 

<!-- Gitalk end -->

