---
title: 8、虚拟机类加载机制
date: 2018-04-11 17:33:00
tags: 
- JVM
category: 
- JVM
description: 虚拟机类加载机制
---
<!-- image url 
https://raw.githubusercontent.com/HealerJean/HealerJean.github.io/master/blogImages
　　首行缩进
<font color="red">  </font>
-->

## 前言


下面使用static进行说明下


```java
1、父类
public class SuperClass {
    static{
        System.out.println("super class init!");
    }
    public static int a = 1;
    public final static int b = 1;
}

2、子类
public class SubClass extends SuperClass{
    static{
        System.out.println("SubClass init!");
    }
}
3、测试
public class Test {

    static{
        System.out.println("test class init!");
    }

    public static void main(String[] args){
        System.out.println(SubClass.a);
    }
}

控制台
test class init!
super class init!
1

解释：很明显没有输出子类SubClass中的static代码块的信息，对于静态字段，只有直接定义这个类的字段的类才会被加载。

当子类添加一个静态字段的时候

public class SubClass extends SuperClass{
    static{
        System.out.println("SubClass init!");
    }

    public static int s = 2; //对于静态字段，只有指定定义这个字段的类才会初始化
}

public class Test {

    static{
        System.out.println("test class init!");
    }

    public static void main(String[] args){
        System.out.println(SubClass.s);
    }
}

控制台
test class init!
super class init!
SubClass init!
2

解释:当初始化类的时候，如果他的父类还没有被初始化，则需要先初始化它的父类，和上面的其实也不冲突啦


当
public final static int s = 2; //变成final常亮的时则不会初始化任何，因为它放到了常亮池中，并不是在类中获取的，所以不需要初始化，控制台只会打印出2


```


　　

## 1、类加载的时机

类从被加载到虚拟机内存开始，到卸载出内存为止，它的整个生命周期包括，加载、验证、准备、解析、初始化、使用、卸载7个阶段，其中验证、准备、解析3个被称为连接

![WX20180411-180608@2x](https://raw.githubusercontent.com/HealerJean/HealerJean.github.io/master/blogImages/WX20180411-180608@2x.png)

类加载 在加载、验证、准备、初始化、卸载 这5个阶段顺序是固定的，解析阶段则不一定，在某些情况下，解析阶段有可能在初始化阶段结束后开始，以支持Java的动态绑定。

关于第一个阶段加载：虚拟机规范中并没有强制约束，这个交给虚拟机自由把控，但是对于初始化，有且只有5种情况必须立即对类进行初始化（当然它前面的三个肯定执行了）

1、遇到new 的时候，以及调用一个被static修饰的字段，（被final除外，因为它以及放到常量池中去了）

2、遇到反射调用的时候，记得是调用哦

3、当初始化一个类的时候，如果发现父类还有没有经过初始化，需要先初始化父类，尊重父亲懂吧

4、当虚拟机启动的时候，执行的main的主类


5、不太懂，到时候再说吧，


## 2、类加载的过程

也就是加载、验证、准备、解析、初始化这5个阶段的具体过程，

### 2.1 、加载 
加载是类加载的第一个阶段，这个阶段，虚拟机完成3件事情，

#### 1、通过一个类的全限定名来获取定义此类的二进制字节流

这个地方就厉害了，JAVA开发团队说的很模糊啊，充满智力的开发人员在这个基础上，从jar获取，从war获取，从动态代理proxy中获取等等

#### 2、将这个字节流所代表的静态存储结构转化为方法区的运行时存储结构（

#### 3、在内存中生成一个java.lang.Class对象，作为方法区这个类的各种数据的访问入口

### 2.2、验证

确保class文件的字节流中包含的信息符合当前虚拟机的要求

#### 1、文件格式验证
1、是否魔数为0XCAFEBABE开头
2、主次版本号是否在范围
等

##### 2、元数据验证
判断是否符合java语法规范的眼球
是否有父类，是否继承了不允许继承的父类（final修饰）

#### 3、字节码验证

操作栈总放了int，但是使用的时候却使用了long

#### 4、符号引用验证
这个校验发送在解析阶段
符号引用的类，字段，方法的访问性质（private，protected等是否可以被当前类访问）

### 2.3、准备：正式为类变量分配内存并设置类变量初始值的阶段

<font color="red">  

准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在方法区中进行分配，需要注意的是仅包括static修饰的变量，不包括实例变量，</font>实例变量会在对象实例化时候分配到java堆中。这里说的初始值，通常情况下是数据类型的0值，假设一个类变量的定义为



```java

public static int value = 123
```

那么变量在准备阶段过后的初始值为0，而不是123，因为这个时候还没有执行java方法，123的动作在初始化阶段才会执行。<br/>

<font color="red">  
如果上面是被final修饰，则在准备阶段就会将123赋值给它</font>

### 2.4、解析

#### 1、类或接口的解析
#### 2、字段解析  

比如，如果实现了接口，就会看看把父接口的拿下来

#### 3、类方法解析
#### 4、接口方法解析 


### 2.5、初始化阶段

真正开始执行程序员java代码

## 3、类加载器


### 1、什么是类加载机制

虚拟机将描述类的数据从Class文件加载到内存，并对数据进行校验，转换解析，准备到初始化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的类加载机制

### 2、什么是类加载器classLoader及加载过程

#### 官方：

虚拟机设计团队，把类加载阶段中的，通过一个类的全限名称来描述二进制字节流，这个动作放到Java虚拟机外部去实现，以便让应用程序自己决定如何去获取所需要的类，<font color="red">实现这个动作的代码模块成为类加载器</font>。

#### 字面理解：

　　Java程序（class文件）并不是本地的可执行程序。当运行Java程序时，首先运行JVM（Java虚拟机），然后再把Java class加载到JVM里头运行，负责加载Java class的这部分就叫做Class Loader。所以classLoader的目的在于把class文件装入到jvm中。


### 3、不同的类加载器

从java虚拟机的角度看看，只存在两种不同的类加载器，一种是启动类加载器Bootstrap ClassLoader ,这个类加载器使用C++实现，是虚拟机自身的一部分<br/>

另一个种是由java语言实现，独立于虚拟机外部，并且全都继承自抽象类Java.lang.ClassLoader

Java语言系统自带有三个类加载器: 

#### 1）启动类加载器（Bootstrap ClassLoader）：最顶层的加载类

这个类加载器负责将存放在`%JAVA_HOME%\lib`目录中的，或者被-Xbootclasspath参数所指定的路径中的，并且是虚拟机识别的（**仅按照文件名识别，如rt.jar，名字不符合的类库即使放在lib目录中也不会被加载**）类库加载到虚拟机内存中。启动类加载器无法被Java程序直接引用，因为他是虚拟机的一部分<br/>


```java
  @Test
    public void bootClassPath(){
        System.out.println(System.getProperty("sun.boot.class.path"));

        // /Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home/jre/lib/resources.jar:
        // /Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home/jre/lib/rt.jar:
        // /Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home/jre/lib/sunrsasign.jar:
        // /Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home/jre/lib/jsse.jar:
        // /Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home/jre/lib/jce.jar:
        // /Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home/jre/lib/charsets.jar:
        // /Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home/jre/lib/jfr.jar:
        // /Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home/jre/classes
    }
```

#### 2）扩展类加载器（Extension ClassLoader）：

这个加载器由`sun.misc.Launcher.ExtClassLoader`实现，它负责加载＜JAVA_HOME＞\lib\ext目录中的，或者被java.ext.dirs系统变量所指定的路径中的所有类库，开发者可以直接使用扩展类加载器。


```java
  @Test
    public void ExtClassLoaderClassPath(){
        System.out.println(System.getProperty("java.ext.dirs"));
        
        //  /Users/healerjean/Library/Java/Extensions:
        //  /Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home/jre/lib/ext:
        //  /Library/Java/Extensions:/Network/Library/Java/Extensions:/System/Library/Java/Extensions:
        //  /usr/lib/java

    }
```

#### 3）应用程序类加载器（Application ClassLoader）：

这个类加载器`sun.misc.Launcher.AppClassLoader`实现。由于这个类加载器是ClassLoader中的getSystemClassLoader()方法的返回值，所以一般也称它为系统类加载器。它负责加载用户类路径（Class Path）上所指定的类库，开发者可以直接使用这个类加载器<br/>
<font color="red">  
如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</font>



```java
System.out.println(System.getProperty("java.class.path"));

D:\workspace\ClassLoaderDemo\bin

```



## 1、测试

### 1.1、3个类加载器，执行顺序(先给结果)

具体看sun.misc.Launcher,它是一个java虚拟机的入口应用。

```
1. Bootstrap CLassloder 
2. Extention ClassLoader 
3. Application  ClassLoader
4. 
```

### 1.2、Launcher代码解释

代码有精简，具体自己看

```

1. Launcher初始化了ExtClassLoader和AppClassLoader。 
2. 
2. Launcher中并没有看见BootstrapClassLoader，但通过System.getProperty("sun.boot.class.path")得到了字符串bootClassPath,这个应该就是BootstrapClassLoader加载的jar包路径。


```


```java
public class Launcher {
    private static Launcher launcher = new Launcher();
    private static String bootClassPath =
        System.getProperty("sun.boot.class.path");
 
    public static Launcher getLauncher() {
        return launcher;
    }
 
    private ClassLoader loader;
 
    public Launcher() {
        // Create the extension class loader
        ClassLoader extcl;
        try {
            extcl = ExtClassLoader.getExtClassLoader();
        } catch (IOException e) {
            throw new InternalError(
                "Could not create extension class loader", e);
        }
 
        // Now create the class loader to use to launch the application
        try {
            loader = AppClassLoader.getAppClassLoader(extcl);
        } catch (IOException e) {
            throw new InternalError(
                "Could not create application class loader", e);
        }
 
        //设置AppClassLoader为线程上下文类加载器，这个文章后面部分讲解
        Thread.currentThread().setContextClassLoader(loader);
    }
 
    /*
     * Returns the class loader used to launch the main application.
     */
    public ClassLoader getClassLoader() {
        return loader;
    }
    /*
     * The class loader used for loading installed extensions.
     */
    static class ExtClassLoader extends URLClassLoader {}
 
/**
     * The class loader used for loading from java.class.path.
     * runs in a restricted security context.
     */
    static class AppClassLoader extends URLClassLoader {}
```

## 2、编写代码查看
新建两个类

```java
public class Jvm02Test {
}

```


### 1、自己编写的是由AppClassLoader加载的

```java
public class Jvm02ClassLoader {


    /**
     * 1、 也就是说明Jvm02Test.class文件是由AppClassLoader加载的。
     */
    @Test
    public  void testClassLoader (){

        ClassLoader classLoader = Jvm02Test.class.getClassLoader();

        System.out.println("ClassLoader is:" + classLoader.toString());
        // ClassLoader is:sun.misc.Launcher$AppClassLoader@18b4aac2
    }
    
}

```

也就是说明Jvm02Test.class文件是由AppClassLoader加载的。



### 2、系统自带的int String是通过谁加载呢


```java

    @Test
    public void intClassLoader(){

      ClassLoader  classLoader = int.class.getClassLoader() ;
      System.out.println("int is:" + classLoader.toString());
      //空指针异常
      //java.lang.NullPointerException

      ClassLoader stringClassLoader = String.class.getClassLoader() ;
      System.out.println(stringClassLoader.toString());
//     java.lang.NullPointerException
    }
```

提示的是空指针，意思是int.class这类基础类没有类加载器加载？<br/>

当然不是！ 
int.class是由Bootstrap ClassLoader加载的。要想弄明白这些，我们首先得知道一个前提。<br/>
<font color="red">每个类加载器都有一个父加载器,通过getParent方法</font>



### 3、父加载器

```java


    @Test
    public void classLoaderParent(){

        ClassLoader classLoader = Jvm02Test.class.getClassLoader();

        System.out.println("ClassLoader is:" + classLoader.toString());
//        AppClassLoader
//        打印信息：" ClassLoader is:sun.misc.Launcher$AppClassLoader@18b4aac2

        System.out.println("ClassLoader\'s parent is:"+classLoader.getParent().toString());
//       ExtClassLoader@
//       打印信息："   ClassLoader's parent is:sun.misc.Launcher$ExtClassLoader@531d72ca

/*
        ClassLoader is:sun.misc.Launcher$AppClassLoader@18b4aac2
        ClassLoader's parent is:sun.misc.Launcher$ExtClassLoader@531d72ca
*/
    }
    
```

这个说明，AppClassLoader的父加载器是ExtClassLoader。那么ExtClassLoader的父加载器又是谁呢？




### 4、ExtClassLoader的父加载器

```java

  @Test
    public  void testGrandClassLoader (){

        ClassLoader classLoader = Jvm02Test.class.getClassLoader();

        System.out.println("ClassLoader is:" + classLoader.toString());
        // ClassLoader is:sun.misc.Launcher$AppClassLoader@18b4aac2
        System.out.println("ClassLoader\'s parent is:"+classLoader.getParent().toString());
        //ClassLoader's parent is:sun.misc.Launcher$ExtClassLoader@3941a79c
        System.out.println("ClassLoader\'s grand father is:"+classLoader.getParent().getParent().toString());
        //跑出了异常，空指针
        //Exception in thread "main" java.lang.NullPointerException

    /*
         ClassLoader is:sun.misc.Launcher$AppClassLoader@18b4aac2
         ClassLoader's parent is:sun.misc.Launcher$ExtClassLoader@531d72ca

        java.lang.NullPointerException

     */
    }
    
    
```


又是一个空指针异常，这表明ExtClassLoader也没有父加载器。那么，为什么标题又是每一个加载器都有一个父加载器呢？这不矛盾吗？为了解释这一点，我们还需要看下面的一个基础前提。


### 5、父加载器不是父类

launch中已经有了下面这两个内部类


```java
static class ExtClassLoader extends URLClassLoader {
……
}
static class AppClassLoader extends URLClassLoader {
……
}


```

可以看见ExtClassLoader和AppClassLoader同样继承自URLClassLoader<br/>

<font color="red">但上面一小节代码中，为什么调用AppClassLoader的getParent()代码会得到ExtClassLoader的实例呢？先从URLClassLoader说起，这个类又是什么？ </font>



![WX20190208-161242@2x](https://raw.githubusercontent.com/HealerJean/HealerJean.github.io/master/blogImages/WX20190208-161242@2x.png)

### 6、URLClassLoader

URLClassLoader的源码中并没有找到getParent()方法。这个方法在ClassLoader.java中。


```java

public class URLClassLoader extends SecureClassLoader implements Closeable {}


public class SecureClassLoader extends ClassLoader {}




public abstract class ClassLoader {
 
// The parent class loader for delegation
// Note: VM hardcoded the offset of this field, thus all new fields
// must be added *after* it.
private final ClassLoader parent;
// The class loader for the system
    // @GuardedBy("ClassLoader.class")
private static ClassLoader scl;
 
private ClassLoader(Void unused, ClassLoader parent) {
    this.parent = parent;
    ...
}
protected ClassLoader(ClassLoader parent) {
    this(checkCreateClassLoader(), parent);
}
protected ClassLoader() {
    this(checkCreateClassLoader(), getSystemClassLoader());
}
public final ClassLoader getParent() {
    if (parent == null)
        return null;
    return parent;
}
public static ClassLoader getSystemClassLoader() {
    initSystemClassLoader();
    if (scl == null) {
        return null;
    }
    return scl;
}
 
private static synchronized void initSystemClassLoader() {
    if (!sclSet) {
        if (scl != null)
            throw new IllegalStateException("recursive invocation");
        sun.misc.Launcher l = sun.misc.Launcher.getLauncher();
        if (l != null) {
            Throwable oops = null;
            //通过Launcher获取ClassLoader
            scl = l.getClassLoader();
            try {
                scl = AccessController.doPrivileged(
                    new SystemClassLoaderAction(scl));
            } catch (PrivilegedActionException pae) {
                oops = pae.getCause();
                if (oops instanceof InvocationTargetException) {
                    oops = oops.getCause();
                }
            }
            if (oops != null) {
                if (oops instanceof Error) {
                    throw (Error) oops;
                } else {
                    // wrap the exception
                    throw new Error(oops);
                }
            }
        }
        sclSet = true;
    }
}
}

```

我们可以看到getParent()实际上返回的就是一个ClassLoader对象parent，parent的赋值是在ClassLoader对象的构造方法中，它有两个情况： 


#### 1. 由外部类创建ClassLoader时直接指定一个ClassLoader为parent。 

#### 2. 由getSystemClassLoader()方法生成，也就是说在sun.misc.Laucher通过getClassLoader()获取，直白的说，一个ClassLoader创建时如果没有指定parent，那么它的parent默认就是AppClassLoader。（相当于上面的Jvm01Test.class 获取clssLoader其实就是自己的parent，默认）




```java
public class Launcher {

    private ClassLoader loader;


    public Launcher() {
        Launcher.ExtClassLoader var1;
        try {
            var1 = Launcher.ExtClassLoader.getExtClassLoader();
        } catch (IOException var10) {
            throw new InternalError("Could not create extension class loader", var10);
        }

        try {
            this.loader = Launcher.AppClassLoader.getAppClassLoader(var1);
        } catch (IOException var9) {
            throw new InternalError("Could not create application class loader", var9);
        }
```



```java

 Launcher.ExtClassLoader var1;

var1 = Launcher.ExtClassLoader.getExtClassLoader(); //什么都不传入，null


 this.loader = Launcher.AppClassLoader.getAppClassLoader(var1); //生成自己的父加载器


```

AppClassLoader的parent是ExtClassLoader，ExtClassLoader的parent是nul<br/>

ExtClassLoader的父加载器为null,但是Bootstrap CLassLoader却可以当成它的父加载器这又是为何呢？

### 6、Bootstrap ClassLoader是由C++编写的。

Bootstrap ClassLoader是由C/C++编写的，它本身是虚拟机的一部分，所以它并不是一个JAVA类，也就是无法在java代码中获取它的引用，JVM启动时通过Bootstrap类加载器加载rt.jar等核心jar包中的class文件，之前的int.class,String.class都是由它加载。<br/>
    
然后呢，**我们前面已经分析了，JVM初始化sun.misc.Launcher并创建Extension ClassLoader和AppClassLoader实例。并将ExtClassLoader设置为AppClassLoader的父加载器。Bootstrap没有父加载器，但是它却可以作用一个ClassLoader的父加载器。比如ExtClassLoader。这也可以解释之前通过ExtClassLoader的getParent方法获取为Null的现象。具体是什么原因，很快就知道答案**

## 3、双亲委托（终于来到这里）

![20170211135054825](https://raw.githubusercontent.com/HealerJean/HealerJean.github.io/master/blogImages/20170211135054825.png)



一个类加载器查找class和resource时，是通过“委托模式”进行的，它首先判断这个class是不是已经加载成功，如果没有的话它并不是自己进行查找，而是先通过父加载器，然后递归下去，直到Bootstrap ClassLoader，如果Bootstrap classloader找到了，直接返回，如果没有找到，则一级一级返回，最后到达自身去查找这些对象。这种机制就叫做双亲委托。 



具体解释：
#### 1. 一个AppClassLoader查找资源时，先看看缓存是否有，缓存有从缓存中获取，否则委托给父加载器。 

#### 2. 递归，重复第1部的操作。 

#### 3. 如果ExtClassLoader也没有加载过，则由Bootstrap ClassLoader出面，它首先查找缓存，如果没有找到的话，就去找自己的规定的路径下，也就是`sun.mic.boot.class`下面的路径。找到就返回，没有找到，让子加载器自己去找。

#### 4. Bootstrap ClassLoader如果没有查找成功，则ExtClassLoader自己在`java.ext.dirs`路径中去查找，查找成功就返回，查找不成功，再向下让子加载器找。

#### 5. ExtClassLoader查找不成功，AppClassLoader就自己查找，在`java.class.path`路径下查找。找到就返回。如果没有找到就让子类找，如果没有子类会怎么样？抛出各种异常。


## 4、重要方法

### loadClass


```java
protected Class<?> loadClass(String name, boolean resolve)
        throws ClassNotFoundException
    {
        synchronized (getClassLoadingLock(name)) {
            // 首先，检测是否已经加载
            Class<?> c = findLoadedClass(name);
            if (c == null) {
                long t0 = System.nanoTime();
                try {
                    if (parent != null) {
                        //父加载器不为空则调用父加载器的loadClass
                        c = parent.loadClass(name, false);
                    } else {
                        //父加载器为空则调用Bootstrap Classloader，前面说过ExtClassLoader的parent为null，所以它向上委托时，系统会为它指定Bootstrap ClassLoader。
                        c = findBootstrapClassOrNull(name);
                    }
                } catch (ClassNotFoundException e) {
                    // ClassNotFoundException thrown if class not found
                    // from the non-null parent class loader
                }
 
                if (c == null) {
                    // If still not found, then invoke findClass in order
                    // to find the class.
                    long t1 = System.nanoTime();
                    //父加载器没有找到，则调用findclass
                    c = findClass(name);
 
                    // this is the defining class loader; record the stats
                    sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);
                    sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);
                    sun.misc.PerfCounter.getFindClasses().increment();
                }
            }
            if (resolve) {
                //调用resolveClass()
                resolveClass(c);
            }
            return c;
        }
    }

```


## 4、自定义ClassLoader

不知道大家有没有发现，不管是Bootstrap ClassLoader还是ExtClassLoader等，这些类加载器都只是加载指定的目录下的jar包或者资源。如果在某种情况下，我们需要动态加载一些东西呢？比如从D盘某个文件夹加载一个class文件，或者从网络上下载class主内容然后再进行加载，这样可以吗？


### 1、自定义步骤

```
1、编写一个类继承自ClassLoader抽象类。
2、复写它的findClass()方法。
3、在findClass()方法中调用defineClass()

```
### 2、编辑一个测试文件

将它编译之后的class文件，放到一个任意的目录下面

```java

package com.hlj.moudle.Jvm03类加载器;

/**
 * @Description
 * @Author HealerJean
 * @Date 2019/2/8  下午3:45.
 */
public class Jvm02Test {


    public void say(){
        System.out.println("Say Hello");
    }


}


```

### 2、自定义ClassLoader示例之DiskClassLoader。


我们在findClass()方法中定义了查找class的方法，然后数据通过defineClass()生成了Class对象。




```java
package com.hlj.moudle.Jvm03类加载器;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;


/**
 * @Description
 * @Author HealerJean
 * @Date 2019/2/8  下午5:13.
 */
public class Jvm03DiskClassLoader extends ClassLoader{

        private String mLibPath;

        public Jvm03DiskClassLoader(String path) {
            // TODO Auto-generated constructor stub
            mLibPath = path;
        }

        @Override
        protected Class<?> findClass(String name) throws ClassNotFoundException {
            // TODO Auto-generated method stub

            String fileName = getFileName(name);

            File file = new File(mLibPath,fileName);

            try {
                FileInputStream is = new FileInputStream(file);

                ByteArrayOutputStream bos = new ByteArrayOutputStream();
                int len = 0;
                try {
                    while ((len = is.read()) != -1) {
                        bos.write(len);
                    }
                } catch (IOException e) {
                    e.printStackTrace();
                }

                byte[] data = bos.toByteArray();
                is.close();
                bos.close();

                return defineClass(name,data,0,data.length);

            } catch (IOException e) {
                // TODO Auto-
    
```

### 4、测试


```java
package com.hlj.moudle.Jvm03类加载器;

import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;

/**
 * @Description
 * @Author HealerJean
 * @Date 2019/2/8  下午5:16.
 */
public class Jvm03ClassLoaderTest {

    public static void main(String[] args) {
        // TODO Auto-generated method stub

        //创建自定义classloader对象。
        Jvm03DiskClassLoader diskLoader = new Jvm03DiskClassLoader("/Users/healerjean/Desktop");
        try {
            //加载class文件
            Class c = diskLoader.loadClass("com.hlj.moudle.Jvm03类加载器.Jvm02Test");

            if (c != null) {
                try {
                    Object obj = c.newInstance();
                    Method method = c.getDeclaredMethod("say", null);
                    //通过反射调用Test类的say方法
                    method.invoke(obj, null);
                } catch (InstantiationException | IllegalAccessException
                        | NoSuchMethodException
                        | SecurityException |
                        IllegalArgumentException |
                        InvocationTargetException e) {
                    // TODO Auto-generated catch block
                    e.printStackTrace();
                }
            }
        } catch (ClassNotFoundException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }

    }

}

```

感谢博主 [https://blog.csdn.net/andyzhaojianhui/article/details/72829386](https://blog.csdn.net/andyzhaojianhui/article/details/72829386)


<br/><br/><br/>
如果满意，请打赏博主任意金额，感兴趣的请下方留言吧。可与博主自由讨论哦

|支付包 | 微信|微信公众号|
|:-------:|:-------:|:------:|
|![支付宝](https://raw.githubusercontent.com/HealerJean/HealerJean.github.io/master/assets/img/tctip/alpay.jpg) | ![微信](https://raw.githubusercontent.com/HealerJean/HealerJean.github.io/master/assets/img/tctip/weixin.jpg)|![微信公众号](https://raw.githubusercontent.com/HealerJean/HealerJean.github.io/master/assets/img/my/qrcode_for_gh_a23c07a2da9e_258.jpg)|




<!-- Gitalk 评论 start  -->

<link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk@latest/dist/gitalk.min.js"></script> 
<div id="gitalk-container"></div>    
 <script type="text/javascript">
    var gitalk = new Gitalk({
		clientID: `1d164cd85549874d0e3a`,
		clientSecret: `527c3d223d1e6608953e835b547061037d140355`,
		repo: `HealerJean.github.io`,
		owner: 'HealerJean',
		admin: ['HealerJean'],
		id: 'P0ov9ErbRJUfeP3L',
    });
    gitalk.render('gitalk-container');
</script> 

<!-- Gitalk end -->

