---
title: 设计模式之生成实例_Builder模式_组装复杂的实例
date: 2019-05-27 03:33:00
tags: 
- DesignPattern
category: 
- DesignPattern
description: 设计模式之生成实例_Builder模式_组装复杂的实例
---

<!-- 

https://raw.githubusercontent.com/HealerJean/HealerJean.github.io/master/blogImages/
　　首行缩进

<font  clalss="healerColor" color="red" size="5" >     </font>

<font  clalss="healerSize"  size="5" >     </font>
-->




## 前言

#### [博主github](https://github.com/HealerJean)
#### [博主个人博客http://blog.healerjean.com](http://HealerJean.github.io)    



在建造大楼的时候，需要先打牢低级，搭建框架，然后自下而上一层一层的建立起来，在建造比较复杂的结构的物体时候，很难一气呵成，我们需要首先建造组成这个物体的各个部分，然后分阶段将它们组装起来        





**builer模式就是用于组装复杂的实例**



### 1、示例程序 

![1558943323421](https://raw.githubusercontent.com/HealerJean/HealerJean.github.io/master/blogImages/1558943323421.png)







#### 1.1、示例程序UML

![1558943374736](https://raw.githubusercontent.com/HealerJean/HealerJean.github.io/master/blogImages/1558943374736.png)



#### 1.2、示例代码

##### 1.2.1、Builder （抽象类）

```java
package com.hlj.moudle.design.D05_生成实例.D07_Builder模式.Sample;

public abstract class Builder {

    /**
     * 编写标题
     * @param title
     */
    public abstract void makeTitle(String title);

    /**
     * 编写字符串
     * @param str
     */
    public abstract void makeString(String str);

    /**
     * 编写条目
     * @param items
     */
    public abstract void makeItems(String[] items);

    /**
     * 完成文档编写
     */
    public abstract void close();
}

```

##### 1.2.2、Director  (类，调用builer 编写一个具体的文档)

```java
package com.hlj.moudle.design.D05_生成实例.D07_Builder模式.Sample;

public class Director {
    private Builder builder;

    public Director(Builder builder) {              // 因为接收的参数是Builder类的子类
        this.builder = builder;                     // 所以可以将其保存在builder字段中
    }

    public void construct() {                       // 编写文档
        builder.makeTitle("Greeting");              // 标题

        builder.makeString("从早上至下午");         // 字符串
        builder.makeItems(new String[]{             // 条目
                "早上好。",
                "下午好。",
        });




        builder.makeString("晚上");                 // 其他字符串
        builder.makeItems(new String[]{             // 其他条目
                "晚上好。",
                "晚安。",
                "再见。",
        });
        builder.close();                            // 完成文档
    }
}

```



##### 1.2.3、TextBuilder （Builder实现类 ）

```java
package com.hlj.moudle.design.D05_生成实例.D07_Builder模式.Sample;

public class TextBuilder extends Builder {
    private StringBuffer buffer = new StringBuffer();           // 文档内容保存在该字段中

    public void makeTitle(String title) {                       // 纯文本的标题
        buffer.append("==============================\n");      // 装饰线
        buffer.append("『" + title + "』\n");                   // 为标题添加『』
        buffer.append("\n");                                    // 换行
    }

    public void makeString(String str) {                        // 纯文本的字符串
        buffer.append('■' + str + "\n");                       // 为字符串添加■
        buffer.append("\n");                                    // 换行
    }

    public void makeItems(String[] items) {                     // 纯文本的条目
        for (int i = 0; i < items.length; i++) {
            buffer.append("　・" + items[i] + "\n");            // 为条目添加・
        }
        buffer.append("\n");                                    // 换行
    }

    public void close() {                                       // 完成文档
        buffer.append("==============================\n");      // 装饰线
    }

    public String getResult() {                                 // 完成的文档
        return buffer.toString();                               // 将StringBuffer变换为String
    }
}

```

##### 1.2.4、HTMLBuilder （Bulder实现类）

```java
package com.hlj.moudle.design.D05_生成实例.D07_Builder模式.Sample;

import java.io.*;

public class HTMLBuilder extends Builder {
    private String filename;                                                        // 文件名
    private PrintWriter writer;                                                     // 用于编写文件的PrintWriter

    public void makeTitle(String title) {                                           // HTML文件的标题
        filename = title + ".html";                                                 // 将标题作为文件名
        try {
            writer = new PrintWriter(new FileWriter(filename));                     // 生成 PrintWriter
        } catch (IOException e) {
            e.printStackTrace();
        }
        writer.println("<html><head><title>" + title + "</title></head><body>");    // 输出标题
        writer.println("<h1>" + title + "</h1>");
    }

    public void makeString(String str) {                                            // HTML文件中的字符串
        writer.println("<p>" + str + "</p>");                                       // 用<p>标签输出
    }

    public void makeItems(String[] items) {                                         // HTML文件中的条目
        writer.println("<ul>");                                                     // 用<ul>和<li>输出
        for (int i = 0; i < items.length; i++) {
            writer.println("<li>" + items[i] + "</li>");
        }
        writer.println("</ul>");
    }

    public void close() {                                                           // 完成文档
        writer.println("</body></html>");                                           // 关闭标签
        writer.close();                                                             // 关闭文件
    }

    public String getResult() {                                                     // 编写完成的文档
        return filename;                                                            // 返回文件名
    }
}

```

##### 1.2.5、Main测试

```java
package com.hlj.moudle.design.D05_生成实例.D07_Builder模式.Sample;

public class Main {
    public static void main(String[] args) {

        usage();
        String name  = "plain" ;
        if (name.equals("plain")) {
            TextBuilder textbuilder = new TextBuilder();
            Director director = new Director(textbuilder);
            director.construct();
            String result = textbuilder.getResult();
            System.out.println(result);
        } else if (name.equals("html")) {
            HTMLBuilder htmlbuilder = new HTMLBuilder();
            Director director = new Director(htmlbuilder);
            director.construct();
            String filename = htmlbuilder.getResult();
            System.out.println(filename + "文件编写完成。");
        }


    }

    public static void usage() {
        System.out.println("Usage: java Main plain      编写纯文本文档");
        System.out.println("Usage: java Main html       编写HTML文档");
    }
}


```



### 2、BuIlder模式中登场的角色



#### 2.1、Biilder（建造者）

Buildet角色负责定义定义建造需要哪些步骤，也就是说这里定义一些建造房子需要的方法



#### 2.2、ConcreteBuiler （具体的建造者）

ConcreteBuiler角色是负责实现Builer中的抽象方法，在示例程序中 TextBuilder和HtmlBuilder类扮演这个角色

#### 2.3、Director （监工）

Director负责使用Builer角色的接口来生成实例，并不依赖与ConcreBuilter角色，为了确保不论ConcreBuilder角色是如果定义的，Direcotr都能正常工作，它只调用在Builer中定义的方法，示例程序中，又Direcotor来扮演此角色

#### 2.4、Client （使用者）

该角色使用了Builder模式，示例程序中，又Main扮演这个角色



### 3、UML

![1558945469921](https://raw.githubusercontent.com/HealerJean/HealerJean.github.io/master/blogImages/1558945469921.png)





### 4、Builder时序图

![1558945560375](https://raw.githubusercontent.com/HealerJean/HealerJean.github.io/master/blogImages/1558945560375.png)

### 5、扩展思路

Main并不知道Builder类，它只是调用了Director监工的construct方法，这样,Director就会开始工作，并完成文档的编写    

Director知道Builder类，它调用Builder类的方法来编写文档，但是并不知道它，真正调用的是哪个实现类，不过仔细想想，其实也没有必要知道，因为Direcotor只是用了Builder方法，而Builder的子类都已经实现了那些方法     

Direcotr **因为不知道Builder的子类才能替换** ，不论用了哪个子类都能替换，正式因为不知道才能替换，所以这个组件才具有高价值，我们必须时刻关注这种可替换性         



因为Diercotr中的方法都是Builder提供的，Builder还必须能够应对将来子类增加的需求，在上面我使用了两种文档格式，以后还可能遇到其他的，到底能不能支持新的需求，我们可能无法准确的做出判断，但是我们有必要尽可能应对近期的版本，仔细多想一些设想      

**个人理解：比如使用不同的平台进行签章，流程是一致的，替换起来也非常容易**   









<br/>
<br/>

<font  color="red" size="5" >     
感兴趣的，欢迎添加博主微信
 </font>

<br/>



哈，博主很乐意和各路好友交流，如果满意，请打赏博主任意金额，感兴趣的在微信转账的时候，备注您的微信或者其他联系方式。添加博主微信哦。    

请下方留言吧。可与博主自由讨论哦

|微信 | 微信公众号|支付宝|
|:-------:|:-------:|:------:|
| ![微信](https://raw.githubusercontent.com/HealerJean/HealerJean.github.io/master/assets/img/tctip/weixin.jpg)|![微信公众号](https://raw.githubusercontent.com/HealerJean/HealerJean.github.io/master/assets/img/my/qrcode_for_gh_a23c07a2da9e_258.jpg)|![支付宝](https://raw.githubusercontent.com/HealerJean/HealerJean.github.io/master/assets/img/tctip/alpay.jpg) |



<!-- Gitalk 评论 start  -->

<link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk@latest/dist/gitalk.min.js"></script> 
<div id="gitalk-container"></div>    
 <script type="text/javascript">
    var gitalk = new Gitalk({
		clientID: `1d164cd85549874d0e3a`,
		clientSecret: `527c3d223d1e6608953e835b547061037d140355`,
		repo: `HealerJean.github.io`,
		owner: 'HealerJean',
		admin: ['HealerJean'],
		id: 'AAAAAAAAAAAAAAA',
    });
    gitalk.render('gitalk-container');
</script> 

<!-- Gitalk end -->

