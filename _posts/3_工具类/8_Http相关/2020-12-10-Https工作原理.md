---
title: Https工作原理
date: 2020-02-20 03:33:00
tags: 
- Utils
category: 
- Utils
description: Https工作原理
---

**前言**     

 Github：[https://github.com/HealerJean](https://github.com/HealerJean)         

 博客：[http://blog.healerjean.com](http://HealerJean.github.io)          



近几年，互联网发生着翻天覆地的变化，尤其是我们一直习以为常的HTTP协议，在逐渐的被HTTPS协议所取代，在浏览器、搜索引擎、CA机构、大型互联网企业的共同促进下，互联网迎来了“HTTPS加密时代”，HTTPS将在未来的几年内全面取代HTTP成为传输协议的主流。





# 1、什么是HTTPS

> HTTPS是在HTTP上建立SSL加密层，并对传输数据进行加密，是HTTP协议的安全版。现在它被广泛用于万维网上安全敏感的通讯，例如交易支付方面。

HTTPS主要作用是：    

（1）对数据进行加密，并建立一个信息安全通道，来保证传输过程中的数据安全;    

（2）对网站服务器进行真实身份认证。



我们经常会在Web的登录页面和购物结算界面等使用HTTPS通信。使用HTTPS通信时，不再用`http://`，而是改用`https://`。另外，当浏览器访问HTTPS通信有效的Web网站时，浏览器的地址栏内会出现一个带锁的标记。



![image-20201216101029061](https://raw.githubusercontent.com/HealerJean/HealerJean.github.io/master/blogImages/image-20201216101029061.png)





# 2、为什么需要HTTPS

> 在HTTP协议中有可能存在信息窃取或身份伪装等安全问题。使用HTTPS通信机制可以有效地防止这些问题，    接下来，我们先来了解下HTTP协议存在的哪些问题： 



## 2.1、HTTP协议有哪些问题

### 2.1.1、通信使用明文（不加密），内容可能被窃听

> 由于HTTP本身不具备加密的功能，即，**HTTP报文使用明文（指未经过加密的报文）方式发送**。    



HTTP明文协议的缺陷是导致数据泄露、数据篡改、流量劫持、钓鱼攻击等安全问题的重要原因。HTTP协议无法加密数据，所有通信数据都在网络中明文“裸奔”。通过网络的嗅探设备及一些技术手段，就可还原HTTP报文内容。    



**HTTP网络劫持的原理**    

答：在上网的过程中，我们经常会遇到DNS或者http被劫持的情况。HTTP劫持对于运营商来说，再简单不过了，当然，HTTP劫持并不是运营商才能做的事，一些黑客、浏览器厂商、手机厂商都可以做到       

在用户的浏览器连上被访问的网站服务器，发送了HTTP请求后，运营商的路由器会首先收到此次HTTP请求，之后运营商路由器的旁路设备标记此TCP连接为HTTP协议，之后可以抢在网站服务器返回数据之前发送HTTP协议的302代码（重定向）进行下载软件的劫持，浏览器收到302代码后就会跳转到错误的软件下载地址下载软件了，随后网站服务器的真正数据到达后反而会被丢弃。或者，旁路设备在标记此TCP连接为HTTP协议后，直接返回修改后的HTML代码，导致浏览器中被插入了运营商的广告，随后网站服务器的真正数据到达后最终也是被丢弃。      



### 2.2.2、无法证明报文的完整性，所以可能遭篡改

> **没有任何办法确认，发出的请求/响应和接收到的请求/响应是前后相同的**。

所谓完整性是指信息的准确度。若无法证明其完整性，通常也就意味着无法判断信息是否准确。由于HTTP协议无法证明通信的报文完整性，因此，在请求或响应送出之后直到对方接收之前的这段时间内，即使请求或响应的内容遭到篡改，也没有办法获悉。    



### 2.2.3、验证通信方的身份，因此有可能遭遇伪装

> **HTTP协议中的请求和响应不会对通信方进行确认**。 HTTP协议无法验证通信方身份，任何人都可以伪造虚假服务器欺骗用户，实现“钓鱼欺诈”，用户无法察觉。

   

任何客户端、任何人都可以发起请求：在HTTP协议通信时，不存在确认通信方的处理步骤     

服务器不判断请求请求方：服务器只要接收到请求，不管对方是谁都会返回一个响应    



# 3、HTTPS如何解决HTTP上述问题

> HTTPS并非是应用层的一种新协议。只是HTTP通信接口部分用SS和TLS代替而已。
>
> **SSL(Secure Socket Layer 安全套接层)：**是基于HTTPS下的一个协议加密层，SSL是基于HTTP之下TCP之上的一个协议层，是基于HTTP标准并对TCP传输数据时进行加密，   
>
> **TLS（Transport Layer Security 传输层安全协议）是指安全套接字层**，简而言之，它是一项标准技术，可确保互联网连接安全，保护两个系统之间发送的任何敏感数据，防止网络犯罪分子读取和修改任何传输信息，包括个人资料。两个系统可能是指服务器和客户端（例如，浏览器和购物网站），或两个服务器之间（例如，含个人身份信息或工资单信息的应用程序）。



通常，HTTP直接和TCP通信。当使用SSL时，则演变成先和SSL通信，再由SSL和TCP通信了。简言之，**所谓HTTPS，其实就是身披SSL协议这层外壳的HTTP**。   

![image-20201216103420200](https://raw.githubusercontent.com/HealerJean/HealerJean.github.io/master/blogImages/image-20201216103420200.png)



在采用SSL后，HTTP就拥有了HTTPS的加密、证书和完整性保护这些功能。也就是说**HTTP加上加密处理和认证以及完整性保护后即是HTTPS**。

![image-20201216103747108](https://raw.githubusercontent.com/HealerJean/HealerJean.github.io/master/blogImages/image-20201216103747108.png)





HTTPS 协议的主要功能基本都依赖于 TLS/SSL 协议，TLS/SSL 的功能实现主要依赖于三类基本算法：散列函数 、对称加密和非对称加密，   

**1、利用非对称加密实现身份认证和密钥协商**      

**2、对称加密算法采用协商的密钥对数据加密**     

**3、基于散列函数验证信息的完整性**。



![image-20201216104012304](https://raw.githubusercontent.com/HealerJean/HealerJean.github.io/master/blogImages/image-20201216104012304.png)





## 3.1、Https解决了什么

### 3.1.1、解决内容可能被窃听的问题——加密

#### 3.1.1.1、对称加密

这种方式加密和解密同用一个密钥。加密和解密都会用到密钥。**没有密钥就无法对密码解密，反过来说，任何人只要持有密钥就能解密了**。   

以对称加密方式加密时必须将密钥也发给对方。可究竟怎样才能安全地转交？在互联网上转发密钥时，如果通信被监听那么密钥就可会落人攻击者之手，同时也就失去了加密的意义。另外还得设法安全地保管接收到的密钥。

#### 3.1.1..2、非对称加密

公开密钥加密使用一对非对称的密钥。一把叫做私有密钥，另一把叫做公开密钥。顾名思义，**私有密钥不能让其他任何人知道，而公开密钥则可以随意发布，任何人都可以获得**。    

使用公开密钥加密方式，发送密文的一方使用**对方的公开密钥**进行加密处理，对方收到被加密的信息后，再使用自己的私有密钥进行解密。利用这种方式，不需要发送用来解密的私有密钥，也不必担心密钥被攻击者窃听而盗走。



#### 3.1.1..3、对称加密+非对称加密(HTTPS采用这种方式)

> **在交换密钥环节使用非对称加密方式，之后的建立通信交换报文阶段则使用对称加密方式**。

**使用对称密钥的好处是解密的效率比较快**，**使用非对称密钥的好处是可以使得传输的内容不能被破解**，    

因为就算你拦截到了数据，但是没有对应的私钥，也是不能破解内容的。就比如说你抢到了一个保险柜，但是没有保险柜的钥匙也不能打开保险柜。那我们就将对称加密与非对称加密结合起来,充分利用两者各自的优势，   



具体做法是：**发送密文的一方（客户端）使用对方的公钥进行加密处理“对称的密钥（随机生成的）”，然后对方用自己的私钥解密拿到“对称的密钥”，这样双方就都拥有密钥 X了，且别人无法知道它。之后双方所有数据都用密钥 加密解密即可。这样可以确保交换的密钥是安全的前提下，使用对称加密方式进行通信**。所以，HTTPS采用对称加密和非对称加密两者并用的混合加密机制。





### 2.1.2、解决报文可能遭篡改问题——数字签名

> 网络传输过程中需要经过很多中间节点，虽然数据无法被解密，但可能被篡改，那如何校验数据的完整性呢？----校验数字签名。



**数字签名有两种功效**：   

1、能确定消息确实是由发送方签名并发出来的，因为别人假冒不了发送方的签名。   

2、数字签名能确定消息的完整性,证明数据是否未被篡改过。



**数字签名如何生成和验证:**

发送者用HASH函数对收到的原文产生一个摘要信息，然后用公钥进行加密    

接受者用私钥进行解密，然后用HASH函数对收到的原文产生一个摘要信息，与上一步得到的摘要信息对比。如果相同，则说明收到的信息是完整的，在传输过程中没有被修改，否则说明信息被修改过，因此数字签名能够验证信息的完整性。



**举例：**    

假设消息传递在Kobe，James两人之间发生。      

James将消息连同数字签名一起发送给Kobe，Kobe接收到消息后，通过校验数字签名，就可以验证接收到的消息就是James发送的。当然，这个过程的前提是Kobe知道James的公钥。问题的关键的是，和消息本身一样，公钥不能在不安全的网络中直接发送给Kobe,或者说拿到的公钥如何证明是James的。    

此时就需要引入了**证书颁发机构**（Certificate Authority，简称CA），CA数量并不多，Kobe客户端内置了所有受信任CA的证书。CA对James的公钥（和其他信息）数字签名后生成证书。





### 2.1.3、解决通信方身份可能被伪装的问题——数字证书

> 非对称加密方式还是存在一些问题的。那就是无法证明公开密钥本身就是货真价实的公开密钥。比如，正准备和某台服务器建立公开密钥加密方式下的通信时，如何证明收到的公开密钥就是原本预想的那台服务器发行的公开密钥。       
>
> 
>
> **为了解决上述问题，可以使用由数字证书认证机构(CA，Certificate Authority)和其相关机关颁发的公开密钥证书。数字证书认证机构处于客户端与服务器双方都可信赖的第三方机构的立场上。**



数字证书认证机构处于客户端与服务器双方都可信赖的第三方机构的立场上。我们来介绍一下数字证书认证机构的业务流程。    

1、首先，服务器的运营人员向数字证书认证机构提出公开密钥的申请（向数字证书认证机构提交公钥、组织信息、个人信息(域名)等信息并申请认证;）。

2、数字证书认证机构通过线上、线下等多种手段验证申请者提供信息的真实性，如组织是否存在、企业是否合法，是否拥有域名的所有权等;     

3、如信息审核通过，数字证书认证机构在判明提出申请者的身份之后，会对已申请的公开密钥做数字签名，然后分配这个已签名的公开密钥，并将该公开密钥放入公钥证书后绑定在一起。   申请者签发认证文件-证书。证书包含以下信息：申请者公钥、申请者的组织信息和个人信息、签发机构 CA的信息、有效时间、证书序列号等信息的明文，同时包含一个签名。       

4、客户端 Client 向服务器 Server 发出请求时，Server 返回证书文件;        

5、服务器会将这份由数字证书认证机构颁发的公钥证书发送给客户端，以进行非对称加密方式通信。公钥证书也可叫做数字证书或直接称为证书。   

**6、客户端 Client 读取证书中的相关的明文信息，采用相同的散列函数计算得到信息摘要**，对那张证书上的数字签名进行验证，一旦验证通过，客户端便可明确两件事：一，认证服务器的公开密钥的是真实有效的数字证书认证机构。二，服务器的公开密钥是值得信赖的。     

7、客户端还会验证证书相关的域名信息、有效时间等信息; 客户端会内置信任CA的证书信息(包含公钥)，如果CA不被信任，则找不到对应 CA的证书，证书也会被  判定非法。   





# 4、为何不所有的网站都使用HTTPS



 既然HTTPS那么安全可靠，那为何不所有的Web网站都使用HTTPS？   

其中一个原因是，因为与纯文本通信相比，加密通信会消耗更多的 CPU 及内存资源。如果每次通信都加密，会消耗相当多的资源，平摊到一台计算机上时，能够处理的请求数量必定也会随之减少。

因此，如果是非敏感信息则使用 HTTP 通信，只有在包含个人信息等敏感数据时，才利用 HTTPS 加密通信。 特别是每当那些访问量较多的 Web 网站在进行加密处理时，它们所承担着的负载不容小觑。     

除此之外，想要节约购买证书的开销也是原因之一。要进行 HTTPS 通信，证书是必不可少的。而使用的证书必须向认证机构(CA)购买























![ContactAuthor](https://raw.githubusercontent.com/HealerJean/HealerJean.github.io/master/assets/img/artical_bottom.jpg)





<link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">

<script src="https://unpkg.com/gitalk@latest/dist/gitalk.min.js"></script> 
<div id="gitalk-container"></div>    
 <script type="text/javascript">
    var gitalk = new Gitalk({
		clientID: `1d164cd85549874d0e3a`,
		clientSecret: `527c3d223d1e6608953e835b547061037d140355`,
		repo: `HealerJean.github.io`,
		owner: 'HealerJean',
		admin: ['HealerJean'],
		id: 'AAAAAAAAAAAAAAA',
    });
    gitalk.render('gitalk-container');
</script> 
