---
title: Http状态码
date: 2023-12-12 00:00:00
tags: 
- Utils
category: 
- Utils
description: Http状态码
---

**前言**     

 Github：[https://github.com/HealerJean](https://github.com/HealerJean)         

 博客：[http://blog.healerjean.com](http://HealerJean.github.io)          



# 一、解释

> `HTTP` 状态码（英语：`HTTP` `Status` `Code`）是用以表示网页服务器超文本传输协议响应状态的 `3` 位数字代码。    
>
> 这里所说的超文本传输协议自然就是位于计算机网络应用层的 `http` 协议（广义上也包括 `https` ）。而响应状态则是指，当客户端向服务端发送请求时，服务端给出了何种类型的响应。按照 `RFC` `2616` 的定义，`http` 协议对每一种响应类型都给出了唯一对应的三位数字，每个数字称为一个状态码。目前总共有五大类状态码，分别对应五大类状态，各以1-5开头，它们的大致分类如下：



# 二、5大类

## 1、1 开头的状态码（服务器已收到请求，但是需要请求者继续操作）

> 信息响应，表示服务器已收到请求，但是需要请求者继续操作。

| **状态码** | **作用**                                                     |
| ---------- | ------------------------------------------------------------ |
| 101        | 这只是个临时的响应状态，它表示到目前为止，客户端请求的内容都没有问题。但是客户端需要继续发送请求，才能完成本次请求过程。 |
| 102        | 该代码是响应客户端的 Upgrade 标头发送的，并且指示服务器也正在切换的协议。比如，我们在使用ws协议时常会见到这个状态码 |
| 103        | 预加载提示。此状态代码主要用于与Link 链接头一起使用，以允许用户代理在服务器仍在准备响应时开始预加载资源。 |

> **协议切换说明：**从协议本身来说，http协议和ws协议并没有什么联系。前者是一个无状态、短连接的协议，后者是一个有状态、长连接的协议。但是为了降低协议设计的复杂度，ws协议并没有定义如何直接在客户端和服务端建立一个ws连接，而是约定客户端和服务端应该先建立一个http连接，然后由客户端发送一个切换协议的请求，两者再从http协议切换到ws协议。

## 2、2 开头的状态码（响应成功，表示服务器已接收到请求并正确处理）

> 响应成功，表示服务器已接收到请求并正确处理

| **状态码** | **作用**                                                     |
| ---------- | ------------------------------------------------------------ |
| 200        | 服务器已成功处理了请求。通常，这表示服务器供了请求的网页。   |
| 201        | 请求成功并且服务器创建了新的资源。                           |
| 202        | 服务器已接受请求，但尚未处理。                               |
| 203        | 服务器已成功处理了请求，但返回的信息可能来自另一来源         |
| 204        | 服务器已成功处理了请求，但没有返回任何实体内容，并且浏览器不需要刷新或者重定向 |
| 205        | 服务器已成功处理了请求，但没有返回任何实体内容，不过浏览器应该立即刷新当前页面 |
| 206        | 服务器成功处理了部分 `GET`请求                               |

## 3、3 开头的状态码（服务器已接收到请求，但没有直接处理，而是重定向）

> 重定向，表示服务器已接收到请求，但是没有直接处理，而是进行了重定向

| **状态码** | **作用**                                                     |
| ---------- | ------------------------------------------------------------ |
| 300        | 针对请求，服务器可执行多种操作。服务器可根据请求者(user_agent)选择一项操作，或提供操作列表供请求者选择。 |
| 301        | 请求的网页已永久移动到新位置。服务器返回此响应对GET或HEAD请求的响应时，会自动将请求者转到新位置 |
| 302        | 请求的资源被临时重定向到了别的URI。但这个重定向只是临时的，下次请求当前资源时仍然应该使用当前的地址 |
| 303        | 服务端已经收到请求，但是不会进行处理。客户端需要向响应中携带的新的URI发送GET请求，服务端才会进行处理 |
| 304        | 表示当前资源已被下载过，并且没有改变，因此客户端应该从缓存中获取该资源 |
| 305        | 当前资源需要使用指定的代理才能访问                           |
| 306        | 最新的规范中，306不再被使用                                  |
| 307        | 请求的资源现在临时从不同的 URI 响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在Cache-Control或Expires中进行了指定的情况下，这个响应才是可缓存的 |

## 4、4 开头的状态码（客户端错误，客户端的请求存在错误，无法完成请求）

> 客户端错误，表示客户端发出的请求中存在错误，无法完成请求

| **状态码** | **作用**                                                     |
| ---------- | ------------------------------------------------------------ |
| 400        | 请求有误。它包含两种情况：1.语义有误。服务端无法理解当前请求的含义，因此客户端必须对请求进行修改才可以重新发送。2.参数有误。客户端请求中携带的参数不符合服务端的要求，如数量不一致，类型错误，体积过大（如上传文件时，文件大小超出了服务端配置）等。 |
| 401        | 未授权。即当前请求需要进行用户验证                           |
| 402        | 该状态码暂未使用，将来可能用于数字支付系统                   |
| 403        | 服务器已经接受并理解了请求，但是拒绝执行                     |
| 404        | 请求的资源不存在                                             |
| 405        | 请求方法不允许。比如服务端设置某个资源只能用POST方法进行访问，而客户端发送的是一个GET请求，服务端就会返回状态码405 |
| 406        | 请求的资源的内容特性无法满足请求头中的条件，因此无法生成响应实体。比如客户端设置返回的数据类型必须是JSON，而服务端没有配置转换JSON所依赖的包，或者所请求的资源本身就无法转化为JSON，这时服务端就无法生成符合客户端要求的响应实体，因此就会返回状态码406。 |
| 407        | 需要在代理服务器上进行身份验证。该状态码与401类似，但是它要求客户端必须在代理服务器上进行身份验证 |
| 408        | 请求超时。                                                   |
| 409        | 服务器在完成请求时发生冲突。服务器必须在响应中包含有关冲突的信息 |
| 410        | 如果请求的资源已永久删除，服务器就会返回此响应。             |
| 411        | 服务器不接受不含有效内容长度标头字段的请求。                 |
| 412        | 服务器未满足请求者在请求中设置的其中一个前提条件。           |
| 413        | 服务器无法处理请求，因为请求实体过大，超出服务器的处理能力   |
| 414        | 请求的URI通常为网址过长，服务器无法处理                      |
| 415        | 请求的格式不受请求页面的支持                                 |
| 416        | 如果页面无法提供请求的范围，则服务器会返回此状态代码         |
| 417        | 服务器未满足"期望"请求标头字段的要求                         |

## 5、5开头的状态码（服务端错误，服务器在处理请求的过程中出现错误）

> 服务端错误，表示服务器在处理请求的过程中出现错误

| **状态码** | **作用**                                                     |
| ---------- | ------------------------------------------------------------ |
| 500        | 服务器遇到错误，无法完成请求                                 |
| 501        | 服务器不具备完成请求的功能。例如，服务器无法识别请求方法时可能会返回此代码 |
| 502        | 服务器作为网关或代理，从上游服务器收到无效响应               |
| 503        | 服务器目前无法使用，由于超载或停机维护。通常，这只是暂时状态 |
| 504        | 服务器作为网关或代理，但是没有及时从上游服务器收到请求       |
| 505        | 服务器不支持请求中所用的HTTP协议版本                         |









![ContactAuthor](https://raw.githubusercontent.com/HealerJean/HealerJean.github.io/master/assets/img/artical_bottom.jpg)



<!-- Gitalk 评论 start  -->

<link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">

<script src="https://unpkg.com/gitalk@latest/dist/gitalk.min.js"></script> 
<div id="gitalk-container"></div>    
 <script type="text/javascript">
    var gitalk = new Gitalk({
		clientID: `1d164cd85549874d0e3a`,
		clientSecret: `527c3d223d1e6608953e835b547061037d140355`,
		repo: `HealerJean.github.io`,
		owner: 'HealerJean',
		admin: ['HealerJean'],
		id: 'y6XPxrQKmqAH5ZMv',
    });
    gitalk.render('gitalk-container');
</script> 




<!-- Gitalk end -->



