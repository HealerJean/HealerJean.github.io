---
title: 单元测试之_Mockio
date: 2023-12-12 00:00:00
tags: 
- Java
category: 
- Java
description: 单元测试之_Mockio
---

**前言**     

 Github：[https://github.com/HealerJean](https://github.com/HealerJean)         

 博客：[http://blog.healerjean.com](http://HealerJean.github.io)          





# 1、`MOCK`编程

> 单元测试中，一个重要原则就是不扩大测试范围，尽可能将 `mock` 外部依赖，例如外部的 `RPC` 服务、数据库等中间件。被 `mock` 的对象可以称作。       
>
> **两大目的**
>
> > **1.验证这个对象的某些方法的调用情况，调用了多少次，参数是什么等等**      
> >
> > **2.指定这个对象的某些方法的行为，返回特定的值，或者是执行特定的动作**



## 1.1、测试替身分类

> 「测试替身」，它来源于电影中的特技替身的概念。Meszaros 在他的文中[2]定义了五类替身。

![image-20220329212107753](https://raw.githubusercontent.com/HealerJean/HealerJean.github.io/master/blogImages/image-20220329212107753.png)



# 2、`Mockito`

## 2.1、`Mockito.mock` ：`mock`出一个虚假的对象

```java
@Test
public void test_1() {
  PersonDTO person = Mockito.mock(PersonDTO.class);

}
```



## 2.2、`Mockito.verify` ：

### 2.2.1、验证方法调用没(关心参数)&次数

```java
@Test
public void test2_1() {
  PersonDTO person = Mockito.mock(PersonDTO.class);

  // 1、验证person的getSex得到了调用
  person.getSex(1);
  Mockito.verify(person).getSex(1);
  Mockito.verify(person, Mockito.times(1)).getSex(1);

}

```

| 方法            | 说明                            |
| --------------- | ------------------------------- |
| `times(n)`      | 方法被调用n次                   |
| `never()`       | 没有被调用                      |
| `atLeast(n)`    | 至少被调用n次                   |
| `atLeastOnce()` | 至少被调用1次，相当于atLeast(1) |
| `atMost()`      | 最多被调用n次                   |

### 2.2.2、验证方法调用没(不关系参数)

```java
@Test
public void test_3() {
  PersonDTO person = Mockito.mock(PersonDTO.class);
  person.printing("healerjean");
  // 1、只关心打印方法走没走，而不关心他的参数是什么的时候，我们就要用到Mock的any方法
  Mockito.verify(person).printing(Mockito.anyString());
}

```

| 方法                     | 说明                     |
| ------------------------ | ------------------------ |
| `anyString()`            | 表示任何一个字符串都可以 |
| `anyInt`                 |                          |
| `anyLong`                |                          |
| `anyDouble`              |                          |
| `anyObject`              | 表示任何对象             |
| `any(clazz)`             | 表示任何属于clazz的对象  |
| `anyCollection`          |                          |
| `anyCollectionOf(clazz)` |                          |
| `anyList(Map, set)`      |                          |
| `anyListOf(clazz)`       |                          |

### 2.2.3、`Mockito.inOrder`：验证调用顺序

```java
@Test
public void test2_2(){
  PersonDTO person = Mockito.mock(PersonDTO.class);
  person.getSex(1);
  person.isMan(1);
  
  InOrder inOrder = Mockito.inOrder(person);
  inOrder.verify(person).getSex(1);
  inOrder.verify(person).isMan(1);
}
```



## 2.3、`Mockito.when(xx).thenReturn(xx)`

> 指定某个方法的返回值，或者是执行特定的动作

```java
@Test
public void test_4_1() {
  PersonDTO person = Mockito.mock(PersonDTO.class);

  // 4.1、当调用person的isMan方法，同时传入"0"时，返回true
  // （注意这个时候我们调用person.isMan(0);的时候值为true而调用其他数字则为false，
  //   如果我们忽略数字，传任何值都返回true时，就可以用到我们上面讲的any()参数适配方法）
  Mockito.when(person.isMan(0)).thenReturn(true);
  // true
  System.out.println(person.isMan(0));
  // false
  System.out.println(person.isMan(1));

  //当调用person的isMan方法，同时传入"0"时，返回false，其他默认也都是 false
  Mockito.when(person.isMan(0)).thenReturn(false);
  // false
  System.out.println(person.isMan(0));
  // false
  System.out.println(person.isMan(1));


  Mockito.when(person.isMan(Mockito.anyInt())).thenReturn(true);
  // true
  System.out.println(person.isMan(0));
  // true
  System.out.println(person.isMan(1));
}
```



## 2.4、`Mockito.doThrow`：

> 指定某法方法抛出异常

```java
@Test
public void test_4_2() {
  List list = Mockito.mock(List.class);
  list.add("123");
  //1、当list调用clear()方法时会抛出异常
  Mockito.doThrow(new RuntimeException()).when(list).clear();
  list.clear();
}

```



## 2.5、`Mockito.doReturn` 

> 指定返回特定值

```java
public void test_4_3() {
  List list = Mockito.mock(List.class);
  Mockito.doReturn("123").when(list).get(Mockito.anyInt());
  System.out.println(list.get(0));
}

```

## 2.6、`mock` 对象默认不调用&真实调用

### 2.6.1、`Mockito.doNothing()`：默认不调用

```java
@Test
public void test_4_4(){
  Foo foo = Mockito.mock(Foo.class);

  //1、什么信息也不会打印, mock对象并不会调用真实逻辑
  foo.doFoo();

  //2、啥也不会打印出来
  Mockito.doNothing().when(foo).doFoo();
  foo.doFoo();
  //不会调用真实逻辑，但是int默认值就是0，所以打印0
  // 打印0
  System.out.println(foo.getCount());
}

class Foo {
  public void doFoo() {
    System.out.println("method doFoo called.");
  }
  public int getCount() {
    return 1;
  }
}
```



### 2.6.2、`Mockito.doCallRealMethod`：真实调用

```java
@Test
public void test_4_4(){
  Foo foo = Mockito.mock(Foo.class);

  //3、这里会调用真实逻辑, 打印出信息
  Mockito.doCallRealMethod().when(foo).doFoo();
  // 打印："method doFoo called."
  foo.doFoo();

  Mockito.doCallRealMethod().when(foo).getCount();
  // 打印 0
  System.out.println(foo.getCount());

}

class Foo {
  public void doFoo() {
    System.out.println("method doFoo called.");
  }
  public int getCount() {
    return 1;
  }
}
```

# 3、`@Mock`注解

> 需要配合 `@RunWith(MockitoJUnitRunner.class)` 注解使用。
>
> 1、对该对象所有非私有方法的调用都没有调用 `真实方法`          
>
> 2、对该对象私有方法的调用无法进行模拟，会调用 `真实方法`



## 3.1、非 `Spring`

> `Spring`：`A`  -> `B` ->`C`，这是一个`Spring` 链路，只单侧1层 A -> B 可以用

### 3.1.1、























![ContactAuthor](https://raw.githubusercontent.com/HealerJean/HealerJean.github.io/master/assets/img/artical_bottom.jpg)



<!-- Gitalk 评论 start  -->

<link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">

<script src="https://unpkg.com/gitalk@latest/dist/gitalk.min.js"></script> 
<div id="gitalk-container"></div>    
 <script type="text/javascript">
    var gitalk = new Gitalk({
		clientID: `1d164cd85549874d0e3a`,
		clientSecret: `527c3d223d1e6608953e835b547061037d140355`,
		repo: `HealerJean.github.io`,
		owner: 'HealerJean',
		admin: ['HealerJean'],
		id: 'cRPB4UX8lFdfvOEy',
    });
    gitalk.render('gitalk-container');
</script> 




<!-- Gitalk end -->



