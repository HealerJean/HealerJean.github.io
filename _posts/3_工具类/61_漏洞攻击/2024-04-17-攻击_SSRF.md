---
title: 攻击_SSRF
date: 2024-04-17 00:00:00
tags: 
- SpringBoot
category: 
- SpringBoot
description: 攻击_SSRF
---

**前言**     

 Github：[https://github.com/HealerJean](https://github.com/HealerJean)         

 博客：[http://blog.healerjean.com](http://HealerJean.github.io)          



# 一、`SSRF` 是什么

> **`SSRF`（`Server-Side Request Forgery`）是一种服务器端请求伪造的攻击方式**。攻击者通过诱导服务器发起对外部或内部目标的请求，从而绕过网络隔离机制，访问原本无法从外部访问的资源或服务。

## 1、核心原理：

- 当 `Web` 应用程序提供从指定 URL 获取资源的功能（如图片加载、文件下载、API 调用等）时，若未对用户提供的 `URL` 做严格的校验与限制，攻击者可以构造恶意 `URL`，使服务器向任意地址发起请求。
- `SSRF` 通常被用于：
  - 访问内网资源（如 `127.0.0.1`、`192.168.x.x`）
  - 探测或攻击内部服务（如 `Redis`、`MySQL`、`SSRF` 反弹 Shell）
  - 利用伪协议（如 `file://`、`dict://`、`gopher://`）读取本地文件或执行命令
  - 绕过防火墙访问外网限制服务



# 二、`SSRF` 的危害

| 攻击目标 | 潜在风险                                |
| -------- | --------------------------------------- |
| 内网服务 | Redis 未授权访问、SSRF 反弹 Shell       |
| 本地文件 | 利用 `file://` 读取敏感文件             |
| 外部服务 | 利用服务器身份发起攻击                  |
| 云环境   | 获取云平台元数据（如 AWS Metadata API） |



# 三、`SSRF` 的防御措施

## 1、输入验证和过滤

- **白名单机制**：只允许访问特定域名或 IP 地址。
- **协议限制**：仅允许 `http`、`https` 等安全协议。
- **禁止伪协议**：如 `file://`、`dict://`、`gopher://` 等。



## 2、禁止访问内网地址

- **IP 地址黑名单**：拒绝 `127.0.0.1`、`192.168.0.0/16`、`10.0.0.0/8`、`172.16.0.0/12` 等私有 IP。
- **`DNS` 解析控制**：防止 `localhost`、`metadata.google.internal` 等解析为内网地址。



## 3、端口限制

- 限制访问端口为常见的 Web 端口，如 `80`、`443`。
- 防止访问 `22`、`23`、`25`、`53`、`8080` 等非 Web 端口。



## 4、使用安全组件

- 使用安全的 HTTP 客户端库，如 Apache HttpClient、OkHttp。
- 使用 DNS 解析时，避免使用系统默认解析器，防止 DNS Rebinding 攻击。



## 5、强制访问控制

- 对请求目标进行身份认证和权限控制。
- 使用代理服务器或中间服务来隔离请求。



## 6、日志和监控

- 记录所有 `SSRF` 请求行为，便于审计和追踪。
- 设置异常请求的告警机制。



# 四、优化建议

**输入验证和过滤**：对从用户输入中获取的URL进行严格的验证和过滤，确保只接受合法的URL。使用白名单过滤机制，限制URL只能访问特定的域名或IP地址，从而防止攻击者构造恶意请求。     

**限制协议和端口**：限制服务器端应用程序只能发起特定协议（如HTTP和HTTPS）和特定端口范围内的请求。同样，使用白名单机制，只允许特定的协议和端口，以减少潜在的攻击面。     

**内网访问限制**：确保服务器端应用程序只能发起外部网络的请求，禁止访问内部网络。利用网络隔离技术，将服务器部署在DMZ（Demilitarized Zone）区域，只允许与外部网络通信，以防止SSRF攻击利用内部网络资源。     

**更新相关组件和框架**：及时更新服务器端应用程序使用的相关组件和框架，以修复已知的SSRF漏洞。保持系统和应用程序的最新版本，可以减少被利用的风险。    

**强制访问控制**：使用身份验证和授权机制，限制用户访问特定的功能和资源。这有助于防止未经授权的请求被发送，从而减少SSRF攻击的可能性。

```java
import java.net.*;
import java.util.*;

public class SslfUtils {

    private static final Set<String> ALLOWED_PROTOCOLS = Set.of("http", "https");
    private static final Set<String> ALLOWED_DOMAINS = Set.of("blog.healerjean.com");
    private static final Set<Integer> ALLOWED_PORTS = Set.of(80, 443);

    public static boolean sslfUrl(String url) {
        URL urlObj;
        try {
            urlObj = new URL(url);
        } catch (Exception e) {
            System.out.println("URL 不合法: " + url);
            return false;
        }

        // 协议检查
        if (!ALLOWED_PROTOCOLS.contains(urlObj.getProtocol())) {
            System.out.println("协议不合法: " + url);
            return false;
        }

        // 域名检查
        String host = urlObj.getHost();
        if (!isAllowedDomain(host)) {
            System.out.println("域名不合法: " + url);
            return false;
        }

        // IP 地址检查
        try {
            InetAddress address = InetAddress.getByName(host);
            if (address.isSiteLocalAddress() || address.isLoopbackAddress()) {
                System.out.println("禁止访问私有地址: " + url);
                return false;
            }
        } catch (UnknownHostException e) {
            System.out.println("DNS 解析失败: " + url);
            return false;
        }

        // 端口检查
        int port = urlObj.getPort();
        if (port == -1) {
            port = "https".equals(urlObj.getProtocol()) ? 443 : 80;
        }
        if (!ALLOWED_PORTS.contains(port)) {
            System.out.println("端口不合法: " + url);
            return false;
        }

        return true;
    }

    private static boolean isAllowedDomain(String host) {
        for (String allowedDomain : ALLOWED_DOMAINS) {
            if (allowedDomain.startsWith("*.")) {
                String suffix = allowedDomain.substring(2);
                if (host.endsWith(suffix)) {
                    return true;
                }
            } else if (host.equals(allowedDomain)) {
                return true;
            }
        }
        return false;
    }
}
```





![ContactAuthor](https://raw.githubusercontent.com/HealerJean/HealerJean.github.io/master/assets/img/artical_bottom.jpg)



<!-- Gitalk 评论 start  -->

<link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">

<script src="https://unpkg.com/gitalk@latest/dist/gitalk.min.js"></script> 
<div id="gitalk-container"></div>    
 <script type="text/javascript">
    var gitalk = new Gitalk({
		clientID: `1d164cd85549874d0e3a`,
		clientSecret: `527c3d223d1e6608953e835b547061037d140355`,
		repo: `HealerJean.github.io`,
		owner: 'HealerJean',
		admin: ['HealerJean'],
		id: 'oi0WqSbHQw8FnEIX',
    });
    gitalk.render('gitalk-container');
</script> 




<!-- Gitalk end -->



