---
title: 正则表达式
date: 2022-01-21 00:00:00
tags: 
- Java
category: 
- Java
description: 正则表达式
---

**前言**     

 Github：[https://github.com/HealerJean](https://github.com/HealerJean)         

 博客：[http://blog.healerjean.com](http://HealerJean.github.io)          

# 一、常用的正则表达式

## 1、身份证号码

```java
package com.hlj.util.Z025_utils;

import org.apache.commons.lang.StringUtils;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.*;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * 身份证号码的格式：610821-20061222-612-X
 * 由18位数字组成：前6位为地址码，第7至14位为出生日期码，第15至17位为顺序码，
 * 第18位为校验码。检验码分别是0-10共11个数字，当检验码为“10”时，为了保证公民身份证号码18位，所以用“X”表示。
 * 虽然校验码为“X”不能更换，但若需全用数字表示，只需将18位公民身份号码转换成15位居民身份证号码，去掉第7至8位和最后1位3个数码。
 * 当今的身份证号码有15位和18位之分。1985年我国实行居民身份证制度，当时签发的身份证号码是15位的，1999年签发的身份证由于年份的扩展（由两位变为四位）和末尾加了效验码，就成了18位。
 * （1）前1、2位数字表示：所在省份的代码；
 * （2）第3、4位数字表示：所在城市的代码；
 * （3）第5、6位数字表示：所在区县的代码；
 * （4）第7~14位数字表示：出生年、月、日；
 * （5）第15、16位数字表示：所在地的派出所的代码；
 * （6）第17位数字表示性别：奇数表示男性，偶数表示女性
 * （7）第18位数字是校检码：根据一定算法生成
 */
public class CheckIdCardUtils {


    public static Map<String, Object> checkIdCard(String IDStr) {
        Map<String, Object> map = new HashMap<>();
        map.put("success", false);
        map.put("msg", "该身份证号无效！");
        String Ai = "";

        if (StringUtils.isBlank(IDStr)) {
            map.put("msg", "空的身份证号！");
            return map;
        } else {
            IDStr = IDStr.toUpperCase(); //将身份证最后一位的x转换为大写，便于统一
        }

        // 判断号码的长度 15位或18位
        if (IDStr.length() != 15 && IDStr.length() != 18) {
            map.put("msg", "身份证号码长度应该为15位或18位！");
            return map;
        }


        // 18位身份证前17位位数字，如果是15位的身份证则所有号码都为数字
        if (IDStr.length() == 18) {
            Ai = IDStr.substring(0, 17);
        } else if (IDStr.length() == 15) {
            Ai = IDStr.substring(0, 6) + "19" + IDStr.substring(6, 15);
        }
        if (!isNumeric(Ai)) {
            map.put("msg", "身份证15位号码都应为数字，18位号码除最后一位外，都应为数字！");
            return map;
        }


        // 判断出生年月是否有效
        String strYear = Ai.substring(6, 10);// 年份
        String strMonth = Ai.substring(10, 12);// 月份
        String strDay = Ai.substring(12, 14);// 日期
        if (!isDate(strYear + "-" + strMonth + "-" + strDay)) {
            map.put("msg", "身份证出生日期无效！");
            return map;
        }
        GregorianCalendar gc = new GregorianCalendar();
        SimpleDateFormat s = new SimpleDateFormat("yyyy-MM-dd");
        try {
            if ((gc.get(Calendar.YEAR) - Integer.parseInt(strYear)) > 150
                    || (gc.getTime().getTime() - s.parse(
                    strYear + "-" + strMonth + "-" + strDay).getTime()) < 0) {
                map.put("msg", "身份证生日不在有效范围！");
                return map;
            }
        } catch (NumberFormatException | ParseException e) {
            e.printStackTrace();
        }
        if (Integer.parseInt(strMonth) > 12 || Integer.parseInt(strMonth) == 0) {
            map.put("msg", "身份证月份无效！");
            return map;
        }
        if (Integer.parseInt(strDay) > 31 || Integer.parseInt(strDay) == 0) {
            map.put("msg", "身份证日期无效！");
            return map;
        }
        // 判断地区码是否有效
        Hashtable areacode = getAreaCode();
        //如果身份证前两位的地区码不在Hashtable，则地区码有误
        if (areacode.get(Ai.substring(0, 2)) == null) {
            map.put("msg", "身份证地区编码错误！");
            return map;
        }

        if (!isVarifyCode(Ai, IDStr)) {
            map.put("msg", "身份证校验码无效，不是合法的身份证号码！");
            return map;
        }

        map.put("success", true);
        map.put("msg", "该身份证号有效！");

        return map;
    }


    /**
     * 判断第18位校验码是否正确
     * 第18位校验码的计算方式：
     * 　　1. 对前17位数字本体码加权求和
     * 　　公式为：S = Sum(Ai * Wi), i = 0, ... , 16
     * 　　其中Ai表示第i个位置上的身份证号码数字值，Wi表示第i位置上的加权因子，其各位对应的值依次为： 7 9 10 5 8 4 2 1 6 3 7 9 10 5 8 4 2
     * 　　2. 用11对计算结果取模
     * 　　Y = mod(S, 11)
     * 　　3. 根据模的值得到对应的校验码
     * 　　对应关系为：
     * 　　 Y值：     0  1  2  3  4  5  6  7  8  9  10
     * 　　校验码： 1  0  X  9  8  7  6  5  4  3   2
     */
    private static boolean isVarifyCode(String Ai, String IDStr) {
        String[] VarifyCode = {"1", "0", "X", "9", "8", "7", "6", "5", "4", "3", "2"};
        String[] Wi = {"7", "9", "10", "5", "8", "4", "2", "1", "6", "3", "7", "9", "10", "5", "8", "4", "2"};
        int sum = 0;
        for (int i = 0; i < 17; i++) {
            sum = sum + Integer.parseInt(String.valueOf(Ai.charAt(i))) * Integer.parseInt(Wi[i]);
        }
        int modValue = sum % 11;
        String strVerifyCode = VarifyCode[modValue];
        Ai = Ai + strVerifyCode;
        if (IDStr.length() == 18) {
            if (!Ai.equals(IDStr)) {
                return false;

            }
        }
        return true;
    }


    /**
     * 将所有地址编码保存在一个Hashtable中
     *
     * @return Hashtable 对象
     */

    private static Hashtable getAreaCode() {
        Hashtable<String, String> hashtable = new Hashtable<>();
        hashtable.put("11", "北京");
        hashtable.put("12", "天津");
        hashtable.put("13", "河北");
        hashtable.put("14", "山西");
        hashtable.put("15", "内蒙古");
        hashtable.put("21", "辽宁");
        hashtable.put("22", "吉林");
        hashtable.put("23", "黑龙江");
        hashtable.put("31", "上海");
        hashtable.put("32", "江苏");
        hashtable.put("33", "浙江");
        hashtable.put("34", "安徽");
        hashtable.put("35", "福建");
        hashtable.put("36", "江西");
        hashtable.put("37", "山东");
        hashtable.put("41", "河南");
        hashtable.put("42", "湖北");
        hashtable.put("43", "湖南");
        hashtable.put("44", "广东");
        hashtable.put("45", "广西");
        hashtable.put("46", "海南");
        hashtable.put("50", "重庆");
        hashtable.put("51", "四川");
        hashtable.put("52", "贵州");
        hashtable.put("53", "云南");
        hashtable.put("54", "西藏");
        hashtable.put("61", "陕西");
        hashtable.put("62", "甘肃");
        hashtable.put("63", "青海");
        hashtable.put("64", "宁夏");
        hashtable.put("65", "新疆");
        hashtable.put("71", "台湾");
        hashtable.put("81", "香港");
        hashtable.put("82", "澳门");
        hashtable.put("91", "国外");

        return hashtable;
    }

    /**
     * 判断字符串是否为数字,0-9重复0次或者多次
     */
    private static boolean isNumeric(String strnum) {
        Pattern pattern = Pattern.compile("[0-9]*");
        Matcher isNum = pattern.matcher(strnum);
        return isNum.matches();
    }

    /**
     * 功能：判断字符串出生日期是否符合正则表达式：包括年月日，闰年、平年和每月31天、30天和闰月的28天或者29天
     */
    private static boolean isDate(String strDate) {
        Pattern pattern = Pattern
                .compile("^((\\d{2}(([02468][048])|([13579][26]))[\\-\\/\\s]?((((0?[13578])|(1[02]))[\\-\\/\\s]?((0?[1-9])|([1-2][0-9])|(3[01])))|(((0?[469])|(11))[\\-\\/\\s]?((0?[1-9])|([1-2][0-9])|(30)))|(0?2[\\-\\/\\s]?((0?[1-9])|([1-2][0-9])))))|(\\d{2}(([02468][1235679])|([13579][01345789]))[\\-\\/\\s]?((((0?[13578])|(1[02]))[\\-\\/\\s]?((0?[1-9])|([1-2][0-9])|(3[01])))|(((0?[469])|(11))[\\-\\/\\s]?((0?[1-9])|([1-2][0-9])|(30)))|(0?2[\\-\\/\\s]?((0?[1-9])|(1[0-9])|(2[0-8]))))))?$");
        Matcher m = pattern.matcher(strDate);
        return m.matches();
    }
}

```



## 2、校验银行卡号

```java
package com.hlj.util.Z025_utils;


import org.apache.commons.lang.StringUtils;


public class CheckBankCardUtils {

    /**
    校验过程：
    1、从卡号最后一位数字开始，逆向将奇数位(1、3、5等等)相加。
    2、从卡号最后一位数字开始，逆向将偶数位数字，先乘以2（如果乘积为两位数，将个位十位数字相加，即将其减去9），再求和。
    3、将奇数位总和加上偶数位总和，结果应该可以被10整除。
    */
    /**
     * 校验银行卡卡号
     */
    public static boolean checkBankCard(String bankCard) {
        bankCard = StringUtils.deleteWhitespace(bankCard);
        if (StringUtils.isBlank(bankCard)){
            return false;
        }
        if(bankCard.length() < 15 || bankCard.length() > 19) {
            return false;
        }
        char bit = getBankCardCheckCode(bankCard.substring(0, bankCard.length() - 1));
        if(bit == 'N'){
            return false;
        }
        return bankCard.charAt(bankCard.length() - 1) == bit;
    }

    /**
     * 从不含校验位的银行卡卡号采用 Luhm 校验算法获得校验位
     */
    private static char getBankCardCheckCode(String nonCheckCodeBankCard){
        if(nonCheckCodeBankCard == null || nonCheckCodeBankCard.trim().length() == 0
                || !nonCheckCodeBankCard.matches("\\d+")) {
            //如果传的不是数据返回N
            return 'N';
        }
        char[] chs = nonCheckCodeBankCard.trim().toCharArray();
        int luhmSum = 0;
        for(int i = chs.length - 1, j = 0; i >= 0; i--, j++) {
            int k = chs[i] - '0';
            if(j % 2 == 0) {
                k *= 2;
                k = k / 10 + k % 10;
            }
            luhmSum += k;
        }
        return (luhmSum % 10 == 0) ? '0' : (char)((10 - luhmSum % 10) + '0');
    }

}


```

## 3、校验密码强度

```java
/**
 * 判断密码强度
 */
public static int checkPasswordStrength(String password) {
    if (password.length() < 6) {
        return 1;
    } else {
        String strongPattern = "^(?![a-zA-z]+$)(?!\\d+$)(?![!@#$%^&*]+$)(?![a-zA-z\\d]+$)(?![a-zA-z!@#$%^&*]+$)(?![\\d!@#$%^&*]+$)[a-zA-Z\\d!@#$%^&*]+$";
        String inPattern = "^(?![a-zA-z]+$)(?!\\d+$)(?![!@#$%^&*]+$)[a-zA-Z\\d!@#$%^&*]+$";
        String weakPattern = "^(?:\\d+|[a-zA-Z]+|[!@#$%^&*]+)$";
        if (Pattern.matches(strongPattern, password)) {
            //强
            return 3;
        } else if (Pattern.matches(inPattern, password)) {
            //中
            return 2;
        } else {
            //弱
            return 1;
        }
    }
}
```



## 4、校验姓名

```java
/**
 * 姓名（包含少数名族）
 */
public static boolean checkChineseName(String name) {
    if(StringUtils.isBlank(name)){
        return false;
    }
    //少数名族 带点时前后汉字是[2，8]个
    if (name.contains(".") && name.matches("^[\\u4e00-\\u9fa5]+[.][\\u4e00-\\u9fa5]+$")) {
        return true;
    } else if (name.matches("^[\\u4e00-\\u9fa5]+$")) {
        return true;
    }
    return false;
}
```

## 5、用户相关

```java
/** 用户名-正则表达式：英文字母开头，包含英文字母或数字或特殊字符(. _ -)，长度4-32位*/
public static final String UserName = "^[a-zA-Z]{1}([a-zA-Z0-9]|[._-]){3,31}$";

/** 邮箱-正则表达式 */
public static final String Email = "^[A-Za-z0-9\\u4e00-\\u9fa5]{1}[A-Za-z0-9\\u4e00-\\u9fa5\\._-]+[A-Za-z0-9\\u4e00-\\u9fa5]{1}@[a-zA-Z0-9_-]+(\\.[a-zA-Z0-9_-]+)+$";

/** 手机-正则表达式 */
public static final String Telephone = "^(\\s?)|([1](([3][0-9])|([4][5-9])|([5][0-3,5-9])|([6][5,6])|([7][0-8])|([8][0-9])|([9][1,8,9]))[0-9]{8})$";

/** 支付密码规则-正则表达式 */
public static final String PayPassWord = "\\d{6}";

/** 密码规则-正则表达式 */
public static final String PassWord = "^.*(?=.{6,})(?=.*\\d)(?=.*[A-Z])(?=.*[a-z]).*$";

/** QQ-正则表达式 */
public static final String QQ = "[1-9][0-9]{4,14}";

/** 统一社会信用代码-正则表达式 */
public static final String SocialCreditCode = "^([159Y]{1})([1239]{1})([0-9ABCDEFGHJKLMNPQRTUWXY]{6})([0-9ABCDEFGHJKLMNPQRTUWXY]{9})([0-90-9ABCDEFGHJKLMNPQRTUWXY])$";

```



## 6、字符相关

```java
/** 全为英文 */
public static final String ENGLISH = "[a-zA-Z]+";

/** 全为英文 大写*/
public static final String ENGLISH_UPPER = "^[A-Z]+$";

/** 全为英文 小写*/
public static final String ENGLISH_lLOW = "^[a-z]+$";

/** 含有英文 */
public static final String CONTAIN_ENGLISH = ".*[a-zA-z].*";

/** 全为数字 */
public static final String NUMBER = "[0-9]+";

/** 含有数字 */
public static final String CONTAIN_NUMBER  = ".*[0-9].*";

/** 英文、数字 */
public static final String ENGLISH_NUMBER = "[a-zA-Z0-9]+";

/** 英文、数字、下划线 */
public static final String ENGLISH_NUMBER_ = "^\\w+$";

/** 全为中文  */
public static final String CHINESE = "[\\u4e00-\\u9fa5]+";

/** 中文、英文、数字 */
public static final String CHINESE_ENGLISH_NUMBER = "^[\\u4E00-\\u9FA5A-Za-z0-9]+$";

/** 中文、英文、数字、下划线*/
public static final String CHINESE_ENGLISH_NUMBER_ = "^[\\u4E00-\\u9FA5A-Za-z0-9_]+$";


```



# 二、正则写法

# 1、常见用法

### 1）匹配特定字符

| 模式                 | 说明                                                         | 样例                                                  |
| -------------------- | ------------------------------------------------------------ | ----------------------------------------------------- |
| **匹配数字**         | `\d` 匹配任何数字（0-9）。例如，`\d\d\d` 匹配三个连续的数字。 | `"123"` 会被 `\d\d\d` 匹配。                          |
| **匹配非数字**：     | `\D` 匹配任何非数字字符。                                    | `"abc"` 会被 `\D+` 匹配（匹配一个或多个非数字字符）。 |
| **匹配空白字符**：   | `\s` 匹配任何空白字符（包括空格、制表符、换行符等）。        | `" a "` 中的空格会被 `\s` 匹配。                      |
| **匹配非空白字符**： | `\S` 匹配任何非空白字符。                                    | `"abc"` 会被 `\S+` 匹配（匹配一个或多个非空白字符）。 |



### 2） 字符类

| 模式                           | 说明                                                         | 样例                                            |
| ------------------------------ | ------------------------------------------------------------ | ----------------------------------------------- |
| **匹配指定范围内的字符**：     | `[a-z]` 匹配任何小写字母，`[A-Z]` 匹配任何大写字母，`[0-9a-fA-F]` 匹配任何十六进制数字。 | `"Hello123"` 中的 `"llo"` 会被 `[a-z]+` 匹配。  |
| **匹配不在指定范围内的字符**： | `[^a-z]` 匹配任何不是小写字母的字符。                        | `"Hello123"` 中的 `"123"` 会被 `[^a-z]+` 匹配。 |

### 3）量词

| 模式                   | 说明                                                         | 样例                                                         |
| ---------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **匹配零次或多次**：   | `*` 例如，`a*` 可以匹配空字符串、一个 "a"、两个 "a"、依此类推。 | `"aaa"` 会被 `a*` 匹配（尽管它也会匹配空字符串，但在这个例子中它匹配了三个 "a"）。 |
| **匹配一次或多次**：   | `+` 例如，`a+` 匹配一个或多个 "a"。                          | 实例：`"aaa"` 会被 `a+` 匹配（但不会匹配空字符串）。         |
| **匹配零次或一次**：   | `?` 例如，`a?` 可以匹配空字符串或一个 "a"。                  | 实例：`"a"` 和空字符串 `""` 都会被 `a?` 匹配。               |
| **匹配指定次数**：     | `{n}` 例如，`a{3}` 匹配三个连续的 "a"。                      | `"aaa"` 会被 `a{3}` 匹配。                                   |
| **匹配至少指定次数**： | `{n,}` 例如，`a{2,}` 匹配两个或更多连续的 "a"。              | 实例：`"aaa"` 会被 `a{2,}` 匹配。                            |
| **匹配指定次数范围**： | `{n,m}` 例如，`a{2,4}` 匹配两个到四个连续的 "a"。            | `"aa"`、`"aaa"` 和 `"aaaa"` 会被 `a{2,4}` 匹配，但 `"a"` 和 `"aaaaa"` 不会。 |

### 4）分组和捕获

| 模式         | 说明                                                         | 样例                                                         |
| ------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **分组**：   | 使用圆括号 `()` 可以将多个字符组合成一个组，以便作为一个整体进行匹配。 | `"(abc)"` 匹配字符串 "abc" 并将其作为一个组捕获。            |
| **捕获组**： | 匹配的结果可以存储在捕获组中，以便后续引用或操作。           | 在替换操作中，可以使用 `\1`、`\2` 等来引用第一个、第二个捕获组的内容。 |

### 5）边界匹配

| 模式                   | 说明                                         | 样例                                                    |
| ---------------------- | -------------------------------------------- | ------------------------------------------------------- |
| **匹配字符串的开始**： | `^` 例如，`^abc` 匹配以 "abc" 开头的字符串。 | `"abcdef"` 会被 `^abc` 匹配。                           |
| **匹配字符串的结束**： | `$` 例如，`abc$` 匹配以 "abc" 结尾的字符串。 | `"xyzabc"` 会被 `abc$` 匹配（如果它是整个字符串的话）。 |

### 6）逻辑运算符

| 模式             | 说明                                                         | 样例                                      |
| ---------------- | ------------------------------------------------------------ | ----------------------------------------- |
| **或运算**：     | `|` 例如，`a|b` 匹配 "a" 或 "b"。                            | `"a"` 和 `"b"` 都会被 `a|b` 匹配。        |
| **字符集取反**： | `[^...]` 例如，`[^abc]` 匹配任何不是 "a"、"b" 或 "c" 的字符。 | `"d"` 会被 `[^abc]` 匹配，但 `"a"` 不会。 |





# 2、`match.group`

> `Matcher` 类中`group(0)` 表示正则表达式中符合条件的字符串。      
>
> `Matcher` 类中 `group(1)` 表示正则表达式中符合条件的字符串中的第一个() 中的字符串。     
>
> `Matcher` 类中 `group(2)` 表示正则表达式中符合条件的字符串中的第二个() 中的字符串。      
>
> `Matcher` 类中 `group(3)` 表示正则表达式中符合条件的字符串中的第三个() 中的字符串。

```java
 @Test
    public void test(){
        String line = "123ra9040 123123aj234 adf12322ad 222jsk22";
        ////d+ 表示最少匹配一个数字、[a-z]+ 表示最少匹配一个字符
        String pattern = "(\\d+)([a-z]+)(\\d+)";

        // 创建 Pattern 对象
        Pattern r = Pattern.compile(pattern);

        // 现在创建 matcher 对象
        Matcher m = r.matcher(line);
        int i = 0;
        // m.find 是否找到正则表达式中符合条件的字符串
        while (m.find( )) {
            // 拿到上面匹配到的数据
            System.out.println("----i="+i);
            System.out.println("Found value: " + m.group(0) );
            System.out.println("Found value: " + m.group(1) );
            System.out.println("Found value: " + m.group(2) );
            System.out.println("Found value: " + m.group(3) );
            i++;
            System.out.println("=============");
        }
    }
```





```java
----i=0
Found value: 123ra9040
Found value: 123
Found value: ra
Found value: 9040
=============
----i=1
Found value: 123123aj234
Found value: 123123
Found value: aj
Found value: 234
=============
----i=2
Found value: 222jsk22
Found value: 222
Found value: jsk
Found value: 22
=============
```







![ContactAuthor](https://raw.githubusercontent.com/HealerJean/HealerJean.github.io/master/assets/img/artical_bottom.jpg)



<!-- Gitalk 评论 start  -->

<link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">

<script src="https://unpkg.com/gitalk@latest/dist/gitalk.min.js"></script> 
<div id="gitalk-container"></div>    
 <script type="text/javascript">
    var gitalk = new Gitalk({
		clientID: `1d164cd85549874d0e3a`,
		clientSecret: `527c3d223d1e6608953e835b547061037d140355`,
		repo: `HealerJean.github.io`,
		owner: 'HealerJean',
		admin: ['HealerJean'],
		id: 'Wu8ZlJPzYCiUTEKI',
    });
    gitalk.render('gitalk-container');
</script> 




<!-- Gitalk end -->



