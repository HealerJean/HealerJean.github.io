---
title: 短连接生成
date: 2022-04-14 00:00:00
tags: 
- Java
category: 
- Java
description: 短连接生成
---

**前言**     

 Github：[https://github.com/HealerJean](https://github.com/HealerJean)         

 博客：[http://blog.healerjean.com](http://HealerJean.github.io)          

# 1、短链接介绍

> 短码一般是由 `[a - z, A - Z, 0 - 9]` 这62 个字母或数字组成，短码的长度也可以自定义，但一般不超过8位。比较常用的都是6位，6位的短码已经能有568亿种的组合：(26+26+10)^6 = 56800235584，已满足绝大多数的使用场景。        
>
> 目前比较流行的生成短码方法有：`自增id`、`摘要算法`、`普通随机数`。



# 2、短连接生成方案

## 2.1、自增id

> 该方法是一种无碰撞的方法，原理是，每新增一个短码，就在上次添加的短码id基础上加1，然后将这个`10`进制的id值，转化成一个`62 `进制的字符串。                     
>
> > 生成方法：**数据库自增主键、Redis的INCR、分布式ID（雪花算法）**



### 2.1.2、缺点

> 1、短码 `id` 是从一位长度开始递增，短码的长度不固定       
>
> 2、生成的短码是有序的，可能会有安全的问题           



## 2.2、`MD5` 哈希

> 使用 `MD5` 哈希，可以实现输入任意长度的数据，输出固定长度的数据。相同的输入数据始终得到相同的输出，不同的输入数据尽量得到不同的输出。      
>
> 
>
> > 生成方法：`MD5`加密结果分为`8`位一组，最后产生`4` 个短地址，取里面的任意一个，这样做重复的概率被大大提高了(8b28a2b4d81d96b8bf6169a638f105c7)。

### 2.2.1、优缺点

> **优点**：链接的长度始终不变，同一长链接多次生成短链接，结果不变           
>
> **缺点：**哈希算法可能会产生冲突，虽然几率很小，但是该方法依然存在碰撞的可能性，解决冲突会比较麻烦。



## 2.3、普通随机数

> 从 `62`个字符串中随机取出一个 `6`位短码的组合，然后去数据库中查询该短码是否已存在。如果已存在，就继续循环该方法重新获取短码，否则就直接返回。

### 2.3.1、优缺点

> 优点：该方法是最简单的一种实现       
>
> 缺点：     
>
> 1、不过由于`Math.round()`方法生成的随机数属于伪随机数，碰撞的可能性也不小。
>
> 2、在数据比较多的情况下，可能会循环很多次，才能生成一个不冲突的短码。





# 3、实现方案

> 选择：摘要算法。

## 3.1、数据库存储

> **1、域名和后缀存储设计**：短网址基础数据采用域名和后缀分开存储的形式。另外域名需要区分 `HTTP` 和 `HTTPS`，`hash`方案针对整个链接进行`hash `而不是除了域名外的链接。域名单独保存可以用于分析当前域名下链接的使用情况。           
>
> **2、链接有效期设计**：增加当前链接有效期字段，一般有短链需求的可能是相关活动或者热点事件，这种短链在一段时间内会很活跃，过了一定时间热潮会持续衰退。所以没有必要将这种链接永久保存增加每次查询的负担。



| 字段                | 说明                       |
| ------------------- | -------------------------- |
| `base_url`          | 域名                       |
| `suffix_url`        | 链接除了域名外的后缀       |
| `full_url`          | 完整链接                   |
| `shot_code`         | 当前 suffix_url 链接的短码 |
| `expiration_date`   | 失效日期                   |
| `total_click_count` | 当前链接总点击次数         |



| `base_url`              | `suffix_url`           | `shot_code` | `total_click_count` | `full_url`                                     | `expiration_date` |
| ----------------------- | ---------------------- | ----------- | ------------------- | ---------------------------------------------- | ----------------- |
| http://www.aichacha.com | /search/12345          | edfg3s      |                     | http://www.aichacha.com//search/12345          |                   |
| http://www.aichacha.com | /aiCheck/getResult/123 | Fe9dq       |                     | http://www.aichacha.com//aiCheck/getResult/123 |                   |



## 3.2、缓存设计

> 如果短连接非常多，对于几百个`G`的数据量都放在缓存肯定不行，因此考虑缓存时间限制：缓存时间3个月，命中缓存，就不用走库。查不到的时候再走库更新缓存。



# 4、短链接跳转

>  例如访问http://code.cn/a5dw98

1、DNS进行解析，得到code.cn域名对应的IP地址     

2、向得到的IP地址发送GET请求，查询短码a5dw98     

3、服务器通过短码查询数据库得到对应的长URL     

4、请求通过HTTP 301状态码，将请求重定向到长URL

⬤ 301：永久重定向、**搜索引擎在抓取新的内容的同时也将旧的网址替换为了重定向之后的网址**，使用301无法统计短链接被点击的次数，无法收集用户的Cookie等信息。      

⬤ 302：临时重定向、**搜索引擎会抓取新的内容而保留旧的地址，搜索搜索引擎认为新的网址是暂时的**，302跳转每次会去访问短链接服务器，从而获取长链接再去访问，效率低而且会给短链接服务器负载压力。



![ContactAuthor](https://raw.githubusercontent.com/HealerJean/HealerJean.github.io/master/assets/img/artical_bottom.jpg)



<!-- Gitalk 评论 start  -->

<link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">

<script src="https://unpkg.com/gitalk@latest/dist/gitalk.min.js"></script> 
<div id="gitalk-container"></div>    
 <script type="text/javascript">
    var gitalk = new Gitalk({
		clientID: `1d164cd85549874d0e3a`,
		clientSecret: `527c3d223d1e6608953e835b547061037d140355`,
		repo: `HealerJean.github.io`,
		owner: 'HealerJean',
		admin: ['HealerJean'],
		id: 'YdDe9ho8pmKJNcxs',
    });
    gitalk.render('gitalk-container');
</script> 




<!-- Gitalk end -->



