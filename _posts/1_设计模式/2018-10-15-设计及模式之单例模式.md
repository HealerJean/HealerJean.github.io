---
title: 设计及模式之单例模式
date: 2018-10-15 03:33:00
tags: 
- Java
category: 
- Java
description: 设计及模式之单例模式
---



**前言**     

 Github：[https://github.com/HealerJean](https://github.com/HealerJean)         

 博客：[http://blog.healerjean.com](http://HealerJean.github.io)           



# 1、单例模式

> 单例对象（Singleton）是一种常用的设计模式。在Java应用中，<font color="red">  单例对象能保证在一个JVM中，该对象只有一个实例存在。</font>

## 1.1、作用

1、某些类创建比较频繁，对于一些大型的对象，这是一笔很大的系统开销。      

2、有些类如交易所的核心交易引擎，控制着交易流程，如果该类可以创建多个的话，系统完全乱了。（比如一个军队出现了多个司令员同时指挥，肯定会乱成一团），所以只有使用单例模式，才能保证核心交易服务器独立控制整个流程。     

## 1.2、使用场景 

1、	控制资源的使用，通过线程同步来控制资源的并发访问 （比如线程导入学籍，控制导入成功的数据）

2、	控制实例的产生，以达到节约资源的目的

3、	控制数据的共享，在不建立直接关联的条件下，让多个不相关的进程或线程之间实现通信 （启动的时候就开始，比如数据源的配置）


### 1.2.1、简单的单例模式（有缺陷）

>  这个类可以满足基本要求，但是，像这样毫无线程安全保护的类，如果我们把它放入多线程的环境下，肯定就会出现问题了，如何解决？我们首先会想到对getInstance方法加synchronized关键字，如下：
>

```java

package com.hlj.designpatterns.Singleton.one;
/** 
 * @author 作者 HealerJean
 * @version 创建时间：2017年9月26日 上午9:57:27 
 * 类说明 
 */
public class Singleton {  
	  
    /* 持有私有静态实例，防止被引用，此处赋值为null，目的是实现延迟加载 */   
    private static Singleton instance = null;  
  
    /* 私有构造方法，防止被实例化 */  
    private Singleton() {  
    }  
  
    /* 1、静态工程方法，创建实例 */  
     public static Singleton getInstance() {  
        if (instance == null) {  
            instance = new Singleton();  
        }  
        return instance;  
    }  
   }

```




### 1.2.2、synchronized 上锁

>  但是，synchronized关键字锁住的是这个对象，这样的用法，在性能上会有所下降，因为每次调用getInstance()，都要对对象上锁，事实上，只有在第一次创建对象的时候需要加锁，之后就不需要了，所以，这个地方需要改进。我们改成下面这个：
>

```java
public static synchronized Singleton getInstance() {  
    if (instance == null) {  
        instance = new Singleton();  
    }  
    return instance;  
} 

```



### 3、最终的单例模式


```java

public class SingletonFinal {  
	  
    private static SingletonFinal instance = null;  
  
    private SingletonFinal() {  
    }  
  
    private static synchronized void syncInit() {  
        if (instance == null) {  
            instance = new SingletonFinal();  
        }  
    }  
  
    public static SingletonFinal getInstance() {  
        if (instance == null) {  
            syncInit();  
        }  
        return instance;  
    }  
}  

```



## 1.3、静态内部类存在的问题

> 通过静态内部类的方式实现单例模式是线程安全的，同时静态内部类不会在`Singleton`类加载时就加载，而是在调用`getInstance()`方法时才进行加载，达到了懒加载的效果。   

### 3.1.1、可能存在反射攻击     

```java
public class Singleton {

    private static class SingletonHolder {
        private static Singleton instance = new Singleton();
    }

    private Singleton() {

    }

    public static Singleton getInstance() {
        return SingletonHolder.instance;
    }
}
```



```java
public static void main(String[] args) throws Exception {
    Singleton singleton = Singleton.getInstance();
    Constructor<Singleton> constructor = Singleton.class.getDeclaredConstructor();
    constructor.setAccessible(true);
    Singleton newSingleton = constructor.newInstance();
    System.out.println(singleton == newSingleton); //false
}

// 这两个实例不是同一个，这就违背了单例模式的原则了。

```



### 3.1.2、可能存在反序列化攻击

```java
public class Singleton implements Serializable {

    private static class SingletonHolder {
        private static Singleton instance = new Singleton();
    }

    private Singleton() {

    }

    public static Singleton getInstance() {
        return SingletonHolder.instance;
    }

    public static void main(String[] args) {
        Singleton instance = Singleton.getInstance();
        byte[] serialize = SerializationUtils.serialize(instance);
        Singleton newInstance = SerializationUtils.deserialize(serialize);
        System.out.println(instance == newInstance); //false
    }
}
```



## 1.4、单例模式缺点

### 1.4.2、单例不支持有参数的构造函数

> 单例不支持有参数的构造函数，比如创建一个连接池的单例对象，没法通过参数来指定连接池的大小。    
>
> 解决方式：将参数配置化。在单例实例化时，从外部读取参数。   

### 1.4.3、单例对代码的扩展性不友好

> 单例类只能有一个对象实例。如果未来某一天，需要在代码中创建两个实例或多个实例，那就要对代码有比较大的改动。   





## 1.4、枚举类型实现的单例模式是最佳的方式

> 枚举方式实现的单例模式不仅能避免多线程同步的问题，也可以防止反序列化和反射的破坏。



```java
public enum Singleton {

    INSTANCE;

    public void doSomething() {
        System.out.println("doSomething");
    }

}
```

### 1.4.1、JVM级别的线程安全

> 反编译的代码中可以发现枚举中的各个枚举项都是通过static代码块来定义和初始化的，他们会在类被加载时完成初始化，而Java的类加载由`JVM`保证线程安全。   



### 1.4.2、防止反序列化的破坏

> 1、在序列化时，只是将枚举对象的name属性输出到结果中，     
>
> 2、在反序列化时通过`java.lang.Enum`的`valueOf`方法根据名字查找对象，而不是新建一个新的对象，所以防止了反序列化对单例的破坏。



### 1.4.3、防止反射的破坏

> 射在通过`newInstance`创建对象时会检查这个类是否是枚举类，如果是枚举类就会`throw new IllegalArgumentException("Cannot reflectively create enum objects");`,如下是源码`java.lang.reflect.Constructor#newInstance`：



















​        






![](https://raw.githubusercontent.com/HealerJean/HealerJean.github.io/master/assets/img/artical_bottom.jpg)


<!-- Gitalk 评论 start  -->

<link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk@latest/dist/gitalk.min.js"></script> 
<div id="gitalk-container"></div>    
 <script type="text/javascript">
    var gitalk = new Gitalk({
		clientID: `1d164cd85549874d0e3a`,
		clientSecret: `527c3d223d1e6608953e835b547061037d140355`,
		repo: `HealerJean.github.io`,
		owner: 'HealerJean',
		admin: ['HealerJean'],
		id: '98ZDdqE6YpwnKjQx',
    });
    gitalk.render('gitalk-container');
</script> 

<!-- Gitalk end -->

