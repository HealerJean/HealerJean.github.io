---
title: 设计模式之_6大设计原则
date: 2020-01-01 03:33:00
tags: 
- DesignPattern
category: 
- DesignPattern
description: 设计模式之_6大设计原则
---

**前言**     

 Github：[https://github.com/HealerJean](https://github.com/HealerJean)         

 博客：[http://blog.healerjean.com](http://HealerJean.github.io)          



![image-20210706205043822](/Users/healerjean/Desktop/HealerJean/HCode/HealerJean.github.io/blogImages/image-20210706205043822.png)





# 1、单一职责

## 1.1、解释：

> 官方定义：
>
> > 就一个类(接口、结构体、方法等等)而言，有且仅有一个引起它变化的原因。      
>
> 
>
> 个人理解：
>
> > 通俗的来讲做一件事就是专注做一件事，不可以三心二意。任务对象只是专注于一项职责，不去承担太多的责任。当任务对象的职责发生变化时，不会对其他的对象产生影响。

​        



## 1.1、应用

> 背景：有一个类A，他需要负责T1和T2。但是当职责T1因为需求而改变类A的时候，就会对职责T2造成影响，导致T2不能正常工作。    
>
> 解决办法：针对职责T1创建类A，针对职责T2创建类B。这样就可以达到当修改类A时不会对职责T2造成影响，当修改类B时不会对职责T1造成影响。



# 2、里氏替换原则

## 2.1、解释：

> **官方定义**：里氏代换原则(`Liskov Substitution Principle LSP`)面向对象设计的基本原则之一。       
>
> > ⬤ **里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现**。      
> >
> > ⬤ **`LSP` 是继承复用的基石，只有当衍生类可以替换掉基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为**。
>
> 
>
> **个人理解**：子类可以扩展父类的功能，但不能改变父类原有的功能，子类中尽量不要去重写父类方法，`A`类的所有方法都被`B`类重写了。 那何必继承呢？直接新建一个`B`类不就好了，采用`final` 的手段强制来遵循
>
> > ⬤ 子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法。      
> >
> > ⬤ 子类中可以增加自己特有的方法。       
> >
> > ⬤ 当子类的方法重载父类的方法时，方法的前置条件要比父类方法的输入参数更宽松。        
> >
> > ⬤ 子类的方法实现父类的抽象方法时，方法的返回值要比父类的返回值更加严谨。





## 2.2、应用

> 经典案例之正方形不是长方形：

### 2.2.1、反例

#### 2.2.1.1、`Rectangle` 类

```java
@Data
@AllArgsConstructor
public class Rectangle {

	private int width;
	private int height;


	public int area() {
		return width * height;
	}

}

```

#### 2.2.1.2、`Square` 类

```java
@Data
@AllArgsConstructor
public class Square extends Rectangle {

	public int area() {
		return width * width;
	}
}

```



#### 2.2.1.3、`Tester` 类

```java
public class Tester {

  public static void main(String[] args) {
    Rectangle rectangle = new Rectangle(10, 20);
    System.out.println("面积：" + rectangle.area());
    // 输出结果为面积：200

    Square rectangle = new Square(10, 20);
    System.out.println("面积：" + rectangle.area());
    // 输出结果为面积：0
  }
}

```



#### 2.2.1.4、分析总结

问题1：：为什么当`Rectangle`替换为`Square`之后，面积的结果出错了呢？       

答案：因为在`Square`类里重写了`area()`方法，很明显违背了里氏替换原则，改变了父类的原有功能，所以导致输出结果不对。





# 3、依赖倒置原则

## 3.1、解释

> 高层模块不应该依赖低层模块，二者都应该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象。

















![ContactAuthor](https://raw.githubusercontent.com/HealerJean/HealerJean.github.io/master/assets/img/artical_bottom.jpg)



<!-- Gitalk 评论 start  -->

<link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">

<script src="https://unpkg.com/gitalk@latest/dist/gitalk.min.js"></script> 
<div id="gitalk-container"></div>    
 <script type="text/javascript">
    var gitalk = new Gitalk({
		clientID: `1d164cd85549874d0e3a`,
		clientSecret: `527c3d223d1e6608953e835b547061037d140355`,
		repo: `HealerJean.github.io`,
		owner: 'HealerJean',
		admin: ['HealerJean'],
		id: 'mboIeYypvUB7D3PE',
    });
    gitalk.render('gitalk-container');
</script> 




<!-- Gitalk end -->



