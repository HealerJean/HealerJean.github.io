package com.hlj.arith.demo00040_有效的数独;

import org.junit.Test;

import java.util.HashSet;

/**
作者：HealerJean
题目：有效的数独
 判断一个 9x9 的数独是否有效。只需要根据以下规则，验证已经填入的数字是否有效即可。
 数字 1-9 在每一行只能出现一次。
 数字 1-9 在每一列只能出现一次。
 数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。
     示例 1:
         输入:
         [
         ['5','3','.','.','7','.','.','.','.'],
         ['6','.','.','1','9','5','.','.','.'],
         ['.','9','8','.','.','.','.','6','.'],
         ['8','.','.','.','6','.','.','.','3'],
         ['4','.','.','8','.','3','.','.','1'],
         ['7','.','.','.','2','.','.','.','6'],
         ['.','6','.','.','.','.','2','8','.'],
         ['.','.','.','4','1','9','.','.','5'],
         ['.','.','.','.','8','.','.','7','9']
         ]
         输出: true
    示例 2:
     输入:
     [
       ['8','3','.','.','7','.','.','.','.'],
       ['6','.','.','1','9','5','.','.','.'],
       ['.','9','8','.','.','.','.','6','.'],
       ['8','.','.','.','6','.','.','.','3'],
       ['4','.','.','8','.','3','.','.','1'],
       ['7','.','.','.','2','.','.','.','6'],
       ['.','6','.','.','.','.','2','8','.'],
       ['.','.','.','4','1','9','.','.','5'],
       ['.','.','.','.','8','.','.','7','9']
     ]
     输出: false 解释: 由于位于左上角的 3x3 宫内有两个 8 存在, 因此这个数独是无效的。
 说明:
 一个有效的数独（部分已被填充）不一定是可解的。
 只需要根据以上规则，验证已经填入的数字是否有效即可。
 给定数独序列只包含数字 1-9 和字符 . 。
 给定数独永远是 9x9 形式的。

 解题思路：
HashSet，不可保存重复元素，用3个HashSet，分别保存第i行、第i列和第i个3x3的九宫格中的元素，每处理一个元素，
 我们最简单的就是先判断，所有的位置的所在的行，所在列没有重复的。然后再判断这9个 3* 3的表格没有重复的，
 那么判断重复最简单的就是set了吧。然后看下面的代码吧**

*/
public class 有效的数独 {

    @Test
    public void test(){
        char[][] board = {
                {'8','3','.','.','7','.','.','.','.'},
                {'6','.','.','1','9','5','.','.','.'},
                {'.','9','8','.','.','.','.','6','.'},
                {'8','.','.','.','6','.','.','.','3'},
                {'4','.','.','8','.','3','.','.','1'},
                {'7','.','.','.','2','.','.','.','6'},
                {'.','6','.','.','.','.','2','8','.'},
                {'.','.','.','4','1','9','.','.','5'},
                {'.','.','.','.','8','.','.','7','9'}
        };
        System.out.println(isValidSudoku(board));
    }


    public boolean isValidSudoku(char[][] board) {
        //最外层循环，每次循环并非只是处理第i行，而是处理第i行、第i列以及第i个3x3的九宫格
        for (int i = 0; i < 9; i++) {
            //line
            HashSet<Character> line = new HashSet<>();
            HashSet<Character> col = new HashSet<>();
            HashSet<Character> cube = new HashSet<>();
            for (int j = 0; j < 9; j++) {
                // 判断第 i 行 有没有重复
                if ('.' != board[i][j] && !line.add(board[i][j])) {
                    return false;
                }
                // 判断 i 列 有没有重复
                if ('.' != board[j][i] && !col.add(board[j][i])) {
                    return false;
                }

                //判断第 i 个 3 * 3 九宫格有没有重复
                int m = i / 3 * 3 + j / 3;
                int n = i % 3 * 3 + j % 3;
                if ('.' != board[m][n] && !cube.add(board[m][n])) {
                    return false;
                }
            }
        }
        return true;
    }
}
