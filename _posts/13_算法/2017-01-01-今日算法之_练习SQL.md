---
title: 今日算法之_练习SQL
date: 2020-02-20 03:33:00
tags: 
- Arithmetic
category: 
- Arithmetic
description: 今日算法之_练习SQL
---

**前言**     

 Github：[https://github.com/HealerJean](https://github.com/HealerJean)         

 博客：[http://blog.healerjean.com](http://HealerJean.github.io)          

# 1、大的国家

## 1.1、题目

这里有张 World 表

```
+-----------------+------------+------------+--------------+---------------+
| name            | continent  | area       | population   | gdp           |
+-----------------+------------+------------+--------------+---------------+
| Afghanistan     | Asia       | 652230     | 25500100     | 20343000      |
| Albania         | Europe     | 28748      | 2831741      | 12960000      |
| Algeria         | Africa     | 2381741    | 37100000     | 188681000     |
| Andorra         | Europe     | 468        | 78115        | 3712000       |
| Angola          | Africa     | 1246700    | 20609294     | 100990000     |
+-----------------+------------+------------+--------------+---------------+
```

如果一个国家的面积超过300万平方公里，或者人口超过2500万，那么这个国家就是大国家。   

编写一个SQL查询，输出表中所有大国家的名称、人口和面积。     

例如，根据上表，我们应该输出:

```
+--------------+-------------+--------------+
| name         | population  | area         |
+--------------+-------------+--------------+
| Afghanistan  | 25500100    | 652230       |
| Algeria      | 37100000    | 2381741      |
+--------------+-------------+--------------+
```



## 1.2、数据准备

```sql
drop table if exists World;
create table World(
    name varchar(32),
    continent varchar(32),
    area int,
    population int,
    gdp int
);
insert into World(name, continent, area, population, gdp) values ('Afghanistan', 'Asia', 652230, 25500100, 20343000);
insert into World(name, continent, area, population, gdp) values ('Albania', 'Europe', 28748, 2831741, 12960000);
insert into World(name, continent, area, population, gdp) values ('Algeria', 'Africa', 2381741, 37100000, 188681000);
insert into World(name, continent, area, population, gdp) values ('Algeria', 'Europe', 468, 78115, 3712000);
insert into World(name, continent, area, population, gdp) values ('Angola', 'Africa', 1246700, 20609294, 100990000);
select * from World;
```



## 1.2、答案

```sql
select name, population, area from World where area > 3000000 or population > 25000000;
```



# 2、第n高的薪水

## 2.1、题目

> 编写一个 SQL 查询，获取 Employee 表中第 n 高的薪水（Salary）。
>

```
+----+--------+
| Id | Salary |
+----+--------+
| 1  | 100    |
| 2  | 200    |
| 3  | 300    |
+----+--------+  


```

例如上述 Employee 表，n = 2 时，应返回第二高的薪水 200。如果不存在第 n 高的薪水，那么查询应返回 null。

```
+------------------------+
| getNthHighestSalary(2) |
+------------------------+
| 200                    |
+------------------------+
```



## 2.2、数据准备

```sql
drop table if exists employee;
create table employee
(

    id     int(11),
    salary int(11)
)
select * from employee;
insert into employee (id, salary) values (1, 100);
insert into employee (id, salary) values (2, 200);
insert into employee (id, salary) values (3, 300);
```



## 2.3、答案

```sql
 select distinct(a.salary)
        from employee a
        where (select count(distinct b.salary) from employee b where b.salary >= a.salary) = n
```





# 3、分数排名

## 3.1、题目



> 编写一个 SQL 查询来实现分数排名。    
>
> 如果两个分数相同，则两个分数排名（Rank）相同。请注意，平分后的下一个名次应该是下一个连续的整数值。换句话说，名次之间不应该有“间隔”。

```
+----+-------+
| Id | Score |
+----+-------+
| 1  | 3.50  |
| 2  | 3.65  |
| 3  | 4.00  |
| 4  | 3.85  |
| 5  | 4.00  |
| 6  | 3.65  |
+----+-------+
```

例如，根据上述给定的 Scores 表，你的查询应该返回（按分数从高到低排列）：

```
+-------+------+
| Score | Rank |
+-------+------+
| 4.00  | 1    |
| 4.00  | 1    |
| 3.85  | 2    |
| 3.65  | 3    |
| 3.65  | 3    |
| 3.50  | 4    |
+-------+------+
```



## 3.2、数据准备

```sql
drop table if exists  Scores ;
create table Scores
(

    Id     int(11) ,
    Score  decimal(16,2)
);

truncate Scores;
insert into Scores (Id, Score) values (1, 3.50);
insert into Scores (Id, Score) values (2, 3.65);
insert into Scores (Id, Score) values (3, 4.00);
insert into Scores (Id, Score) values (4, 3.85);
insert into Scores (Id, Score) values (5, 4.00);
insert into Scores (Id, Score) values (6, 3.65);

```



## 3.2、答案

### 3.2.1、答案1

> 解析：子查询查询大于A中等于（唯一，因为会有重复的分数比它大，重复的分数看做是一个排名）分数的的个数 也就是排名

```sql
select A.Score as score,
       (select count(distinct B.Score) from Scores B where B.Score >= A.Score) as Rank
from Scores A
order by Score
desc;
```



### 3.2.2、答案2

```sql
SELECT
    Score,
    case
        when  @curScore = Score then @curRank
        when  @curScore := Score THEN 	@curRank := @curRank + 1
        end as Rank
FROM
    Scores,
    (SELECT @curRank := 0 , @curScore) r
ORDER BY
    Score DESC;

```



# 4、连续出现的数字

## 4.1、题目

>   编写一个 SQL 查询，查找所有至少连续出现三次的数字。

```
+----+-----+
| Id | Num |
+----+-----+
| 1  |  1  |
| 2  |  1  |
| 3  |  1  |
| 4  |  2  |
| 5  |  1  |
| 6  |  2  |
| 7  |  2  |
+----+-----+
```

例如，给定上面的 Logs 表， 1 是唯一连续出现至少三次的数字。

```
+-----------------+
| ConsecutiveNums |
+-----------------+
| 1               |
+-----------------+
```



## 4.2、数据准备

```sql
drop table  if exists  Logs  ;
create table Logs
(

    Id     int(11) ,
    Num   int(11)
);

select * from Logs ;
insert into logs (Id, Num) values (1, 1);
insert into logs (Id, Num) values (2, 1);
insert into logs (Id, Num) values (3, 1);
insert into logs (Id, Num) values (4, 2);
insert into logs (Id, Num) values (5, 1);
insert into logs (Id, Num) values (6, 2);
insert into logs (Id, Num) values (7, 2);
```



## 4.2、答案

```sql

select distinct (a.Num) as ConsecutiveNums
from logs a
         join logs b on a.Num = b.Num
         join logs c on a.Num = c.Num
where a.Id = b.Id - 1
  and b.Id = c.Id - 1;
```





# 5、超过经理收入的员工

## 5.1、题目

>   Employee 表包含所有员工，他们的经理也属于员工。每个员工都有一个 Id，此外还有一列对应员工的经理的 Id。

```
+----+-------+--------+-----------+
| Id | Name  | Salary | ManagerId |
+----+-------+--------+-----------+
| 1  | Joe   | 70000  | 3         |
| 2  | Henry | 80000  | 4         |
| 3  | Sam   | 60000  | NULL      |
| 4  | Max   | 90000  | NULL      |
+----+-------+--------+-----------+
```

给定 Employee 表，编写一个 SQL 查询，该查询可以获取收入超过他们经理的员工的姓名。在上面的表格中，Joe 是唯一一个收入超过他的经理的员工。

```
+----------+
| Employee |
+----------+
| Joe      |
+----------+
```



## 5.2、数据准备

```sql
drop table if exists Employee;
create table Employee
(

    Id        int(11),
    Name      varchar(20),
    Salary    decimal(16, 2),
    ManagerId int(11)
)

```



## 5.2、答案

```sql
select e.Name as Employee
from Employee e  join Employee m on e.ManagerId = m.Id
where e.Salary > m.Salary;
```



# 6、从不订购的客户

## 6.1、题目

>  某网站包含两个表，Customers 表和 Orders 表。编写一个 SQL 查询，找出所有从不订购任何东西的客户。



Customers 表：

```
+----+-------+
| Id | Name  |
+----+-------+
| 1  | Joe   |
| 2  | Henry |
| 3  | Sam   |
| 4  | Max   |
+----+-------+
```

Orders 表：

```
+----+------------+
| Id | CustomerId |
+----+------------+
| 1  | 3          |
| 2  | 1          |
+----+------------+
```

例如给定上述表格，你的查询应返回：

```
+-----------+
| Customers |
+-----------+
| Henry     |
| Max       |
+-----------+
```



## 6.2、数据准备

```sql
drop table if exists  Customers  ;
create table Customers(
    Id int(11),
    Name varchar(20)
);
drop table if exists  Orders   ;
create table Orders(
    Id int(11),
    CustomerId int(11)
);
```



## 6.2、答案

```sql
select C.Name AS Customers
from Customers C
where C.Id not in (select distinct (O.CustomerId) from Orders O);
```





# 7、部门工资最高的员工

## 7.1、题目

Employee 表包含所有员工信息，每个员工有其对应的 Id, salary 和 department Id。

```
+----+-------+--------+--------------+
| Id | Name  | Salary | DepartmentId |
+----+-------+--------+--------------+
| 1  | Joe   | 70000  | 1            |
| 2  | Henry | 80000  | 2            |
| 3  | Sam   | 60000  | 2            |
| 4  | Max   | 90000  | 1            |
+----+-------+--------+--------------+
```

Department 表包含公司所有部门的信息。

```
+----+----------+
| Id | Name     |
+----+----------+
| 1  | IT       |
| 2  | Sales    |
+----+----------+
```

编写一个 SQL 查询，找出每个部门工资最高的员工。例如，根据上述给定的表格，Max 在 IT 部门有最高工资，Henry 在 Sales 部门有最高工资。

```
+------------+----------+--------+
| Department | Employee | Salary |
+------------+----------+--------+
| IT         | Max      | 90000  |
| Sales      | Henry    | 80000  |
+------------+----------+--------+
```



## 7.2、数据准备

```mysql
drop table if exists Employee;
create table Employee
(
    Id           int(11),
    Name         varchar(20),
    Salary       decimal(20, 0),
    DepartmentId int(11)
);
drop table if exists Department;
create table Department
(
    Id         int(11),
    Name       varchar(20)
);

select *  from Employee ;
insert into employee (Id, Name, Salary, DepartmentId) values (1, 'Joe', 70000, 1);
insert into employee (Id, Name, Salary, DepartmentId) values (2, 'Henry', 80000, 2);
insert into employee (Id, Name, Salary, DepartmentId) values (3, 'Sam', 60000, 2);
insert into employee (Id, Name, Salary, DepartmentId) values (4, 'Max', 90000, 1);

select *  from Department ;
insert into department (Id, Name) values (1, 'IT');
insert into department (Id, Name) values (2, 'Sales');
```



## 7.2、答案

### 7.2.1、答案1

```sql
select D.Name as Department, A.Name as Employee, A.Salary
from Employee A
         join Department D on A.DepartmentId = D.Id
         join (select max(Salary) as MaxSalary, B.DepartmentId from Employee B group by DepartmentId) C
                   on C.DepartmentId = A.DepartmentId
where A.Salary = C.MaxSalary;

```

### 7.2.2、答案2

```sql
SELECT D.Name AS 'Department',
       E.Name AS 'Employee',
       E.Salary
FROM Employee E
         JOIN
     Department D ON E.DepartmentId = D.Id
WHERE (SELECT COUNT(DISTINCT A.Salary)
       FROM Employee A
       WHERE A.Salary > E.Salary
       AND A.DepartmentId = E.DepartmentId
      ) < 1;

```



# 8、部门工资前三高的所有员工

## 8.1、题目

Employee 表包含所有员工信息，每个员工有其对应的工号 Id，姓名 Name，工资 Salary 和部门编号 DepartmentId 。

```
+----+-------+--------+--------------+
| Id | Name  | Salary | DepartmentId |
+----+-------+--------+--------------+
| 1  | Joe   | 85000  | 1            |
| 2  | Henry | 80000  | 2            |
| 3  | Sam   | 60000  | 2            |
| 4  | Max   | 90000  | 1            |
| 5  | Janet | 69000  | 1            |
| 6  | Randy | 85000  | 1            |
| 7  | Will  | 70000  | 1            |
+----+-------+--------+--------------+
```

Department 表包含公司所有部门的信息。

```
+----+----------+
| Id | Name     |
+----+----------+
| 1  | IT       |
| 2  | Sales    |
+----+----------+
```

编写一个 SQL 查询，找出每个部门获得前三高工资的所有员工。例如，根据上述给定的表，查询结果应返回：

```
+------------+----------+--------+
| Department | Employee | Salary |
+------------+----------+--------+
| IT         | Max      | 90000  |
| IT         | Randy    | 85000  |
| IT         | Joe      | 85000  |
| IT         | Will     | 70000  |
| Sales      | Henry    | 80000  |
| Sales      | Sam      | 60000  |
+------------+----------+--------+
```

解释：    

IT 部门中，Max 获得了最高的工资，Randy 和 Joe 都拿到了第二高的工资，Will 的工资排第三。销售部门（Sales）只有两名员工，Henry 的工资最高，Sam 的工资排第二。



## 8.2、数据准备

```mysql
drop table if exists Employee;
create table Employee
(
    Id           int(11),
    Name         varchar(20),
    Salary       decimal(20, 0),
    DepartmentId int(11)
);
drop table if exists Department;
create table Department
(
    Id         int(11),
    Name       varchar(20)
);

select *  from Employee ;
insert into employee (Id, Name, Salary, DepartmentId) values (1, 'Joe', 85000, 1);
insert into employee (Id, Name, Salary, DepartmentId) values (2, 'Henry', 80000, 2);
insert into employee (Id, Name, Salary, DepartmentId) values (3, 'Sam', 60000, 2);
insert into employee (Id, Name, Salary, DepartmentId) values (4, 'Max', 90000, 1);
insert into employee (Id, Name, Salary, DepartmentId) values (5, 'Janet', 69000, 1);
insert into employee (Id, Name, Salary, DepartmentId) values (6, 'Randy', 85000, 1);
insert into employee (Id, Name, Salary, DepartmentId) values (7, 'Will', 70000, 1);

select *  from Department ;
insert into department (Id, Name) values (1, 'IT');
insert into department (Id, Name) values (2, 'Sales');

```



## 8.2、答案

```sql
-- 解析：最重要的是后面的  < 3 注意里面的  DISTINCT（可能出现重复的人，所以用了）
select D.Name as Department, E.Name as Employee, E.Salary
from Employee E
         join Department D on D.Id = E.DepartmentId
WHERE (
          SELECT count(DISTINCT Salary)
          from Employee A
          where A.Salary > E.Salary
            and A.DepartmentId = E.DepartmentId)
          < 3
order by Department, Salary desc;
```



# 9、求男生的平均分大于女的班级

## 9.1、题目



## 9.2、数据准备

```sql
drop table if exists student;
create table student
(
    Id        int,
    className varchar(32),
    sex       varchar(8),
    score     int
)
select * from student;


INSERT INTO student (Id, className, sex, score) VALUES (1, 'A', '男', 40);
INSERT INTO student (Id, className, sex, score) VALUES (2, 'A', '女', 36);
INSERT INTO student (Id, className, sex, score) VALUES (3, 'A', '男', 90);
INSERT INTO student (Id, className, sex, score) VALUES (4, 'A', '男', 77);
INSERT INTO student (Id, className, sex, score) VALUES (5, 'A', '女', 30);
INSERT INTO student (Id, className, sex, score) VALUES (6, 'B', '女', 35);
INSERT INTO student (Id, className, sex, score) VALUES (7, 'B', '女', 35);
INSERT INTO student (Id, className, sex, score) VALUES (8, 'C', '男', 90);
INSERT INTO student (Id, className, sex, score) VALUES (9, 'C', '女', 35);

```



## 9.2、答案

```sql
select className
from student
group by className
having avg(case sex when '男' then score end) > avg(case sex when '女' then score end);
```







# 10、求出不同班级中男生和女生的数量

## 10.1、题目



## 10.2、数据准备

```sql
drop table if exists student;
create table student
(
    Id        int,
    className varchar(32),
    sex       varchar(8),
    score     int
)
select * from student;


INSERT INTO student (Id, className, sex, score) VALUES (1, 'A', '男', 40);
INSERT INTO student (Id, className, sex, score) VALUES (2, 'A', '女', 36);
INSERT INTO student (Id, className, sex, score) VALUES (3, 'A', '男', 90);
INSERT INTO student (Id, className, sex, score) VALUES (4, 'A', '男', 77);
INSERT INTO student (Id, className, sex, score) VALUES (5, 'A', '女', 40);
INSERT INTO student (Id, className, sex, score) VALUES (6, 'B', '女', 35);
INSERT INTO student (Id, className, sex, score) VALUES (7, 'B', '女', 35);
INSERT INTO student (Id, className, sex, score) VALUES (8, 'C', '男', 90);
INSERT INTO student (Id, className, sex, score) VALUES (9, 'C', '女', 35);

```



## 10.2、答案

```sql
select className,
       sum(case when sex = '男' then 1 else 0 end) as numOfMan,
       sum(case when sex = '女' then 1 else 0 end) as numOfWoman
from student
group by className;

```





# 11、交换工资

## 11.1、题目

给定一个 salary 表，如下所示，有 m = 男性 和 f = 女性 的值。交换所有的 f 和 m 值（例如，将所有 f 值更改为 m，反之亦然）。要求只使用一个更新（Update）语句，并且没有中间的临时表。       

注意，您必只能写一个 Update 语句，请不要编写任何 Select 语句。     

**例如**

```
| id | name | sex | salary |
|----|------|-----|--------|
| 1  | A    | m   | 2500   |
| 2  | B    | f   | 1500   |
| 3  | C    | m   | 5500   |
| 4  | D    | f   | 500    |

```

运行你所编写的更新语句之后，将会得到以下表:

```
| id | name | sex | salary |
|----|------|-----|--------|
| 1  | A    | f   | 2500   |
| 2  | B    | m   | 1500   |
| 3  | C    | f   | 5500   |
| 4  | D    | m   | 500    |

```



## 11.2、数据准备

```sql
drop table if exists  salary;
create table salary(
    id int,
    name varchar(32),
    sex varchar(8),
    salary int
);
select * from salary;
INSERT INTO hlj_sql.salary (id, name, sex, salary) VALUES (1, 'A', 'm', 2500);
INSERT INTO hlj_sql.salary (id, name, sex, salary) VALUES (2, 'B', 'f', 1500);
INSERT INTO hlj_sql.salary (id, name, sex, salary) VALUES (3, 'C', 'm', 5500);
INSERT INTO hlj_sql.salary (id, name, sex, salary) VALUES (4, 'D', 'f', 500);

```



## 11.2、答案

```sql
update salary
set sex = case sex when 'f' then 'm' else 'f' end;
```



# 12、上升的温度

## 12.1、题目

给定一个 Weather 表，编写一个 SQL 查询，来查找与之前（昨天的）日期相比温度更高的所有日期的 Id。

```
+---------+------------------+------------------+
| Id(INT) | RecordDate(DATE) | Temperature(INT) |
+---------+------------------+------------------+
|       1 |       2015-01-01 |               10 |
|       2 |       2015-01-02 |               25 |
|       3 |       2015-01-03 |               20 |
|       4 |       2015-01-04 |               30 |
+---------+------------------+------------------+
```

例如，根据上述给定的 Weather 表格，返回如下 Id:

```
+----+
| Id |
+----+
|  2 |
|  4 |
+----+
```



## 12.2、数据准备

```sql
drop table if exists Weather;
create table Weather
(
    Id          int,
    RecordDate  date,
    Temperature int
);
select * from Weather;
INSERT INTO weather (Id, RecordDate, Temperature) VALUES (1, '2015-01-01', 10);
INSERT INTO weather (Id, RecordDate, Temperature) VALUES (2, '2015-01-02', 25);
INSERT INTO weather (Id, RecordDate, Temperature) VALUES (3, '2015-01-03', 20);
INSERT INTO weather (Id, RecordDate, Temperature) VALUES (4, '2015-01-04', 30);
select * from Weather;


```



## 12.2、答案

### 12.2.1、答案1

```sql
-- 解析、子查询 慢
select a.Id
from weather a
where (select b.Temperature from weather b where b.RecordDate = date_sub(a.RecordDate, INTERVAL 1 DAY))
          < a.Temperature;
```

### 12.2.1、答案2

```sql
-- 解析、关联查询 快
select a.Id
from weather a
         join weather b on b.RecordDate = date_sub(a.RecordDate, INTERVAL 1 DAY)
where a.Temperature > b.Temperature;

```



# 13、有趣的电影

## 13.1、题目

某城市开了一家新的电影院，吸引了很多人过来看电影。该电影院特别注意用户体验，专门有个 LED显示板做电影推荐，上面公布着影评和相关电影描述。

作为该电影院的信息部主管，您需要编写一个 SQL查询，找出所有影片描述为非 boring (不无聊) 的并且 id 为奇数 的影片，结果请按等级 rating 排列。       



例如，下表 cinema:

```
+---------+-----------+--------------+-----------+
|   id    | movie     |  description |  rating   |
+---------+-----------+--------------+-----------+
|   1     | War       |   great 3D   |   8.9     |
|   2     | Science   |   fiction    |   8.5     |
|   3     | irish     |   boring     |   6.2     |
|   4     | Ice song  |   Fantacy    |   8.6     |
|   5     | House card|   Interesting|   9.1     |
+---------+-----------+--------------+-----------+
```

对于上面的例子，则正确的输出是为：

```
+---------+-----------+--------------+-----------+
|   id    | movie     |  description |  rating   |
+---------+-----------+--------------+-----------+
|   5     | House card|   Interesting|   9.1     |
|   1     | War       |   great 3D   |   8.9     |
+---------+-----------+--------------+-----------+
```



## 13.2、数据准备

```sql
drop table if exists cinema;
create table cinema(
    id int,
    movie varchar(32),
    description varchar(32),
    rating decimal(2,1)
)
select * from cinema;
INSERT INTO cinema (id, movie, description, rating) VALUES (1, 'War', 'great 3D', 8.9);
INSERT INTO cinema (id, movie, description, rating) VALUES (2, 'Science', 'fiction', 8.5);
INSERT INTO cinema (id, movie, description, rating) VALUES (3, 'irish', 'boring', 6.2);
INSERT INTO cinema (id, movie, description, rating) VALUES (4, 'Ice song', 'Fantacy', 8.6);
INSERT INTO cinema (id, movie, description, rating) VALUES (5, 'House card', 'Interesting', 9.1);

```



## 13.2、答案

```sql
select id, movie, description, rating from cinema where description != 'boring' and id % 2 != 0 order by rating desc ;
```





# 14、换座位

## 14.1、题目

小美是一所中学的信息科技老师，她有一张 seat 座位表，平时用来储存学生名字和与他们相对应的座位 id。    

其中纵列的 id 是连续递增的     

小美想改变相邻俩学生的座位。    

你能不能帮她写一个 SQL query 来输出小美想要的结果呢？    

 

示例：

```
+---------+---------+
|    id   | student |
+---------+---------+
|    1    | Abbot   |
|    2    | Doris   |
|    3    | Emerson |
|    4    | Green   |
|    5    | Jeames  |
+---------+---------+
```

假如数据输入的是上表，则输出结果如下：

```
+---------+---------+
|    id   | student |
+---------+---------+
|    1    | Doris   |
|    2    | Abbot   |
|    3    | Green   |
|    4    | Emerson |
|    5    | Jeames  |
+---------+---------+
```

## 14.2、数据准备

```sql
drop table if exists seat;
create table seat (
  id int,
  student varchar(32)
);
select * from seat;
INSERT INTO seat (id, student) VALUES (1, 'Abbot');
INSERT INTO seat (id, student) VALUES (2, 'Doris');
INSERT INTO seat (id, student) VALUES (3, 'Emerson');
INSERT INTO seat (id, student) VALUES (4, 'Green');
INSERT INTO seat (id, student) VALUES (5, 'Jeames');
```



## 14.2、答案

```sql
# 解析，if判断 select if( 1 > 0 ,1 ,0 ) ; 第二个if要判断末尾是存在 a.id + 1
select a.id,
       if(a.id % 2 = 0, (select b.student from seat b where b.id = a.id - 1),
          if((select d.id from seat d where d.id = a.id + 1) is not null,
             (select c.student from seat c where c.id = a.id + 1),
             a.student)) as student
from seat a;
```



# 15、体育馆的人流量

## 15.1、题目

X 市建了一个新的体育馆，每日人流量信息被记录在这三列信息中：序号 (id)、日期 (visit_date)、 人流量 (people)。    

请编写一个查询语句，找出人流量的高峰期。高峰期时，至少连续三行记录中的人流量不少于100。    

例如，表 stadium：

```
+------+------------+-----------+
| id   | visit_date | people    |
+------+------------+-----------+
| 1    | 2017-01-01 | 10        |
| 2    | 2017-01-02 | 109       |
| 3    | 2017-01-03 | 150       |
| 4    | 2017-01-04 | 99        |
| 5    | 2017-01-05 | 145       |
| 6    | 2017-01-06 | 1455      |
| 7    | 2017-01-07 | 199       |
| 8    | 2017-01-08 | 188       |
+------+------------+-----------+
```

对于上面的示例数据，输出为：

```
+------+------------+-----------+
| id   | visit_date | people    |
+------+------------+-----------+
| 5    | 2017-01-05 | 145       |
| 6    | 2017-01-06 | 1455      |
| 7    | 2017-01-07 | 199       |
| 8    | 2017-01-08 | 188       |
+------+------------+-----------+
```

## 15.2、数据准备

```sql
drop table stadium;
create table stadium(
                        id int,
                        visit_date date,
                        people int
);
select * from stadium;
INSERT INTO stadium (id, visit_date, people) VALUES (1, '2017-01-01', 10);
INSERT INTO stadium (id, visit_date, people) VALUES (2, '2017-01-02', 109);
INSERT INTO stadium (id, visit_date, people) VALUES (3, '2017-01-03', 150);
INSERT INTO stadium (id, visit_date, people) VALUES (4, '2017-01-04', 99);
INSERT INTO stadium (id, visit_date, people) VALUES (5, '2017-01-05', 145);
INSERT INTO stadium (id, visit_date, people) VALUES (6, '2017-01-06', 1455);
INSERT INTO stadium (id, visit_date, people) VALUES (7, '2017-01-07', 199);
INSERT INTO stadium (id, visit_date, people) VALUES (8, '2017-01-08', 188);


```



## 15.2、答案

### 15.2.1、答案1

```sql
-- 解析：join方式
select * from
(select a.*
-- t1 t2 t3
 from stadium a
          join stadium b on b.id = a.id + 1
          join stadium c on c.id = a.id + 2 where a.people >= 100 and b.people >= 100 and c.people >= 100
 union
-- t2 t1 t3
 select a.*
 from stadium a
          join stadium b on b.id = a.id - 1
          join stadium c on c.id = a.id + 1 where a.people >= 100 and b.people >= 100 and c.people >= 100
 union
-- t2 t3 t1
 select a.*
 from stadium a
          join stadium b on b.id = a.id - 2
          join stadium c on c.id = a.id - 1 where a.people >= 100 and b.people >= 100 and c.people >= 100) m
order by id
;

```

### 15.2.2、答案2

```sql
-- 解析：多个表同时查询方式
select distinct t1.*
from stadium t1
where t1.people >= 100
;

select distinct t1.*
from stadium t1,
     stadium t2,
     stadium t3
where t1.people >= 100
  and t2.people >= 100
  and t3.people >= 100
;



select distinct t1.*
from stadium t1,
     stadium t2,
     stadium t3
where t1.people >= 100
  and t2.people >= 100
  and t3.people >= 100
  and (
        (t1.id + 1 = t2.id and t2.id + 1 = t3.id)    -- t1 t2 t3
        or (t1.id - 1 = t2.id and t2.id + 2 = t3.id) -- t2 t1 t3
        or (t1.id - 2 = t2.id and t2.id + 1 = t3.id) -- t2 t3 t1
    ) order by id
;
```



# 16、超过5名学生的课

## 16.1、题目

有一个courses 表 ，有: student (学生) 和 class (课程)。    

请列出所有超过或等于5名学生的课。    

例如,表:

```
+---------+------------+
| student | class      |
+---------+------------+
| A       | Math       |
| B       | English    |
| C       | Math       |
| D       | Biology    |
| E       | Math       |
| F       | Computer   |
| G       | Math       |
| H       | Math       |
| I       | Math       |
+---------+------------+
```

应该输出:

```
+---------+
| class   |
+---------+
| Math    |
+---------+
```

Note:
学生在每个课中不应被重复计算。



## 16.2、数据准备

```sql
drop table if exists courses;
create table courses (
    student varchar(32),
    class varchar(32)
);
select * from courses;
insert into courses(student, class) values ('A', 'Math');
insert into courses(student, class) values ('B', 'English');
insert into courses(student, class) values ('C', 'Math');
insert into courses(student, class) values ('D', 'Biology');
insert into courses(student, class) values ('E', 'Math');
insert into courses(student, class) values ('F', 'Computer');
insert into courses(student, class) values ('G', 'Math');
insert into courses(student, class) values ('H', 'Math');
insert into courses(student, class) values ('I', 'Math');

```



## 16.3、答案

```sql
-- 解析，可能会有重复的  student 所以使用了 distinct
select class from courses group by class having count(distinct student) >= 5 ;
```



# 、

## .1、题目



## .2、数据准备

```sql

```



## .2、答案

```sql

```









![ContactAuthor](https://raw.githubusercontent.com/HealerJean/HealerJean.github.io/master/assets/img/artical_bottom.jpg)





<link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">

<script src="https://unpkg.com/gitalk@latest/dist/gitalk.min.js"></script> 
<div id="gitalk-container"></div>    
 <script type="text/javascript">
    var gitalk = new Gitalk({
		clientID: `1d164cd85549874d0e3a`,
		clientSecret: `527c3d223d1e6608953e835b547061037d140355`,
		repo: `HealerJean.github.io`,
		owner: 'HealerJean',
		admin: ['HealerJean'],
		id: '5fKrQTO7aNm6Mjbd',
    });
    gitalk.render('gitalk-container');
</script> 

