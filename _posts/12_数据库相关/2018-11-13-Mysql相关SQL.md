---
title:: mysql项目相关sql大全
date: 2018-12-17 03:33:00
tags: 
- Database
category: 
- Database
description: Mysql项目相关sql大全_终身受用

---





<!-- image url 
https://raw.githubusercontent.com/HealerJean/HealerJean.github.io/master/blogImages
　　首行缩进
<font color="red">  </font>

<font  color="red" size="4">   </font>

<font size="4">   </font>
-->



## 1、Mybatis和Hibernate


### 1.1、获取结果为`list<map<String,Object>>`

#### 1.1.1、mybatis 

##### 解释  

>1、返回类型必须是java.util.HashMap
>
>2、map中的value 必须是Objecrt

****



#####  1.1.1.1、mapper接口**


```java

public interface HealerJeanMapper {
     List<Map<String,Object>> sqlMap();
}
```


#####  1.1.1.2、mapper.xml


```xml
<select id="sqlMap" resultType="java.util.HashMap">
  SELECT h.id as id ,h.subject as subject FROM  healerjean  h;
</select>
```

#####  1.1.1.3、controller测试

```java

@RequestMapping("sqlMap")
@ResponseBody
public List<Map<String,Object>> sqlMap(){
    return healerJeanMapper.sqlMap();
}
```

![](https://raw.githubusercontent.com/HealerJean/HealerJean.github.io/master/blogImages/WEFASDFUMM.png)

#### 1.1.2、Jpa分组制作



+ **1、mapper.xml**

```java
@Query(value = "select new map(g.department as department,count(*) as count) from GraduateDestination g  group by g.department")
 List<Map<String,Object>> getAcademyEmplo(String graduateDate);

```



+ **2、使用**

```java
 Map<String ,Integer> academyEmploMap=new HashMap<>();
 List<Map<String,Object>> list = destinationRepostiory.getAcademyEmplo(graduateDate);
 for(Map<String,Object> map:list){
	String key =  map.get("department").toString() ;
    String value = Integer.parseInt(map.get("count").toString()) ;
    emploMap.put(key,value);
 }
```





### 1.2、`resultMap`作为Mybatis返回类型 



#### 解释 

>1、`property` 实体类中的属性名         
>
>2、`column`默认是数据表的列名，或者比如 



#### 1.2.1、mapper.xml 

```xml
<select id="select" parameterType="Query" resultMap="BaseResultMap">
    select *   from scf_contract
</select>

<select id="select" parameterType="Query" resultMap="BaseResultMap">
    select c.id as user_id   from scf_contract c
</select>
```

#### 1.2.2、**resultMap**


```xml

  <resultMap id="BaseResultMap" type="com.taotao.pojo.TbUser" >
    <id column="user_id" property="id" jdbcType="BIGINT" />
    <result column="username" property="username" jdbcType="VARCHAR" />
    <result column="password" property="password" jdbcType="VARCHAR" />
    <result column="phone" property="phone" jdbcType="VARCHAR" />
    <result column="email" property="email" jdbcType="VARCHAR" />
    <result column="created" property="created" jdbcType="TIMESTAMP" />
    <result column="updated" property="updated" jdbcType="TIMESTAMP" />
  </resultMap>

```


### 1.3、`If`标签的使用



```xml

<select id="findCustomerList" resultType="com.entity.db.customer.Customer">
    SELECT t.* from crm_customer t
    WHERE t.isVisiblisVisiblee = 1
    <if test="name != null and name != ''">
        and t.name like CONCAT('%','${name}','%' )
    </if>
    <if test="status != null">
        and t.status = #{status}
    </if>
</select>

```



### 1.4、where标签和trim的使用

#### 解释 

>**1、where标签会使sql语句自动加上where** 
>
>**2、 trim标签内sql语句 ,去除 ”前“，”后“ 内容、加前后缀**
>
>- **suffixOverrides= “,” 去除多余的后缀 '，'**
>- **prefixOverrides="and" 去除多余的前缀 'and '**
>- **prefix="("    加前缀 **  
>- **suffix=")"   加后缀 **



```xml
<select id="selectByExample" parameterType="ScfContractQuery" resultMap="BaseResultMap">
    select
    <trim suffixOverrides=",">
        <include refid="Base_Column_List" />
    </trim>
    from scf_contract
    <include refid="Example_Where_Clause" />
</select>



<sql id="Example_Where_Clause">
    <where>
        <trim prefix="(" prefixOverrides="and" suffix=")">
            <if test="refSysFileId != null and refSysFileId != ''">
                and ref_sys_file_id = #{refSysFileId,jdbcType=VARCHAR}
            </if>
        </trim>
    </where>
</sql>

```



### 1.5、foreach标签 的使用



```xml
<if test="statusList != null and statusList.size() > 0">
    and status in
    <foreach collection="list" index="index" item="item" 
             open="(" separator="," close=")">
        #{item}
    </foreach>
</if>
```



### 1.6、choose when 标签 (相当于if else)的使用



```xml
<choose>
    <when test="flag == 1">
        and t.status = 0
    </when>
    <when test="flag == 2">
        and t.status = 1
    </when>
    <when test="flag == 3">
        and t.expressStatus = 1
    </when>
    <when test="flag == 4">
        and t.status = -2
    </when>
    <otherwise>
    </otherwise>
</choose>
```



### 1.7、制作参数map值在mybatis的mapper.xml使用 



#### 1.7.1、controller接收参数 



```java
@RequestMapping("data")
@ResponseBody
public ResponseBean data(String name,
					  Integer type,
					  Integer status,
                      @RequestParam(value = "page",defaultValue = "0") Integer page){
  
        int pageSize = 15;
        Pageable pageable = new PageRequest(page,pageSize);
        Page<AppInfoData> dataPage = skinsService.findList(pageable,
                                                           "name",name,
                                                           "type",type,
                                                           "status",status);
        return ResponseBean.buildSuccess(dataPage);
}
```

####  1.7.2、service 制作map参数    



>pageable 主要是利用里面的参数制作limit参数的



```java
@Override
public Page<AppInfoData> findList(Pageable pageable, Object... param)  {

    Map data = MyBatisHelper.mergeParameterMap(pageable,param);
    if(data.get("startDate") != null){
        Date startDate = (Date) data.get("startDate");
        data.put("startDate", .DateHelper.getDateFirstTime(startDate));
    }
    if(data.get("endDate") != null){
        Date endDate = (Date) data.get("endDate");
        data.put("endDate",DateHelper.getDateLastTime(endDate));
    }

    List<SkinAppInfoData> dataList = skinsMapper.findSkinList(data);
    Long count = skinsMapper.countSkinList(data);
    return new PageImpl<SkinAppInfoData>(dataList,pageable,count);
}
```



####  1.7.3、MyBatisHelper工具类



```java
public class MyBatisHelper {
    public static final String PARAM_OFFSET = "offset";
    public static final String PARAM_LIMIT = "limit";

    public MyBatisHelper() {
    }

    public static Map<String, Object> mergeParameterMap(Object... parameter) {
        if (parameter.length % 2 != 0) {
            throw new IllegalArgumentException("parameter须为key-value对应参数");
        } else {
            Map<String, Object> map = new HashMap();

            for(int i = 0; i < parameter.length; i += 2) {
                map.put(parameter[i].toString(), parameter[i + 1]);
            }

            return map;
        }
    }

    public static Map<String, Object> mergeParameterMap(Pageable pageable, Object... parameter) {
        if (parameter.length % 2 != 0) {
            throw new IllegalArgumentException("parameter须为key-value对应参数");
        } else {
            Map<String, Object> map = new HashMap();
            map.put("offset", pageable.getOffset());
            map.put("limit", pageable.getPageSize());

            for(int i = 0; i < parameter.length; i += 2) {
                map.put(parameter[i].toString(), parameter[i + 1]);
            }

            return map;
        }
    }
}
```




####  1.7.4、mapper接口



```java
public interface SkinsMapper {

    public List<SkinAppInfoData> findSkinList(Map param);

}
```


####  1.7.5、mapper.xml


```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd" >
<mapper namespace="com.duodian.admore.dao.db.skins.SkinsMapper">

    <select id="findSkinList" resultType="com.duodian.admore.data.skins.SkinAppInfoData">
        SELECT
            A1.`appid`,
            A1.`appSecret`,
            A1.`icon`,
            A1.`makerMemo`,
            A1.`haveBackstage`,
            A1.`channelJson`,
            A1.`filePath`
        FROM  `skin_app_info_check`  a1
        where A1.status not in (9)
        <if test="name != null and name != ''">
            AND (A1.trackId = #{name}
            OR A1.name LIKE CONCAT('%',#{name},'%' )
            OR A1.appid LIKE CONCAT('%',#{name},'%' )
            OR A1.appSecret LIKE CONCAT('%',#{name},'%' )
            )
        </if>
        <if test="type != null and type != '' ">
            and A1.type = #{type}
        </if>
        <if test="status != null and status != '' ">
            and  A1.status = #{status}
        </if>
        order by A1.cdate desc
        <if test="offset != null and limit != null">
            limit #{offset}, #{limit}
        </if>
    </select>

</mapper>

```



### 1.8、query对象作为参数传入  

#### 1.8.1、query对象  

```java
public class SysUserQuery implements Serializable {

    private static final long serialVersionUID = 1L;

    private Long id;
    private Integer offset;
    private Integer limit;
    private Date startDate;
    private Date endDate ;
    private String userid;
    private String userParam;
    private Integer status;

}


```

#### 1.8.2、controller层

```java
@RequestMapping("data")
@ResponseBody
public ResponseBean data(@RequestParam(defaultValue = "0")Integer page, 
                         @RequestParam(defaultValue = "15")Integer pageSize, 
                         SysUserQuery query){

        Pageable pageable = new PageRequest(page,pageSize);
        return ResponseBean.buildSuccess(sysDingUserService.getData(pageable,query));
}
```



#### 1.8.3、service层，将pageable分页对象放入



```java
 @Override
    public Page<SysDingUser> getDingUserData(Pageable pageable, SysUserQuery query) {

        query.setOffset(pageable.getOffset());
        query.setLimit(pageable.getPageSize());

        List<SysDingUser> list = sysMapper.findSysDingUserList(query);
        Long count = sysMapper.countSysDingUser(query);
        return new PageImpl<>(list, pageable, count);
    }
}

```





### 1.9、resultType 返回对象

#### 解释 

>1、对于数据库字段匹配的，可以直接选择   
>
>2、对于不匹配的使用 as  转化

### 

```xml
<select id="findRedStartSpread" 
        parameterType="com.duodian.RedStartSpreadQuery" 
        resultType="com.duodian.RedStartHistoryBean">
    select
    k.trackId,
    e.smallIcon,
    e.formattedPrice,
    e.price,
    e.fileSizeBytes,
    e.trackName,
    f.name admName,
    a.nickName userName,

    DATE_FORMAT(k.spreadDateStart, '%Y-%m-%d') AS ymd,
    k.userId
    FROM
    redstart_spread k
```



### 1.10、不使用注解@Param 只有一个参数传入   

#### 解释 

> 使用了@Param正常情况下，直接写参数名字，也可以直接传入数据，但是只有一个参数传入的时候，,不能直接写参数名字了 而是使用下面的_parameter 



##### 1.10.1、mapepr接口

```java
List<CustomerChance> getCustomerList(Long adminId);

```

##### 1.10.2、mapper.xml

```xml
<select id="getCustomerList" resultType="com.duodian.db.CustomerChance">
    select *
    from `crm_customer_chance`  c
    where c.isVisible = 1
    <if test="_parameter != null">
        and c.adminId = #{_parameter}
    </if>
</select>

```





### 1.11、原生符号 

##### 解释 



>被<![CDATA[]]>这个标记所包含的内容将表示为纯文本，比如<![CDATA[<]]>表示文本内容“<”。        
>
>此标记用于xml文档中，我们先来看看使用转义符的情况。我们知道，在xml中，”<”、”>”、”&”等字符是不能直接存入的，否则xml语法检查时会报错，如果想在xml中使用这些符号，必须将其转义为实体，如”&lt;”、”&gt;”、”&amp;”，这样才能保存进xml文档。 



##### 1.11.1　　举例说明 



<font  color="red" size="4">但是经过我测试，在mybaits执行的时候，没有使用 <![CDATA[>]]>  直接 >=也没有提示报错
  </font> 

```xml
 where rownum <![CDATA[<=]]> #{end,jdbcType=INTEGER} ) 
```



### 1.12、一个条件参数匹配多个 字段 

```xml
<if test="userParam != null and userParam != ''">
    AND (t.userId = #{userParam}
          OR a.nickName LIKE CONCAT('%',#{userParam},'%' )
          OR b.realName LIKE CONCAT('%',#{userParam},'%' )
          OR c.realName LIKE CONCAT('%',#{userParam},'%' )
          OR t.customerId LIKE CONCAT('%',#{userParam},'%' )
          OR t.customerName LIKE CONCAT('%',#{userParam},'%'))
</if>

```



### 1.13、多条件排序

##### 1.13.1、正确的多条件排序，排序字段由前端进行传入`${order}`

```xml
    <if  test="order != null">
        order by  ${order}
    </if>
 
```



##### 1.13.2、chose where进行判断 

举例：订单降序 1，订单升序 2 ，成交额降序 3，成交额升序 4，  



```xml
<select id="findCouponTaoKeDataByParam" resultType="com.duodian.youhui.data.coupon.CouponTaoKeItemGoodSummaryData">
  SELECT c.itemTitle,
    COUNT(c.itemId) as orderSize,
    sum(c.estimateAmount) AS sumEstimateAmount ,
    c.adzoneName,c.adzonePid,
    c.createTime,c.itemId  
    FROM  coupon_taoke_data c
    <where>
        c.dataType = 1 and  c.status = 1
        <include refid="findCouponTaoKeDataByParamSQL"></include>
    </where>
    GROUP by c.itemId,c.adzonePid
    <if test="order != null">
        <choose>
            <when test="order == 1">
                order by    orderSize DESC
            </when>
            <when test="order == 2">
                order by    orderSize asc
            </when>
            <when test="order == 3">
                order by   sumEstimateAmount DESC
            </when>
            <when test="order == 4">
                order by   sumEstimateAmount asc
            </when>
        </choose>
    </if>
    <if test="offset != null and limit != ''">
        limit #{offset}, #{limit}
    </if>
</select>

```



##### 1.13.3、给排序添加非空条件

>  使用order by orderid desc实现降序时    ,orderid 为null数据的会排在数据的最后面；       
>
> 但是，order by orderid升序时，orderid 为null的数据则会排在最前面   ，如果想要将orderid为null的数据排在最后，就需要加上is null



```sql
select * from b_programme u order by u.orderid is null
```



##### 1.13.4、自定义排序规则

```sql
order by  field (c.status,'Ready','Part','Completed','Close')
```



### 1.14 、参数为0，判断null



> **id传值为0时(前提是id对应的类型为long 或者 Integer，String型无此问题)**，发现并没有执行if里的sql，因为在**mybatis中会自动把0当成‘’空字符串**，





**使用时增加多一个or status == 0判断**

```xml
<if test="status != null and status !=  '' or status == 0">

```



### 1.15、 #和$项目中使用的区别  


##### 1.15.1、解释 



> {变量名} 可以进行预编译、类型匹配等操作，#{变量名}会转化为jdbc的类型   
> ${变量名} 不进行数据类型匹配，直接替换。

```sql
select * from tablename where id = #{id}


假设id的值为12  
如果id为字符型，那么#{id}表示的就是'12'  
如果id为整型，  那么#{id}表示的就是12 

```



```

select * from tablename where id = ${id}  

如果字段id为整型，sql语句就不会出错，但是如果字段id为字符型， 那么sql语句应该写成select * from table where id = '${id}'。
```



##### 1.15.2、使用 

+ #方式能够很大程度防止sql注入。因为#会自动转换，而&为直接替换,所以$方式无法防止sql注入

+  项目中的使用，尽量使用# ，少用& 臭小子，明白了吧 



`#`适用于普通的参数传入

`$`方式一般用于传入数据库对象，例如传入表名。



```xml
order为 A ASC, A DESC ,B DESC ，B asc数据，这里直接使用#是错误的

 <when  test="order != null">
          order by  ${order}
</when>
```



### 总结：mytabis常见错误 



#### 1、mybatis日期报错

##### 异常：`invalid comparison: java.util.Date and java.lang.String。`

```xml
<if test="date!= null and date !=''">
date为Date类型，不能和‘’比较，只判断是不是null就行啦:

<if test="date!= null">

```






## 2、函数 



### 2.1、ifnull （如果为空返回第二个，如果不空返回第一个） 



```sql
ifnull(b.realName,c.realName) authName,
```



### 2.2、count



#### 2.2.1、count（*） 

##### 2.2.1.1、count（*）本来代表的就是一个数字，本身就是一行，下面这个只会输出一行 


```sql
SELECT  count(*) as "count",idfa from apps_click_record a; 
```



##### 2.2.1.2、和group分组一起使用  ，就表示分组之后每组的个数


```sql
SELECT  count(*) as "count",idfa 
from apps_click_record a 
WHERE  a.keywordId = '169995' 
GROUP  by idfa 
ORDER BY count(*) DESC ;
    
```

##### 2.2.1.3、count（*） 和 * 的查询 是错误的 


```sql
下面是错误的

SELECT  count(*) as "count",* from apps_click_record a; 

```



##### 2.2.1.4、查找数group by分组后的个数，使用嵌套，


```sql
select count(*) from 
(
    select b.type from B b group by b.type
) m


正确写法应该是 
select count(distinct b.type) from B b
```



##### 2.2.1.5、count(distinct Sname)去掉重复得到唯一的数量 

```
select count(distinct b.type) from B b
```



### 2.3、delete删除的正确方法 




```xml
1,delete from user as u where u.userid=6; 错误

2,delete from user u where u.userid=6; 错误

3,delete from user where userid=6;  正确

4,delete u.* from user u where u.userid=6; 正确

5,delete u from user u where u.userid=6; 正确 

```





### 2.4、group_concat：语句将某一列的值查询成逗号分隔的字符串



```sql
select GROUP_CONCAT(c.id) from coupon_item_good;

返回结果
1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,22,23,24,25,26,27,28,29,30,31,32,33
```





### 2.5、find_in_set  查询字段为逗号隔开的字段属性 



**字段 pnum为逗号隔开的字符串** 



```sql
1,2,3,4,21,9

select * from test  t where find_in_set(2,t.pnum) ;
```



### 2.6、随机查询 

#### 26.1 、rand() 性能比较差 



>  **RAND()  函数返回的是一个小于1的随机数**　　



```sql
BY RAND() LIMIT 1

```

```xml
<select id="getUrl" resultType="java.lang.String">
        SELECT c.url FROM coupon_item_good  5 order by rand() limit 1
</select>
```


#### 24.2、round() 进行优化

```sql
SELECT round(column_name,decimals) FROM table_name
```


|参数|描述|
|----|----|----|----|
|column_name|必需。要舍入的字段|
|decimals|非必需，规定返回的小数位数，如果不给值，则自动四舍五入取整取整，select round(100.9) ;  101|




```sql

随机选择一个id，然后选择一个大于他的数据，limit控制为1
随机选择一个推广位，具体条件就是下面and中连接的and t1.status 开始

<select id="findUserCouponAdzone" resultType="com.duodian.coupon.CouponAdzone">

        SELECT *
        FROM `coupon_adzone` AS t1
        JOIN (SELECT ROUND(RAND() * (SELECT MAX(id)
                                       FROM `coupon_adzone`)
              ) AS id) AS t2
        WHERE t1.id >= t2.id 
        and t1.status = 1 
        AND  t1.adzoneType = 3  
        and 
        ORDER BY t1.id ASC
        LIMIT 1;
</select>
```



### 2.7、case when  （试着和if进行替换使用）

#### 2.7.1、普通使用

```sql
 case cp.ssid when 'aa' 
 				then '0' 
 				else'1' 
 			 end as flag 
```



#### 2.7.2、复杂条件 

> 以下场景 我们要扣减金额 operateMoney ，并且要求分配额度和临时额度扣减完成必须大于 0 
> 字段说明：
> 分配额度 allot_amount
> 临时额度 temp_amount
> 总额度   total_amount 
>
> 
>
> 总额度直接减去total_amount 
> 判断临时额度是否 大于等于 扣减的额度，
> 		如果大于，那么直接扣减临时额度，分配额度不变
> 		如果小于，则是先扣减临时额度，然后再扣减分配额度
> 使用主键进行更新，只锁一行，当id和 当分配额度和临时额度扣减后是否大于0 成立的时候更新



```sql

update scf_risk_department_limit set
total_amount = total_amount -  #{operateMoney,jdbcType=DECIMAL},
available_amount = available_amount -  #{operateMoney,jdbcType=DECIMAL},
allot_amount = ( 
    case when   temp_amount  >=   #{operateMoney,jdbcType=DECIMAL} 
    then allot_amount   
          else allot_amount -  (  #{operateMoney,jdbcType=DECIMAL} - temp_amount )    
     end ),
temp_amount =  ( 
    case when  temp_amount  >=  #{operateMoney,jdbcType=DECIMAL}  
   	     then temp_amount -  #{operateMoney,jdbcType=DECIMAL}  
         else  0 
    end )
where id =  #{id,jdbcType=BIGINT} 
       and (allot_amount + temp_amount ) >  #{operateMoney,jdbcType=DECIMAL}

```



#### 2.7.3、case 中 when和and一起使用



```sql
update driver_online 
set vRemainCapacity =  case when (vRemainCapacity>0) and ((vRemainCapacity-0.5) >0) 
then vRemainCapacity-0.5  
else 0 end  
where driverId = 'DR120161118100001'； 
```



#### 2.7.4、case when 多个条件

```sql
update goods
set price = (
case 
  when price between 0 and 99 then price * 1.2
  when price between 100 and 999 then price * 1.1
  when price between 1000 and 1999 then price * 1.05
  when price > 1999 
  then price * 1.02
end);
select * from goods;
```



#### 2.7.5、case的目标 中添加函数

```sql
select substr(t1.area_id, 1, 1) type,
       substr(t1.area_id, 2) id,
       case substr(t1.area_id, 1, 1)
         when 'c' then
          (select t2.country
             from countnumber.dbtable_countryid t2
            where t2.id = substr(t1.area_id, 2))
         else
          (select distinct t3.province
             from countnumber.dbtable_provinceid t3
            where t3.id = substr(t1.area_id, 2))
       end name
  from t_ad_area t1

```



### 2.8、If 函数使用



```sql
select if( 1 > 0 ,1 ,0 ) ;

IF(expr1,expr2,expr3)

 expr1 是TRUE  返回 expr2 否则返回 expr3
```







### 2.9、mysql除法、加法

####  2.9.1、除法



>  **余数可以为0，得到的结果为NUll**   



```java
SELECT 1/0 from dual ;
```

![WX20181212-160341](https://raw.githubusercontent.com/HealerJean/HealerJean.github.io/master/blogImages/WX20181212-160341.png)

#### 2.9.2、加法  

> **如果有的参数是null，则可以让参数带上ifNULL，防止null+size造成的数据时null，不显示**

```sql
select  o.payAmount,
          o.estimateAmount,
         (o3.notValidOrderSize +o.orderSize) as orderSize
from user_info u
        

(IFNULL(o3.notValidOrderSize ,0 ) + IFNULL(o.orderSize ,0 ) ) as orderSize        
```




### 2.10、mysql 取小数 convert   round  cast



#### 2.10.1、convert

```sql

select convert(10000,decimal(10,2));

# 四舍五入，decimal(10,2)后面的代表最大长度10以及保留的小数位数2
select convert(10569.3645,decimal(10,2));    #10569.36
select convert(10569.3665555,decimal(10,2)); #10569.37
```



#### 2.10.2、round

> round 第二个表示小数保留几位，不足的补上0。   

```sql
第二个如果为负数  
-1   代表个位数为0     		ROUND(114.6,-1) 结果 110，  
-2   代表个位数和十分位 为0     ROUND(114.6,-2) 结果  100


ROUND(100.3465,2)  100.35
ROUND(100,2),  	100 
ROUND(0.6,2),	0.60
ROUND(114.6,-1)   110
```



#### 2.10.3、cast函数：强制转换



```sql
select cast(10*1/4 as decimal(18,2)) from dual
```



### 2.11、abs函数取绝对值

> **有时候项目中出现两个数字相减，可能是负数，但是只是需要这连个数的差值，所以就需要用它**

```sql
ABS( TIMESTAMPDIFF(MINUTE,i.cdate,#{createTime}) ))< #{adzoneTime})
```



### 2.12、isnull、length 函数：判断是否为null或空字符串

```sql
isnull(aBegBalRule) || length (trim(aBegBalRule))<1
```



### 2.13、清表（不要用delete）

> delete删除之后还会占用id，

```java
truncate  table_name ; 
```





### 2.14、拼接字符串    

#### 2.14.1、concat：普通拼接

> 如果有一个参数为null，则返回结果为null



```sql
SELECT CONCAT(’My’, NULL, ‘QL’);

NULL 
```



#### 2.14.2、concat_ws，分隔符连接字符串

> **第一个参数是其它参数的分隔符。分隔符的位置放在要连接的两个字符串之间。分隔符可以是一个字符串，也可以是其它参数。**

+ 如果分隔符为 NULL，则结果为 NULL 
+ **函数会忽略任何分隔符参数后的 NULL 值。**



```sql
SELECT CONCAT_WS(',','First name','Second name','Last Name');

First name,Second name,Last Name
```



```sql
SELECT CONCAT_WS(',','First name','','Last Name');

First name,,Last Name (空字符串不会忽略)
```



```sql
SELECT CONCAT_WS(',','First name',null ,'Last Name');

First name,Last Name
```





#### 2.14.3、使用

> 模糊查询使用`concat('%',#{params},'%'))`

```xml
<if test="params != null and params != ''">
   u.nickName like  concat('%',#{params},'%')
</if>             
```





### 2.15、locate： 出现的index位置 

```sql
SELECT LOCATE('bar', 'foobarbar'); #4

SELECT LOCATE('xbar', 'foobarbar'); #0

位置从4开始数起 
SELECT LOCATE('bar', 'foobarbar',4); # 4
```

项目使用

```sql
查找具有http字段的用户

select * from users where locate('http',itemUrl);


判断site表中的url是否包含'http://'子串,如果不包含则拼接在url字符串开头
update site set url =concat('http://',url) where locate('http://',url)=0;
```







### 2.16、like 匹配

#### 2.16.1、_：表示任意单个字符。匹配单个任意字符

![15515944787068](https://raw.githubusercontent.com/HealerJean/HealerJean.github.io/master/blogImages/15515944787068.png)

#### 2.16.2、[charlist] ：只要在里面存在就匹配

![155159444025](https://raw.githubusercontent.com/HealerJean/HealerJean.github.io/master/blogImages/155159444025.png)





### 2.17、日期的一些函数使用



#### 2.17.1、date_format   、str_to_date



> date类型默认的时分秒 为00:00:00  

#####  准备数据

```sql
create table date_test(
  id bigint(20) not null auto_increment ,
  name varchar(20) default  '',
  yyyyMMdd date  default null ,
  yyyyMMddHHmmss datetime default  null ,
  primary key (id)
)

INSERT INTO date_test (id, name, yyyyMMdd, yyyyMMddHHmmss) VALUES (1, 'healerjean', '2018-12-12', '2018-12-12 23:11:11');
```



##### 1、date_format    



```sql

# yyyyMMddHHmmss 存储数据为  2018-12-12 23:11:11
select * from date_test d where date_format(d.yyyyMMddHHmmss,"%Y-%m-%d") = '2018-12-12';
select * from date_test d where date_format(d.yyyyMMddHHmmss,"%Y-%m-%d %H:%i:%s") = '2018-12-12 23:11:11';


# yyyyMMdd 存储的为 2018-12-12
select * from date_test d where date_format(d.yyyyMMdd,"%Y-%m-%d") = '2018-12-12';
select * from date_test d where date_format(d.yyyyMMdd, "%Y-%m-%d %H:%i:%s") = '2018-12-12 00:00:00';

```



##### 2、str_to_date

```sql
select str_to_date('08/09/2008', '%m/%d/%Y'); -- 2008-08-09
select str_to_date('08/09/08' , '%m/%d/%y'); -- 2008-08-09
select str_to_date('08.09.2008', '%m.%d.%Y'); -- 2008-08-09
select str_to_date('08:09:30', '%h:%i:%s'); -- 08:09:30
select str_to_date('08.09.2008 08:09:30', '%m.%d.%Y %h:%i:%s'); -- 2008-08-09 08:09:30



#注意哦，下面这种我们匹配数据库中一定存在的，不可以类似于format那样模糊查询，因为条件是我们字数输入的
select * from date_test d where d.yyyyMMdd = STR_TO_DATE('2018-12-12','%Y-%m-%d') ;
select * from date_test d where d.yyyyMMdd = STR_TO_DATE('2018-12-12 00:00:00','%Y-%m-%d %H:%i:%s') ;


select * from date_test d where (d.yyyyMMdd) = '2018-12-12'; 
# 下面这个找不到数据，说明date类型默认的时分秒 为00:00:00
select * from date_test d where date_format(d.yyyyMMdd, "%Y-%m-%d %H:%i:%s") = '2018-12-12 11:00:00';
```







#### 2.17.2、timestampdiff ：选择大于或小于某个时间段的数据





| 单位   | 说明 |
| ------ | ---- |
| SECOND | 秒   |
| MINUTE | 分钟 |
| HOUR   | 小时 |
| DAY    | 天   |
| MONTH  | 月   |
| YEAR   | 年   |



 ##### 2.17.2.1、计算日期差 

```sql
计算日期差，不要使用now（）而是使用 curdate() ;
TIMESTAMPDIFF(DAY, curdate(),cb.bill_end_time) as warning_day,
```



##### 2.17.2.2、计算小时差

```xml
获取48小时之内的数据

<select id="find48Hours"  resultType="com.duodian.OnlineChatPerson">
	SELECT  * from  call_online_chat_person c
    WHERE timestampdiff(HOUR,c.cdate,now())  < 48 
</select>
```



#### 2.17.3、unix_timestamp：获取日期的时间戳

```sql
unix_timestamp(),
unix_timestamp(date),
from_unixtime(unix_timestamp),
from_unixtime(unix_timestamp,format)

select unix_timestamp(); -- 1218290027
select unix_timestamp('2008-08-08'); -- 1218124800
select unix_timestamp('2008-08-08 12:30:00'); -- 1218169800


SELECT  unix_timestamp(u.date) from user_info u;

1528427765000 毫秒

```



#### 2.17.4、from_unixtime ： 时间戳转化为日期（时间戳为毫秒）

```sql
select from_unixtime(1218290027); -- '2008-08-09 21:53:47'
select from_unixtime(1218169800, '%Y %D %M %h:%i:%s %x'); -- '2008 8th August 12:30:00 2008'


SELECT from_unixtime(1500109248, '%Y-%m-%d %H:%i:%S');
2017-07-15 17:00:48
```



#### 2.17.5、date_add 、date_sub日期加法计算

```sql
date_add(date,INTERVAL expr type)
date_sub(date,INTERVAL expr type)
```



```sql

"OrderDate" 添加 2 天

SELECT 
OrderId,
date_add(OrderDate,INTERVAL 2 DAY) AS OrderPayDate
FROM Orders


MICROSECOND
SECOND
MINUTE
HOUR
DAY
WEEK
MONTH
QUARTER
YEAR
SECOND_MICROSECOND
MINUTE_MICROSECOND
MINUTE_SECOND
HOUR_MICROSECOND
HOUR_SECOND
HOUR_MINUTE
DAY_MICROSECOND
DAY_SECOND
DAY_MINUTE
DAY_HOUR
YEAR_MONTH
```





#### 2.17.6、 to_days(date), from_days(days)  ：（日期、天数（互转））

```sql
select to_days('0000-00-00'); -- 0
select to_days('2008-08-08'); -- 733627

```



#### 2.17.7、time_to_sec(time), sec_to_time(seconds)  （时间、秒（互转）） 

```sql
select time_to_sec('01:00:05'); -- 3605
select sec_to_time(3605); -- '01:00:05'

```



#### 2.17.8、 makdedate(year,dayofyear), maketime(hour,minute,second)  （拼凑日期、时间函数：）

```sql
select makedate(2001,31); -- '2001-01-31'
select makedate(2001,32); -- '2001-02-01'
select maketime(12,15,30); -- '12:15:30'
```





#### 2.17.9、查询一些特定日期



```sql
今天  
select * from 表名 where to_days(时间字段名) = to_days(now());  

昨天  
SELECT * FROM 表名 WHERE TO_DAYS( NOW( ) ) - TO_DAYS( 时间字段名) <= 1  

7天  
SELECT * FROM 表名 where DATE_SUB(CURDATE(), INTERVAL 7 DAY) <= date(时间字段名)  

近30天  
SELECT * FROM 表名 where DATE_SUB(CURDATE(), INTERVAL 30 DAY) <= date(时间字段名)  

本月  
SELECT * FROM 表名 WHERE DATE_FORMAT( 时间字段名, '%Y%m' ) = DATE_FORMAT( CURDATE( ) , '%Y%m' )  

上一月  
SELECT * FROM 表名 WHERE PERIOD_DIFF( date_format( now( ) , '%Y%m' ) , date_format( 时间字段名, '%Y%m' ) ) =1  

#查询本季度数据  
select * from `ht_invoice_information` where quarter(create_date)=quarter(now());  

#查询上季度数据  
select * from `ht_invoice_information` where QUARTER(create_date)=QUARTER(DATE_SUB(now(),interval 1 QUARTER));  

#查询本年数据  
select * from `ht_invoice_information` where YEAR(create_date)=YEAR(NOW());  

#查询上年数据  
select * from `ht_invoice_information` where year(create_date)=year(date_sub(now(),interval 1 year));  

查询当前这周的数据   
SELECT name,submittime FROM enterprise WHERE YEARWEEK(date_format(submittime,'%Y-%m-%d')) 
= YEARWEEK(now());  

查询上周的数据  
SELECT name,submittime FROM enterprise WHERE YEARWEEK(date_format(submittime,'%Y-%m-%d')) = YEARWEEK(now())-1;  

查询当前月份的数据  
select name,submittime from enterprise   where date_format(submittime,'%Y-%m')=date_format(now(),'%Y-%m')  

查询距离当前现在6个月的数据  
select name,submittime from enterprise where submittime between date_sub(now(),interval 6 month) and now();
```



#### 2.17.10、其他 



[https://www.cnblogs.com/ggjucheng/p/3352280.html](https://www.cnblogs.com/ggjucheng/p/3352280.html)











## 3、表相关 



### 3.1、添加表的备注和字段备注 

#### 3.1.1、创建表的时候添加备注 

```sql
CREATE TABLE `healerjean_comment` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `name` varchar(32) NOT NULL COMMENT '名字备注',
  `email` varchar(64)  NOT NULL,
  `message` text ,
  PRIMARY KEY (`id`),
  KEY `index_name` (`name`)
)  COMMENT='表名备注' ;
```



#### 3.1.2、表创建完成添加表名备注和字段备注

```sql
ALTER TABLE healerjean_comment COMMENT='测试索引表';

ALTER table healerjean_comment MODIFY name  VARCHAR(32) NOT NULL COMMENT '名字备注'
```



### 3.2、查询建表语句

```sql
show create table table_name ;

```

![WX20180727-161536](https://raw.githubusercontent.com/HealerJean/HealerJean.github.io/master/blogImages/WX20180727-161536.png)

### 3.3、查看列的属性

```sql
show full columns from healerjean;
```

![WX20180727-161454](https://raw.githubusercontent.com/HealerJean/HealerJean.github.io/master/blogImages/WX20180727-161454.png)



### 3.4、修改字段顺序



#### 3.4.1、放到第1位

```sql
alter table demo_entity modify name varchar(32) comment '名字' first ;
```



#### 3.4.2、放到某个字段后面

```sql
alter table demo_entity modify name varchar(32) comment '名字' after id  ;
```





### 3.5、给表添加约束(唯一索引)  



>  **这个其实很常见，经常我们会使用主键作为唯一约束，如果是手机用户，或者是邮箱用户进行登录，那么这个登录的字段并不是主键。在高并发，注册的时候，如果不设置唯一约束，则可能会导入两个相同的数据。为了防止这种情况发生，我们要注意添加约束。**



> 创建联合约束，我们发现，这里设置为唯一约束，建立唯一约束和唯一索引又什么区别？建立唯一约束的时候，也会自动的创建唯一索引。建立唯一索引可以说是唯一约束的一种手段。





#### 3.5.1、添加普通和唯一索引

```sql
DROP  TABLE  user_info ;
create table user_info(
  id BIGINT(20) not null auto_increment,
  fuWuBusinessNoId  BIGINT(20) default null,
  dingYueBusinessNoId  BIGINT(20) default null,
  openId varchar(20) DEFAULT  NULL  UNIQUE  ,
  iphone varchar(20) default null COMMENT '',
  status int(11) default null ,
  cdate timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,
  udate timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  UNIQUE KEY unique_fuWuBusinessNoId_iphone (fuWuBusinessNoId,iphone) COMMENT '服务号和手机号唯一标识一个用户，可用于手机号登录判断',
  PRIMARY key (id));

添加普通索引
ALTER TABLE  user_info add name VARCHAR(20) DEFAULT  NULL  ;
CREATE INDEX  index_name  on user_info(name)  ;

添加唯一索引
ALTER TABLE  user_info add mail VARCHAR(20) DEFAULT  NULL  ;
CREATE UNIQUE INDEX  index_mail  on user_info(mail)  ;

alter table user_inf add unique index_mail `user_info` ( mail); 
```



#### 3.5.2、查看索引

```sql
show INDEX  from  user_info ;
```



#### 3.5.1、删除约束（唯一索引）

```sql
 
 ALTER TABLE jw_role DROP INDEX resource_name;
```



#### 3.5.4、SpringBoot注解 

```java

@Table(name = "user_info",
uniqueConstraints = {
        @UniqueConstraint(columnNames = "openId"), 
        @UniqueConstraint(columnNames = {"fuId","iphone"})},
indexes = {
    @Index(name = "index_itemGoodId",columnList = "authority,permission",unique = true),
    @Index(name = "index_cdate",columnList = "cdate")
})
            
      
        
@Entity
@Accessors(chain = true)
@Data
@NoArgsConstructor
@ApiModel(description = "微信用户信息")
public class UserInfo {

```





## 复杂查询



### 1、join连接

#### 1.1、内连接 左链接，右连接，全连接  

##### 1.1、INNER JOIN 和 JOIN  

> **返回左表和 右表同时存在的行**



![15515914742853](https://raw.githubusercontent.com/HealerJean/HealerJean.github.io/master/blogImages/15515914742853.png)

```sql
 
SELECT Persons.LastName, Persons.FirstName, Orders.OrderNo
FROM Persons
       INNER JOIN Orders ON Persons.Id_P = Orders.Id_P
ORDER BY Persons.LastName

```

![15515916356311](https://raw.githubusercontent.com/HealerJean/HealerJean.github.io/master/blogImages/15515916356311.png)

##### 3.1.1.2、LEFT JOIN 

> **即使右表中没有匹配，也从左表返回所有的行**

```sql
select Persons.LastName, Persons.FirstName, Orders.OrderNo
from Persons
       left join Orders on Persons.Id_P = Orders.Id_P
order by Persons.LastName

```

![15515914742853](https://raw.githubusercontent.com/HealerJean/HealerJean.github.io/master/blogImages/15515914742853.png)

![15515917585785](https://raw.githubusercontent.com/HealerJean/HealerJean.github.io/master/blogImages/15515917585785.png)

##### 3.1.1.3、RIGHT JOIN: 

> **即使左表中没有匹配，也从右表返回所有的行**

```sql
select Persons.LastName, Persons.FirstName, Orders.OrderNo
from Persons
       right join Orders on Persons.Id_P = Orders.Id_P
order by Persons.LastName

```

![15515914742853](https://raw.githubusercontent.com/HealerJean/HealerJean.github.io/master/blogImages/15515914742853.png)

![15515918393236](https://raw.githubusercontent.com/HealerJean/HealerJean.github.io/master/blogImages/15515918393236.png)

##### 3.1.1.4、FULL JOIN:

>  只要其中一个表中存在匹配，就返回行

```sql
select Persons.LastName, Persons.FirstName, Orders.OrderNo
from Persons full
       join Orders on Persons.Id_P = Orders.Id_P
order by Persons.LastName

```

![15515914742853](https://raw.githubusercontent.com/HealerJean/HealerJean.github.io/master/blogImages/15515914742853.png)

![15515919032202](https://raw.githubusercontent.com/HealerJean/HealerJean.github.io/master/blogImages/15515919032202.png)





#### 3.1.2、举例说明1



##### 数据样例 


```sql
create table department (
  dept_id int(11) default 0 comment '部门id',
  dept_name varchar(20) default '' comment '部门名称'
)comment ='部门' ;

insert into department values(1,'广告部');
insert into department values(2,'媒体部');
insert into department values(3,'管理部');
select * from department ;


create table employee (
  emp_id int(11) default 0 comment '员工id',
  emp_name varchar(20) default '' comment '员工名字',
  dept_id int(11) default 0 comment '部门id',
  emp_wage decimal(19,2) default 0 comment '薪水'
)comment ='员工表' ;


insert into employee values(1,'张宇晋',1,17000);
insert into employee values(2,'张三丰',1,15000);
insert into employee values(3,'张翠',2,18000);
insert into employee values(4,'林徽因',2,12000);
insert into employee values(5,'赵国强',3,17000);


```

<table>
<tr><th>dept_id</th><th>dept_name</th></tr>
<tr><td>1</td><td>广告部</td></tr>
<tr><td>2</td><td>媒体部</td></tr>
<tr><td>3</td><td>管理部</td></tr></table>

<table>
<tr><th>emp_id</th><th>emp_name</th><th>dept_id</th><th>emp_wage</th></tr>
<tr><td>1</td><td>张宇晋</td><td>1</td><td>17000.00</td></tr>
<tr><td>2</td><td>张三丰</td><td>1</td><td>15000.00</td></tr>
<tr><td>3</td><td>张翠</td><td>2</td><td>18000.00</td></tr>
<tr><td>4</td><td>林徽因</td><td>2</td><td>12000.00</td></tr>
<tr><td>5</td><td>赵国强</td><td>3</td><td>17000.00</td></tr></table>


3.1.3、left join on 后面加 and 


##### 1、left join

```sql
select
	d.dept_id,
	d.dept_name,
	e.emp_name,
	e.emp_wage 
from
	department d
	left join employee e on e.dept_id = d.dept_id ;
```

<table>
<tr><th>dept_id</th><th>dept_name</th><th>emp_name</th><th>emp_wage</th></tr>
<tr><td>1</td><td>广告部</td><td>张宇晋</td><td>17000.00</td></tr>
<tr><td>1</td><td>广告部</td><td>张三丰</td><td>15000.00</td></tr>
<tr><td>2</td><td>媒体部</td><td>张翠</td><td>18000.00</td></tr>
<tr><td>2</td><td>媒体部</td><td>林徽因</td><td>12000.00</td></tr>
<tr><td>3</td><td>管理部</td><td>赵国强</td><td>17000.00</td></tr></table>

##### 2、left join on   and 




+ 自个表 

```sql
SELECT
	d.dept_id,
	d.dept_name,
	e.emp_name,
	e.emp_wage 
FROM
	department d
	LEFT JOIN employee e ON e.dept_id = d.dept_id 
	AND d.dept_id = 1
       
```

<table>
<tr><th>dept_id</th><th>dept_name</th><th>emp_name</th><th>emp_wage</th></tr>
<tr><td>1</td><td>广告部</td><td>张宇晋</td><td>17000.00</td></tr>
<tr><td>1</td><td>广告部</td><td>张三丰</td><td>15000.00</td></tr>
<tr><td>2</td><td>媒体部</td><td>NULL</td><td>NULL</td></tr>
<tr><td>3</td><td>管理部</td><td>NULL</td><td>NULL</td></tr></table>

+ 其他表

```sql
select 
	d.dept_id,
	d.dept_name,
	e.emp_name,
	e.emp_wage 
from
	department d
	left join  employee e on e.dept_id = d.dept_id 
	and e.emp_wage = 17000
```

<table>
<tr><th>dept_id</th><th>dept_name</th><th>emp_name</th><th>emp_wage</th></tr>
<tr><td>1</td><td>广告部</td><td>张宇晋</td><td>17000.00</td></tr>
<tr><td>3</td><td>管理部</td><td>赵国强</td><td>17000.00</td></tr>
<tr><td>2</td><td>媒体部</td><td>NULL</td><td>NULL</td></tr></table>






##### 3、where实现全部查询结果的过滤

```sql
SELECT
	d.dept_id,
	d.dept_name,
	e.emp_name,
	e.emp_wage 
FROM
	department d
	LEFT JOIN employee e ON e.dept_id = d.dept_id 
WHERE
	e.emp_wage = 17000;

```

<table>
<tr><th>dept_id</th><th>dept_name</th><th>emp_name</th><th>emp_wage</th></tr>
<tr><td>1</td><td>广告部</td><td>张宇晋</td><td>17000.00</td></tr>
<tr><td>3</td><td>管理部</td><td>赵国强</td><td>17000.00</td></tr>
</table>



##### 4、进阶sql 
 
###### 1、查询每个部门中最大工资和最小工资，要求最大工资大于17000 最小工资小于16000

```sql
select shop, item, max(volumn) max_volumn
From sales s
group by shop;

下面的肯定是不好的，记得优化

select d.dept_id, d.dept_name, l.MaxWage, s.MinWage
from department d
       left join (select a.dept_id, a.emp_wage as MaxWage
                  from employee a
                  where a.emp_wage > 17000
                    and a.emp_wage = (select max(emp_wage) from employee b where b.dept_id = a.dept_id)
                  group by a.dept_id) 
                  l on l.dept_id = d.dept_id
       left join (select a.dept_id, a.emp_wage as MinWage
                  from employee a
                  where a.emp_wage < 16000
                    and a.emp_wage = (select min(emp_wage) from employee b where b.dept_id = a.dept_id)
                  group by a.dept_id)
                  s on s.dept_id = d.dept_id;
                  
                  
                           
         

第一步：查询每个部门中最大的工资，并且要求大于 17000

select a.dept_id, a.emp_wage as MaxWage
from employee a
where a.emp_wage > 17000
         and a.emp_wage = (
         select max(emp_wage) 
         from employee b
          where b.dept_id = a.dept_id)
group by a.dept_id
               
第二部 ：查询每个部门中报最小工资 要求小于16000

select a.dept_id, a.emp_wage as MinWage
from employee a
where a.emp_wage < 16000
     and a.emp_wage = (
     select min(emp_wage) 
     from employee b
      where b.dept_id = a.dept_id)
group by a.dept_id


                  
第三部，开始连接查询


select d.dept_id, d.dept_name, l.MaxWage, s.MinWage
from department d
       left join (select a.dept_id, a.emp_wage as MaxWage
                  from employee a
                  where a.emp_wage > 17000
                    and a.emp_wage = (select max(emp_wage) from employee b where b.dept_id = a.dept_id)
                  group by a.dept_id) 
                  l on l.dept_id = d.dept_id
       left join (select a.dept_id, a.emp_wage as MinWage
                  from employee a
                  where a.emp_wage < 16000
                    and a.emp_wage = (select min(emp_wage) from employee b where b.dept_id = a.dept_id)
                  group by a.dept_id)
                  s on s.dept_id = d.dept_id;

              

```













## 33、Group by 某一个或者多个字段查找重复数据的sql语句

5.7mysql中可能会遇到取唯一值的问题。一定要注意


### 33.1、表中有id和name 两个字段，查询出name重复的所有数据


```sql

group by username   having count(*) > 1
                             

select * 
from healerjean a 
where (a.username) in (
                    select username 
                    from healerjean 
                    group by username 
                             having count(*) > 1
                    )

```

### 33.2、删除分组中重读的数据，只保留id最小的记录


```sql

delete from healerjean 
where username in (
                    select username 
                    from healerjean 
                    group by username 
                    having count(username) > 1
                    )
      and id not in (
                    select min(id)   #每组中最小的数据
                    from healerjean 
                    group by username 
                    having count(username)>1)


```

### 33.3、查找表中多余的重复记录（多个字段）


```sql

下面这个就保证了，肯定是二者同时存在才会出现count(*)>1 
如果没有having则，会出现先根据peopleId分组，然后组内，再根据seq 分组。

group by peopleId,seq having count(*) > 1
                            
select * 
from vitae a
where (a.peopleId,a.seq) in (
                            select peopleId,    
                                   seq      
                            from vitae 
                            group by peopleId,seq 
                            having count(*) > 1)


```

### 33.4、选择表中多余的重复记录（多个字段），只留有id最小的记录


```sql


select * 
from vitae a
where (a.peopleId,a.seq) in (
                            select peopleId,    
                                   seq      
                            from vitae 
                            group by peopleId,seq 
                            having count(*) > 1)
and id not in           ( select min(id)   
                            from vitae 
                            group by peopleId,seq 
                            having count(*) > 1)
 
```

## 39、UNION 和 UNION ALL 操作符



### 默认情况下 UNION 操作符已经删除了重复数据。如果允许重复的值，请使用 UNION ALL。

SELECT 语句必须拥有相同数量的列。列也必须拥有相似的数据类型。同时，每条 SELECT 语句中的列的顺序必须相同。


```sql

SELECT column_name(s) FROM table_name1
UNION
SELECT column_name(s) FROM table_name2

```

## 41、havaing count用法


```sql

create table tb_grade (
  Sno int(11) default 0 comment '学号',
  Sname varchar(20) default '' comment '姓名',
  Cno int(11) default  0  comment '学号',
  Cname varchar(20) default ''comment '课程名',
  score int(11) default 0 comment '分数'
) comment '成绩表' ;

INSERT INTO tb_grade (Sno, Sname, Cno, Cname, score) VALUES (1001, '李菲', 1, '语文', 86);
INSERT INTO tb_grade (Sno, Sname, Cno, Cname, score) VALUES (1001, '李菲', 2, '数学', 50);
INSERT INTO tb_grade (Sno, Sname, Cno, Cname, score) VALUES (1001, '李菲', 3, '英语', 41);
INSERT INTO tb_grade (Sno, Sname, Cno, Cname, score) VALUES (1001, '李菲', 4, '化学', 89);
INSERT INTO tb_grade (Sno, Sname, Cno, Cname, score) VALUES (1001, '李菲', 5, '物理', 20);

INSERT INTO tb_grade (Sno, Sname, Cno, Cname, score) VALUES (1002, '张宇晋', 1, '语文', 86);
INSERT INTO tb_grade (Sno, Sname, Cno, Cname, score) VALUES (1002, '张宇晋', 2, '数学', 50);
INSERT INTO tb_grade (Sno, Sname, Cno, Cname, score) VALUES (1002, '张宇晋', 3, '英语', 70);
INSERT INTO tb_grade (Sno, Sname, Cno, Cname, score) VALUES (1002, '张宇晋', 4, '化学', 89);
INSERT INTO tb_grade (Sno, Sname, Cno, Cname, score) VALUES (1002, '张宇晋', 5, '物理', 20);


INSERT INTO tb_grade (Sno, Sname, Cno, Cname, score) VALUES (1003, '翠花', 1, '语文', 10);
INSERT INTO tb_grade (Sno, Sname, Cno, Cname, score) VALUES (1003, '翠花', 2, '数学', 20);
INSERT INTO tb_grade (Sno, Sname, Cno, Cname, score) VALUES (1003, '翠花', 3, '英语', 70);
INSERT INTO tb_grade (Sno, Sname, Cno, Cname, score) VALUES (1003, '翠花', 4, '化学', 40);
INSERT INTO tb_grade (Sno, Sname, Cno, Cname, score) VALUES (1003, '翠花', 5, '物理', 10);

```

<table >
<tr><th>Sno</th><th>Sname</th><th>Cno</th><th>Cname</th><th>score</th></tr>
<tr><td>1001</td><td>李菲</td><td>1</td><td>语文</td><td>86</td></tr>
<tr><td>1001</td><td>李菲</td><td>2</td><td>数学</td><td>50</td></tr>
<tr><td>1001</td><td>李菲</td><td>3</td><td>英语</td><td>41</td></tr>
<tr><td>1001</td><td>李菲</td><td>4</td><td>化学</td><td>89</td></tr>
<tr><td>1001</td><td>李菲</td><td>5</td><td>物理</td><td>20</td></tr>
<tr><td>1002</td><td>张宇晋</td><td>1</td><td>语文</td><td>86</td></tr>
<tr><td>1002</td><td>张宇晋</td><td>2</td><td>数学</td><td>50</td></tr>
<tr><td>1002</td><td>张宇晋</td><td>3</td><td>英语</td><td>70</td></tr>
<tr><td>1002</td><td>张宇晋</td><td>4</td><td>化学</td><td>89</td></tr>
<tr><td>1002</td><td>张宇晋</td><td>5</td><td>物理</td><td>20</td></tr>
<tr><td>1003</td><td>翠花</td><td>1</td><td>语文</td><td>10</td></tr>
<tr><td>1003</td><td>翠花</td><td>2</td><td>数学</td><td>20</td></tr>
<tr><td>1003</td><td>翠花</td><td>3</td><td>英语</td><td>70</td></tr>
<tr><td>1003</td><td>翠花</td><td>4</td><td>化学</td><td>40</td></tr>
<tr><td>1003</td><td>翠花</td><td>5</td><td>物理</td><td>10</td></tr></table>



#### 1、查询不及格科目数大于等于2的学生学号和学生姓名：


```sql
select t.Sno,t.Sname 
       from tb_grade t 
where t.score < 60 
group by t.Sno having count(t.Cno) > 2

```
<table >
<tr><th>Sno</th><th>Sname</th></tr>
<tr><td>1001</td><td>李菲</td></tr>
<tr><td>1003</td><td>翠花</td></tr></table>

#### 2、查询不及格科目数大于等于2的学生学号和不及格科目数量：


```sql

where条件中已经筛选出来了不及格的人，后面haveing中开始判断下不及格科目数量大于2的人。

不及格科目数量 ，其实已经帮我筛选出来了，只要签名添加就可以了

select t.Sno,
     count(t.Cno) as '不及格科目数量' 
from tb_grade t 
where t.score < 60 
group by t.Sno having count(t.Cno) > 2 
```

<table  style="border-collapse:collapse">
<tr><th>Sno</th><th>不及格科目数量</th></tr>
<tr><td>1001</td><td>3</td></tr>
<tr><td>1003</td><td>4</td></tr></table>

#### 3、查询不及格科目数大于等于2的学生学号、学生姓名、科目号、科目名称和分数，并按学号降序、科目号升序排序



```sql

select t.Sno, t.Sname, t.Cno, t.Cname, t.score
from tb_grade t
where t.score < 60
  and t.Sno in (select b.Sno from tb_grade b where b.score < 60 group by b.Sno having count(b.Cno) > 2)
order by t.Sno desc, Cno asc;


第一步，查询学生姓名、科目号、科目名称和分数，并按学号降序、科目号升序排序

select t.Sno, t.Sname, t.Cno, t.Cname, t.score
from tb_grade t
order by t.Sno desc, Cno asc;

第二部，注意是不及格，添加where筛选
select t.Sno, t.Sname, t.Cno, t.Cname, t.score
from tb_grade t
where t.score < 60
order by t.Sno desc, Cno asc;

第三部，选出，不及格科目数量大于2的同学，将2中的筛选添加放进来吧

select t.Sno, t.Sname, t.Cno, t.Cname, t.score
from tb_grade t
where t.score < 60
  and t.Sno in (select b.Sno from tb_grade b where b.score < 60 group by b.Sno having count(b.Cno) > 2)
order by t.Sno desc, Cno asc;

```

#### 4、分组having中添加and


```sql
select t.Sno,t.Sname
from tb_grade t
where t.score < 60
group by t.Sno having count(t.Cno) > 1 and Sname = '李菲';

```

<table>
<tr><th>Sno</th><th>Sname</th></tr>
<tr><td>1001</td><td>李菲</td></tr></table>
## 44、distinct必须放在开头

### 44.1、 普通用法

```
   id name 
   1 a 
   2 b 
   3 c 
   4 c 
   5 b 

select distinct name from table 
得到的结果是: 

   name 
   a 
   b 
   c 
   
   
他同时作用了两个字段，也就是必须得id与name都相同的才会被排除   
select distinct name, id from table
结果会是:

   id name
   1 a
   2 b
   3 c
   4 c
   5 b
 



```

### 44.2、count(distinct colume )


```sq;

Company	  OrderNumber
IBM	       3532
W3School	    2356
Apple	       4698
W3School	    6953

SELECT COUNT(Company) FROM Orders  4

SELECT COUNT(DISTINCT Company) FROM Orders 3


SELECT  Company ,count(DISTINCT Company)   from Orders  ;

```

### 44.2、和group by的比较

|id|name|
|---|---|
|1|a|
|2|b|
|3|c|
|4|d|
|5|a|
|6|b|


```sql
请注意下面这种方式在低版本的sql是错误的写法
select id ,count(name)  from quancheng_test group by name;

id count(name)
1   2
2   2
3   1
4   1
```
2、distinct 是去重的

```sql
select id, count(distinct name) from quancheng_test group by name;

id count(distinct name)
1   1
2   1
3   1
4   1
```


3、group by   是按组查询的，是一种聚合查询，很多时候是为了做统计用，例如：
对 name 分组，并统计每组 id 的和，

```sql
select sum(id), name from quancheng_test group by name;

sum(id)	name
6	      a
8	      b
3	      c
4	      d
```




```sql


```

​     

<font color="red"> 感兴趣的，欢迎添加博主微信， </font>   

哈，博主很乐意和各路好友交流，如果满意，请打赏博主任意金额，感兴趣的在微信转账的时候，备注您的微信或者其他联系方式。添加博主微信哦。     

请下方留言吧。可与博主自由讨论哦

|支付包 | 微信|微信公众号|
|:-------:|:-------:|:------:|
|![支付宝](https://raw.githubusercontent.com/HealerJean/HealerJean.github.io/master/assets/img/tctip/alpay.jpg) | ![微信](https://raw.githubusercontent.com/HealerJean/HealerJean.github.io/master/assets/img/tctip/weixin.jpg)|![微信公众号](https://raw.githubusercontent.com/HealerJean/HealerJean.github.io/master/assets/img/my/qrcode_for_gh_a23c07a2da9e_258.jpg)|




<!-- Gitalk 评论 start  -->

<link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk@latest/dist/gitalk.min.js"></script> 
<div id="gitalk-container"></div>    
 <script type="text/javascript">
    var gitalk = new Gitalk({
		clientID: `1d164cd85549874d0e3a`,
		clientSecret: `527c3d223d1e6608953e835b547061037d140355`,
		repo: `HealerJean.github.io`,
		owner: 'HealerJean',
		admin: ['HealerJean'],
		id: 'yGteDRHAXmN7alJz',
    });
    gitalk.render('gitalk-container');
</script> 

<!-- Gitalk end -->

