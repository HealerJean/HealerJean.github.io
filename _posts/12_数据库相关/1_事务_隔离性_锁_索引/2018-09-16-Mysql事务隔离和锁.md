---
title: Mysql乐观锁和悲观锁
date: 2018-09-16 03:33:00
tags: 
- Database
category: 
- Database
description: Mysql乐观锁和悲观锁
---
**前言**     

 Github：[https://github.com/HealerJean](https://github.com/HealerJean)         

 博客：[http://blog.healerjean.com](http://HealerJean.github.io)            




# 1、问题

## 1.1、事务并发的问题

### 1.1.1、脏读：

> 事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据，   
>
> 举例：当一个事务读取其它完成一半事务的记录时，就会发生脏读取。例如：用户A,B看到的值都是6，用户B把值改为2，用户A读到的值仍为6。



### 1.1.2、不可重复读：

> 事务 A 多次读取同一数据，事务 B 在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果 不一致。
>



### 1.1.3、幻读：

> 系统管理员A将数据库中所有学生的成绩从具体分数改为ABCDE等级，但是系统管理员B就在这个时候插入了一条具体分数的记录，当系统管理员A改结束后发现还有一条记录没有改过来，就好像发生了幻觉一样，这就叫幻读。



## 1.2、不使用锁会产生的问题

### 1.2.1、	丢失更新：
> 一个事务的更新覆盖了其它事务的更新结果，就是所谓的更新丢失。例如：用户A把值从6改为2，用户B把值从2改为6，则用户A丢失了他的更新。

### 1.2.1、	脏读：
> 当一个事务读取其它完成一半事务的记录时，就会发生脏读取。例如：用户A,B看到的值都是6，用户B把值改为2，用户A读到的值仍为6。
>



# 2、事物的隔离级别

| 事务隔离级别                                 | 脏读 | 不可重复读 | 幻读 |
| -------------------------------------------- | ---- | ---------- | ---- |
| 读取未提交内容（read-uncommitted）           | 是   | 是         | 是   |
| 读取提交内容（不可重复读）（read-committed） | 否   | 是         | 是   |
| 可重复读（repeatable-read）                  | 否   | 否         | 是   |
| 串行化（serializable）                       | 否   | 否         | 否   |



## 2.1、查看事物的隔离级别

```shell
SELECT @@tx_isolation ;  #myslq 默认隔离级别 ，REPEATABLE-READ，但是我们建议改为不可重复读级别
```

## 2.2、设置事物的隔离级别


```shell
SET  SESSION  transaction ISOLATION LEVEL  READ UNCOMMITTED  ;
```





# 3、锁的分类

## 3.1、共享锁和排它锁 

> **共享锁和排它锁 都可以直接通过select ...from...查询数据，因为普通查询没有任何锁机制**



**共享锁：**

> 共享锁又称为读锁，简称S锁，顾名思义，共享锁就是多个事务对于同一数据可以共享一把锁，都能访问到数据，但是只能读不能修改。     

```sql
SELECT * from city where id = "1"  lock in share mode;
然后在另一个查询窗口中，对id为1的数据进行更新


update  city set name="666" where id ="1";
此时，操作界面进入了卡顿状态，过几秒后，也提示错误信息
[SQL]update  city set name="666" where id ="1";
[Err] 1205 - Lock wait timeout exceeded; try restarting transaction
那么证明，对于id=1的记录加锁成功了，在上一条记录还没有commit之前，这条id=1的记录被锁住了，只有在上一个事务释放掉锁后才能进行操作，或用共享锁才能对此数据进行操作。


本窗口中

update city set name="666" where id ="1" lock in share mode;
[Err] 1064 - You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near 'lock in share mode' at line 1
加上共享锁后，也提示错误信息了，通过查询资料才知道，对于update,insert,delete语句会自动加排它锁的原因
于是，我又试了试SELECT * from city where id = "1" lock in share mode;这下成功了。

```

**排它锁：**   

> 排他锁又称为写锁，简称X锁，顾名思义，排他锁就是不能与其他所并存，如一个事务获取了一个数据行的排他锁，其他事务就不能再获取该行的其他锁，包括共享锁和排他锁，但是获取排他锁的事务是可以对数据就行读取和修改。       
>
> > update,insert,delete语句会自动加排它锁<font color="red"> （这三个锁住的是整个表，看情况查询的是不是主键，如果是主键和索引，则是行锁，否则是整张表）</font>



**排它锁与共享锁相对应，就是指对于多个不同的事务，对同一个资源只能有一把锁。与共享锁类型，在需要执行的语句后面加上for update就可以了**





## 3.2、乐观锁和悲观锁

### 3.2.1、悲观锁

> 悲观锁（Pessimistic Lock），顾名思义，就是很悲观，假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会block直到它拿到锁。       
>
> Java synchronized 就属于悲观锁的一种实现，每次线程要修改数据时都先获得锁，保证同一时刻只有一个线程能操作数据，其他线程则会被block。  

#### 3.2.1.1、行锁和表锁

> MySQL InnoDB默认Row-Level Lock，只有「明确」地指定主键，MySQL 才会执行Row lock (只锁住被选取的数据)， 否则MySQL 将会执行Table Lock (将整个数据表给锁住)。使用索引也会影响数据库的锁定级别，只要是明确指定的索引，也是只会锁住被选取的数据，否则就会将整个数据表锁住



#### 3.2.1.2、缺点

> 因为悲观锁大多数情况下依靠数据库的锁机制实现，以保证操作最大程度的独占性。如果加锁的时间过长，其他用户长时间无法访问，影响了程序的并发访问性，同时这样对数据库性能开销影响也很大，特别是对长事务而言，这样的开销往往无法承受。所以与悲观锁相对的，我们有了乐观锁。   





### 3.2.2、乐观锁

> 乐观锁（Optimistic Lock），顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在提交更新的时候会判断一下在此期间别人有没有去更新这个数据。   
>
> Java JUC中的atomic包就是乐观锁的一种实现，AtomicInteger 通过CAS（Compare And Set）操作实现线程安全的自增。
>



#### 3.2.2.1、实现方式

**1、使用数据版本（Version）记录机制实现**    

这是乐观锁最常用的一种实现方式。何谓数据版本？即为数据增加一个版本标识，一般是通过为数据库表增加一个数字类型的 “version” 字段来实现。当读取数据时，将version字段的值一同读出，数据每更新一次，对此version值加一。当我们提交更新的时候，判断数据库表对应记录的当前版本信息与第一次取出来的version值进行比对，如果数据库表当前版本号与第一次取出来的version值相等，则予以更新，否则认为是过期数据。

**2. 使用时间戳（timestamp）。**     

乐观锁定的第二种实现方式和第一种差不多，同样是在需要乐观锁控制的table中增加一个字段，名称无所谓，字段类型使用时间戳（timestamp）, 和上面的version类似，也是在更新提交的时候检查当前数据库中数据的时间戳和自己更新前取到的时间戳进行对比，如果一致则OK，否则就是版本冲突。



# 4、行级锁

1、记录锁(**Record Locks**):主键等值更新或删除的时候，锁定一行记录       

2、间隙锁(**Gap Locks**)：索引范围更新的时候，锁定一个开区间的范围，前提是数据库是RR（可重复读）级别，如果是RC（读已提交）级别，就没有间隙锁了    

3、临键锁(**Next-Key Locks**)：记录锁+间隙锁，一个左开右闭或者左闭右开的区间     

4、插入意向锁(**Insert Intention Locks**)：是一种特殊的间隙锁，也是锁定一个区间     



## 4.1、分类

### 4.1.1、记录锁

> **锁定一条记录，范围就是一条记录，不允许其他事务对这个记录进行加锁操作，记录锁就是锁update或者delete操作的（我下面的举例其实很多就是临减锁，只是说为了方便理解，下面写成了记录锁+间隙锁）**



### 4.1.2、间隙锁

> **锁定一个范围，范围是一个开区间，不包括首尾两个节点**，**不允许在这个间隙进行插入操作，因为间隙没有记录存在，所以也就不存在对记录进行更新或者操作的锁了**。    
>
> **简单理解就是间隙锁就是防止insert操作的，间隙锁防止其他事物做插入操作**    



### 4.1.3、临键锁

> 临键锁就是记录锁加间隙锁，锁定一个范围，范围是一个一开一闭的区间，不允许在这个区间进行加锁操作    
>
> **innodb默认的加锁方式就是临键锁，只不过对于唯一性的索引，会优化一下，不再锁定范围，而是退化成记录锁和间隙锁**     
>
> 所以我个人觉得使用的时候，就不用管临键锁，直接按照记录锁+间隙锁的组合来理解就好，这样可以覆盖所有情况，不然概念太多容易乱   
>
> 总结就是之后忘掉什么临键锁，万一看到临键锁只需要知道临键锁=间隙锁+记录锁



### 4.1.4、插入意向锁

> 特殊的间隙锁，锁定一个范围，**范围是一个开区间，允许在这个区间内进行不重复(主键、唯一索引不重复)的插入操作**，   
>
> **即插入意向锁是有可以共存的，只要唯一索引不重复即可。但是不与其他锁共存。并发插入就是使用意向锁**



在MySQL，InnoDB，RR下：

```
t(id unique PK, name);
```

数据表中有数据：

```
10, shenjian

20, zhangsan

30, lisi
```

事务A先执行，在10与20两条记录中插入了一行，还未提交：

```
insert into t values(11, xxx);
```

事务B后执行，也在10与20两条记录中插入了一行：

```
insert into t values(12, ooo);
```

(1)会使用什么锁？

(2)事务B会不会被阻塞呢？

回答：虽然事务隔离级别是RR，虽然是同一个索引，虽然是同一个区间，但插入的记录并不冲突，故这里：使用的是插入意向锁，并不会阻塞事务B



## 4.2、行锁加锁方式

> 对于**update||delete||insert**语句，innodb会自动的给涉及到的数据集加排他锁(从功能上讲是排他锁，从范围上，可能是记录锁、间隙锁、临建锁、插入意向锁的任何一种)   
>
> 对于**select**语句，不会加任何锁。   
>
> 我们可以手动给select语句加锁(这种悲观锁等效于把select语句变成一个update语句，但不等效insert)

```java
// 加共享锁
select * from lock_test where... lock in share mode;
// 加排他锁
select * from lock_test where... for update;
```



只命中了记录，一定有记录锁，可能会有间隙锁   只要命中了记录一定会给主键索引上记录锁，为了定位这条数据(因为数据是在主键索引上的)   

只命中了间隙(也就是没有命中任何记录)一定有间隙锁，没有记录锁   

都命中的话(说明是范围查询)，那么就是记录锁+间隙锁      

记录锁针对update或者delete   

间隙锁针对insert，且左右区间必须是存在的节点   





|                        | 唯一索引(包括主键索引)                                       | 不唯一索引                                                   |
| ---------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 等值查询命中           | a.命中记录行唯一索引->记录锁                                 | e.命中记录行主键索引->记录锁，不唯一索引->记录锁+间隙锁      |
| 等值查询未命中         | b.where条件中的唯一索引前后值->间隙锁                        | f.不唯一索引->间隙锁                                         |
| 范围查询命中一条或多条 | c.命中记录行唯一索引->记录锁+命中记录唯一索引所在最小区间的间隙锁 | g.命中记录行主键索引、不唯一索引->记录锁+命中记录不唯一索引所在最小区间的间隙锁 |
| 范围查询未命中         | d.where唯一索引向上或向下找一个节点->间隙锁                  | h.不唯一索引->间隙锁                                         |

问题1？这里唯一索引比较好理解，但是不唯一索引确定了数据集之后，为什么还要额外的给主键索引加记录锁呢？   

**答：其实不光不唯一索引，非主键的唯一索引确定了数据集，也要给命中记录的主键索引加记录锁的**       

 

问题2？至于为什么要"多此一举",因为只有给主键索引加了记录锁，才能彻底锁住这条记录，    

**答：可以理解为我们对一条数据做更改操作的时候，最后都是要通过主键索引去判断**。





### 4.2.1、验证

```sql
mysql> select * from lock_test;
+----+--------------+------+--------+
| id | name         | age  | number |
+----+--------------+------+--------+
|  1 | 托儿索       |    6 |    100 |
|  2 | 瞎子         |   10 |    200 |
|  3 | 大头         |  100 |    300 |
|  4 | 琴女         |   40 |    400 |
|  7 | 皇子         |   30 |    700 |
|  9 | 机器人       |   40 |    900 |
| 11 | 伊泽瑞尔     |   20 |   1100 |
+----+--------------+------+--------+
```



**a.只给id=4的索引项加了记录锁，此时已经可以准确定位到琴女这一行记录了**

```sql
// session1
mysql> begin;
mysql> select * from lock_test where id = 4 for update;
+----+--------+------+--------+
| id | name   | age  | number |
+----+--------+------+--------+
|  4 | 琴女   |   40 |    400 |
+----+--------+------+--------+
1 row in set (0.00 sec)

// session2测试
mysql> begin;
mysql> select * from lock_test where id = 4 for update;
ERROR 1205 (HY000): Lock wait timeout exceeded; try restarting transaction
```





**b.未命中记录行，向上向下分别寻找节点，得到id(4,7)的锁定范围，4-7不能插**

```sql
// session1
mysql> begin;
Query OK, 0 rows affected (0.00 sec)
mysql> select * from lock_test where id = 5 for update;
Empty set (0.00 sec)

// session2测试
mysql> begin;
Query OK, 0 rows affected (0.01 sec)

mysql> select * from lock_test where id =4 for update;
+----+--------+------+--------+
| id | name   | age  | number |
+----+--------+------+--------+
|  4 | 琴女   |   40 |    400 |
+----+--------+------+--------+
1 row in set (0.00 sec)

mysql> select * from lock_test where id =7 for update;
+----+--------+------+--------+
| id | name   | age  | number |
+----+--------+------+--------+
|  7 | 皇子   |   30 |    700 |
+----+--------+------+--------+
1 row in set (0.01 sec)

mysql> select * from lock_test where id =6 for update;
Empty set (0.00 sec)

mysql> insert into lock_test values (6,'凯隐',31,'600');
ERROR 1205 (HY000): Lock wait timeout exceeded; try restarting transaction

```



**c.命中记录行主键&唯一索引->记录锁+where条件间隙锁,得到id(4,7],[7,9],[9,11],[11,+oo),大于6的条件命中了7，9，11，4是向左边找到的一个开区间节点。**

```sql
// session1
mysql> begin;
Query OK, 0 rows affected (0.00 sec)

mysql> select * from lock_test where id > 6 for update;
+----+--------------+------+--------+
| id | name         | age  | number |
+----+--------------+------+--------+
|  7 | 皇子         |   30 |    700 |
|  9 | 机器人       |   40 |    900 |
| 11 | 伊泽瑞尔     |   20 |   1100 |
+----+--------------+------+--------+
3 rows in set (0.00 sec)

// session2测试
mysql> begin;
Query OK, 0 rows affected (0.00 sec)

mysql> select * from lock_test where id = 7 for update; --记录锁的原因不能修改
ERROR 1205 (HY000): Lock wait timeout exceeded; try restarting transaction
mysql> insert into lock_test values (12,'凯隐',31,'600'); --间隙锁不能插入
ERROR 1205 (HY000): Lock wait timeout exceeded; try restarting transaction
mysql> insert into lock_test values (5,'凯隐',31,'600');--间隙锁不能插入
ERROR 1205 (HY000): Lock wait timeout exceeded; try restarting transaction

```



**d.id大于11未命中任何记录，所以有了一个(11,+oo)的间隙锁。如果这里是id大于12，间隙锁范围也是(11,+oo)**

```sql
// session1
mysql> begin;
Query OK, 0 rows affected (0.00 sec)

mysql> select * from lock_test where id > 11 for update;
Empty set (0.00 sec)

// session2
mysql> begin;
Query OK, 0 rows affected (0.00 sec)

mysql> insert into lock_test values (12,'凯隐',31,'600');
ERROR 1205 (HY000): Lock wait timeout exceeded; try restarting transaction
mysql> select * from lock_test where id = 11 for update;
+----+--------------+------+--------+
| id | name         | age  | number |
+----+--------------+------+--------+
| 11 | 伊泽瑞尔     |   20 |   1100 |
+----+--------------+------+--------+
1 row in set (0.00 sec)

```



如果是不唯一索引同理，只测试一下范围命中的情况，其他的感兴趣可以自己测试 。   

age是一个normal索引，这里大于35,加锁情况分析如下   

id索引项:3,4,9 记录锁   

age索引项:40,100记录锁，(30,+oo)间隙锁   

```sql
// session1
mysql> begin;
Query OK, 0 rows affected (0.00 sec)

mysql> select * from lock_test where age > 35 for update;
+----+-----------+------+--------+
| id | name      | age  | number |
+----+-----------+------+--------+
|  3 | 大头      |  100 |    300 |
|  4 | 琴女      |   40 |    400 |
|  9 | 机器人    |   40 |    900 |
+----+-----------+------+--------+
3 rows in set (6.56 sec)

// session2
mysql> begin;
Query OK, 0 rows affected (0.00 sec)

mysql> insert into lock_test values (13,'凯隐',29,201); --没有记录锁可以修改
Query OK, 1 row affected (0.00 sec)

mysql> insert into lock_test values (14,'凯隐',30,203); --间隙锁不能超如
ERROR 1205 (HY000): Lock wait timeout exceeded; try restarting transaction

```

















![ContactAuthor](https://raw.githubusercontent.com/HealerJean/HealerJean.github.io/master/assets/img/artical_bottom.jpg)




<!-- Gitalk 评论 start  -->

<link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk@latest/dist/gitalk.min.js"></script> 
<div id="gitalk-container"></div>    
 <script type="text/javascript">
    var gitalk = new Gitalk({
		clientID: `1d164cd85549874d0e3a`,
		clientSecret: `527c3d223d1e6608953e835b547061037d140355`,
		repo: `HealerJean.github.io`,
		owner: 'HealerJean',
		admin: ['HealerJean'],
		id: 'dkFLhNEVlCz3q2yw',
    });
    gitalk.render('gitalk-container');
</script> 

<!-- Gitalk end -->

