---
title: Msql千万级优化
date: 2018-09-19 03:33:00
tags: 
- Database
category: 
- Database
description: Msql千万级优化
---
**前言**     

 Github：[https://github.com/HealerJean](https://github.com/HealerJean)         

 博客：[http://blog.healerjean.com](http://HealerJean.github.io)          



# 一、分页查询优化

**问题 `SQL`** 

> 解释：表中的字段越多下面的优化越明显，否则即使使用了下面的优化，也可能没有那么明显   
>
> 通过下面的可以观察到 当达到`1000`万的时候，查询时间到了37s，太可怕了    
>

```sql
select * from tb_ams_inf_repay_stat limit 0,10 ; 
#  0.003s

select * from tb_ams_inf_repay_stat  limit 10000,10 ;  
# 1万 0.023s

select * from tb_ams_inf_repay_stat  limit 100000,10 ;
# 10万 0.191s

select * from tb_ams_inf_repay_stat limit 1000000,10 ;
# 100万 1.942s

select * from tb_ams_inf_repay_stat limit 10000000,10 ;
# 1000万 37.323s

```

## 1、简单优化

#### 1）子查询

> 0.23s 简直要飞起来了    
>
> **1、先使用覆盖索引 `index` 查询 ，我们只查询 `id` 索引这一个字段，比 `select * ` 或者多个字段快多了，因为只要我们写上这些字段，我们只需要 `10`个，但是从第一条开始到 `1000`万条其实是都要去扫描的**     
>
> **2、然后再进行索引范围内 `range`查询** 

```sql
0.23s 
select *
from tb_ams_inf_repay_stat
where id > (select id from tb_ams_inf_repay_stat limit 1000000, 1)
limit 0,10 ;


--推荐使用 
select * from table where id > 243800 order by id limit 10;
```


<table border="1" style="border-collapse:collapse">
<tr><th>id</th><th>select_type</th><th>table</th><th>type</th><th>possible_keys</th><th>key</th><th>key_len</th><th>ref</th><th>rows</th><th>Extra</th></tr>
<tr><td>1</td><td>PRIMARY</td><td>tb_ams_inf_repay_stat</td><td>range</td><td>PRIMARY</td><td>PRIMARY</td><td>8</td><td>NULL</td><td>3258410</td><td>Using where</td></tr>
<tr><td>2</td><td>SUBQUERY</td><td>tb_ams_inf_repay_stat</td><td>index</td><td>NULL</td><td>idx_orgcd_loannum</td><td>216</td><td>NULL</td><td>19753500</td><td>Using index</td></tr></table>


#### 2）`Join` 连接

```sql
-- 0.31 

SELECT *
FROM tb_ams_inf_repay_stat a
       JOIN (select id from tb_ams_inf_repay_stat limit 1000010, 10) b ON a.ID = b.id
```

<table border="1" style="border-collapse:collapse">
<tr><th>id</th><th>select_type</th><th>table</th><th>type</th><th>possible_keys</th><th>key</th><th>key_len</th><th>ref</th><th>rows</th><th>Extra</th></tr>
<tr><td>1</td><td>PRIMARY</td><td>&lt;derived2&gt;</td><td>ALL</td><td>NULL</td><td>NULL</td><td>NULL</td><td>NULL</td><td>1000020</td><td>NULL</td></tr>
<tr><td>1</td><td>PRIMARY</td><td>a</td><td>eq_ref</td><td>PRIMARY</td><td>PRIMARY</td><td>8</td><td>b.id</td><td>1</td><td>NULL</td></tr>
<tr><td>2</td><td>DERIVED</td><td>tb_ams_inf_repay_stat</td><td>index</td><td>NULL</td><td>idx_orgcd_loannum</td><td>216</td><td>NULL</td><td>19753500</td><td>Using index</td></tr></table>


## 2、其他优化

### 1）带有条件的，`id` 连续的查询（`between`）

```sql
0.03s 
select * from tb_ams_inf_repay_stat  where id  between 1000000 and 1000010  	 ;
```



### 2）带有条件，`id` 不连续的查询，考虑建立索引

```sql
20s 慢死了
select * from tb_ams_inf_repay_stat  	where org_cd = 'xmsd'  	limit 1000000,10 ;
```

```java
-- org_cd建立索引

select *
from tb_ams_inf_repay_stat
where org_cd = 'xmsd'
  and id > (select id from tb_ams_inf_repay_stat where org_cd = 'xmsd' limit 1000000,1)
limit 0,10 ;

0.2s 可以说相当的快了 
```




<table>
<tr><th>id</th><th>select_type</th><th>table</th><th>type</th><th>possible_keys</th><th>key</th><th>key_len</th><th>ref</th><th>rows</th><th>Extra</th></tr>
<tr><td>1</td><td>PRIMARY</td><td>NULL</td><td>NULL</td><td>NULL</td><td>NULL</td><td>NULL</td><td>NULL</td><td>NULL</td><td>~~~~</td></tr>
<tr><td>2</td><td>SUBQUERY</td><td>tb_ams_inf_repay_stat</td><td>ref</td><td>idx_orgcd_loannum</td><td>idx_orgcd_loannum</td><td>93</td><td>const</td><td>1</td><td>Using where; Using index</td></tr></table>




# 二、千万测试数据生成

## 1、存储过程

### 1）表

```java
create table if not exists `user_demo`
(
    `id`          bigint unsigned not null auto_increment comment '主键',
    `name`        varchar(32)     not null default '' comment '姓名',
    `age`         int             not null default 0 comment '年龄',
    `phone`       varchar(32)     not null default '' comment '电话',
    `email`       varchar(64)     not null default '' comment '邮箱',
    `start_time`  datetime                 default null comment '开始时间',
    `end_time`    datetime                 default null comment '结束时间',
    `valid_flag`  int             not null default 1 comment '1有效 0 废弃',
    `create_time` datetime        not null default current_timestamp comment '创建时间',
    `update_time` datetime        not null default current_timestamp on update current_timestamp comment '更新时间',
    primary key (`id`)
) engine = innodb
  default charset = utf8;

```

### 2）存储过程

```sql
drop procedure if exists test_batch_create;
create procedure test_batch_create(in loop_counts int, in date varchar(50))
begin
    declare i int;
    set i = 0;
    set autocommit = 0; -- 关闭自动提交事务，提高插入效率
    while i < loop_counts
        do
            insert into `user_demo` (name, age, phone, email, start_time, end_time, valid_flag)
            values (concat('张', floor(rand() * 2 * i)), floor(rand() * i), floor(rand() * 3 * i),
                    concat( floor(rand() * 2 * i), '@gmail.com'), date_add(date ,interval i day), date_add(date ,interval i*2 day), 1);
            set i = i + 1;
        end while;
    commit;
end;

```

### 3）执行

```sql
CALL test_batch_create(10, '2023-07-01');
```









![ContactAuthor](https://raw.githubusercontent.com/HealerJean/HealerJean.github.io/master/assets/img/artical_bottom.jpg)




<!-- Gitalk 评论 start  -->

<link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk@latest/dist/gitalk.min.js"></script> 
<div id="gitalk-container"></div>    
 <script type="text/javascript">
    var gitalk = new Gitalk({
		clientID: `1d164cd85549874d0e3a`,
		clientSecret: `527c3d223d1e6608953e835b547061037d140355`,
		repo: `HealerJean.github.io`,
		owner: 'HealerJean',
		admin: ['HealerJean'],
		id: 'sVtG9yWYSIPvoieX',
    });
    gitalk.render('gitalk-container');
</script> 

<!-- Gitalk end -->

