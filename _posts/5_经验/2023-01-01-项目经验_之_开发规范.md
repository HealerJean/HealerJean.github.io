---
title: 项目经验_之_开发规范
date: 2023-01-01 00:00:00
tags: 
- Experience
category: 
- Experience
description: 项目经验_之_开发规范
---

**前言**     

 Github：[https://github.com/HealerJean](https://github.com/HealerJean)         

 博客：[http://blog.healerjean.com](http://HealerJean.github.io)          





# 1、命名风格



## 1.1、类名 命名

> 类名使用 `UpperCamelCase` 风格，必须遵从驼峰形式，但以下情形例外:(领 域模型的相关命名) `DO` / `BO` / `DTO` / `VO` / `DAO`
>
> > **影响： 代码可读性差**

```java
 正例： ForceCode / UserDO / HtmlDTO /TcpUdpDeal / TaPromotion
 反例： forcecode / UserDo / HTMLDto /TCPUDPDeal / TAPromotion
```



## 1.2、方法名、参数名、成员/局部变量 命名

> 1.1.2、方法名、参数名、成员/局部变量统一使用`lowerCamelCase`，必须遵从驼峰形式
>
> **影响：反序列化或者 `Lombok` 中 @Data`赋值失败**

```java
正例: localValue / testMethod()
```



## 1.3、抽象类 命名

> 抽象类命名使用 `Abstract` 或 `Base`开头
>
> >  **影响： 代码可读性差**

```java
正例： AbstractActionDemo
```



## 1.4、单元测试类 命名

> 单元测试类命名以它要测试的类的名称开始，以 `Test`结尾
>
>  **影响： 代码可读性差**

```java
 正例： DemoTest
```



## 1.5、美元符号 使用

> 代码中的命名均不能以下划线或美元符号开始，也不能以下划线或美元符号结束
>
> >  **影响： 代码可读性差**

```java
反例:  _name / __name / $name / name_ / name$ / name__
```



## 1.6、异常类 命名

> 异常类命名使用 `Exception` 结尾
>
> > **影响： 代码可读性差**

```java
CacheDemoException
```



## 1.7、常量 命名

> 常量命名应该全部大写，单词间用下划线隔开，**力求语义表达完整清楚，不要嫌名字长**
>
> > **影响： 代码可读性差**

```java
正例:MAX_STOCK_COUNT / CACHE_EXPIRED_TIME 

反例:MAX_COUNT / EXPIRED_TIME

```



## 1.8、 `Service` 和 `DAO`类 使用

> 对于 `Service` 和 `DAO` 类，基于 `SOA` 的理念，暴露出来的服务一定是接口，内部的实现类用 `Impl` 的后缀与接口区别
>
> > **影响： 代码可读性差**

```java
正例：public class DemoServiceImpl implements DemoService
```



## 1.9、包名 命名

> 包名统一使用小写，点分隔符之间有且仅有一个自然语义的英语单词。包名统一使用单数形式，但是类名如果有复数含义，类名可以使用复数形式
>
> > **影响： 代码可读性差**

```java
正例： com.jd.mpp.util/com.jd.tddl.domain.dto
```





## 1.10、`POJO`  类使用

### 1.10.11、布尔类型 命名

> `POJO` 类中的任何布尔类型的变量，都不要加is，否则部分框架解析会引起序列化错误
>
> > **影响： 部分框架解析会引起序列化错误**

```java
正例：Boolean success
  
反例：定义为基本数据类型Boolean isDeleted的属性，当它的方法也isDeleted()时，框架在反向解析的时候，“误以为”对应的属性名称是deleted，导致属性获取不到，进而抛出异常
```

### 1..10.12、禁止在 `POJO` 类中，同时存在对应属性 `xxx` 的 `isXxx()` 和 `getXxx()` 方法

> 禁止在 `POJO` 类中，同时存在对应属性 `xxx` 的 `isXxx()` 和 `getXxx()` 方法
>
> > **影响：框架在调用属性 `xxx` 的提取方法时，并不能确定哪一个方法一定是被优先调用到的**





## 1.11、类型与中括号紧挨相连来表示数组

> 类型与中括号紧挨相连来表示数组
>
> > **影响： 代码可读性差**

```java
正例：定义整形数组int[] arrayDemo;

反例：在main参数中，使用String args[]来定义
```





# 2、注释

## 2.1、字段和方法 注释

> 所有的字段和方法必须要用 `javadoc` 注释
>
> > **影响：严重影响代码可读性和编码效率**



## 2.2、枚举 注释

> 所有的枚举类型字段必须要有注释，说明每个数据项的用途
>
> > **影响： 代码可读性差**

```java
public enum TestEnum {
      /**
      * 月份
      */
      MONTH;
}
```



## 2.3、单行 注释

> 方法内部单行注释，在被注释语句上方另起一行，使用//注释。方法内部多行注释使用/**/注释，注意与代码对齐     
>
> >  影响：影响代码可读性和编码效率



## 2.4、类注释

> 类必须有 `@author`（创建者）、`@since`（创建日期）、类功能描述等注释信息



# 3、集合

## 3.1、集合转数组

> 使用集合转数组的方法，必须使用 `toArray(T[] array)`，传入类型完全一样的数组，大小 `list.size()`    
>
> 说明：使用 `toArray` 带参方法，数组空间大小的 `length`，

1） 等于 `0`，动态创建与size相同的数组，性能最好。    

2） 大于 `0` 但小于`size`，重新创建大小等于size的数组，增加 `GC` 负担。    

3） 等于 `size`，在高并发情况下，数组创建完成之后，`size` 正在变大的情况下，负面影响与2相同。     

4） 大于 `size`，空间浪费，且在 `size` 处插入 `null` 值，存在 `NPE` 隐患。

```java
 正例：Integer[] b = (Integer [])c.toArray(new Integer[0]);

 反例：直接使用toArray无参方法存在问题，返回值只能是Object[]类。若强转其它类型数组将出现ClassCastException错误。

Integer[] a =(Integer[])c.toArray();
```



## 3.2、集合初始化时，指定集合初始值大小

> 集合初始化时，指定集合初始值大小     
>
> > 说明：`HashMap` 使用 `HashMap(int initialCapacity)` 初始化，如果暂时无法确定集合大小，那么指定默认值（`16`）即可。      
> >
> > **影响：浪费内存，降低性能**

```java

正例：initialCapacity = (需要存储的元素个数 / 负载因子) + 1。注意负载因子（即loader factor）默认为0.75，如果暂时无法确定初始值大小，请设置为16（即默认值）。

反例：HashMap需要放置1024个元素，由于没有设置容量初始大小，随着元素不断增加，容量7次被迫扩大，resize需要重建hash表。当放置的集合元素个数达千万级别时，不断扩容会严重影响性能。
```



# 4、`OOP`

## 4.1、比较相等

### 4.1.1、`Object的equals`

> `Object` 的 `equals` 方法容易抛出空指针异常，应使用常量或确定有值的对象来调用 `equals`
>
> >  影响：导致业务逻辑错误

```java
正例："test".equals(object); Objects.equals(a, b);

反例：object.equals("test");
```



### 4.1.2、包装类对象之间值的比较，全部使用 `equals` 方法比较

> 所有的包装类对象之间值的比较，全部使用 `equals` 方法比较
>
> >  影响：导致业务逻辑错误 （对于 `Integer` 在-128至127之间的值会在缓存里对象复用，区间外数据会产生新对象）

```
 正例：Objects.equals(a, b);

 反例：Integer.valueOf(a) == Integer.valueOf(b);
```



### 4.1.3、基本数据类型与包装数据类型的 使用

> 1、 所有的 `POJO` 类属性必须使用包装数据类型；     
>
> 2、`RPC` 方法的返回值和参数必须使用包装数据类型     
>
> 3、所有的局部变量推荐使用基本数据类型      
>
> > 说明：`POJO` 类属性没有初值是提醒使用者在需要使用时，必须自己显式地进行赋值，任何 `NPE` 问题，或者入库检查，都由使用者来保证      

```
正例：数据库查询结果可能是null，因为自动拆箱，用基本数据类型接收有NPE风险。

反例： RPC方法的返回值使用基本类型，无法区分null值和0的区别
```



### 4.1.4、定义 `DO` / `DTO` / `VO` 等 `POJO` 类时，不要加任何属性默认值

> 说明：ORM框架根据列修改时，会将默认值覆盖数据库的存储值

```java
反例： POJO类的createTime默认值为new Date()，但是这个属性在数据提取时并没有置入具体值，在更新其它字段时又附带更新了此字段，导致创建时间被修改成当前时间
```



### 4.1.5、`POJO`  类必须写 `toString`方法

> > 说明：使用工具类 `source` > `generate toString` 时，如果继承了另一个 `POJO` 类，注意在前面加一下 `super.toString`。打印对象信息日志，性能优于 `JSON  `
> >
> > **影响： 降低编码效率，影响日志打印性能**



```java
public class ToStringDemo extends Super {

    private String secondName;

    @Override
    public String toString() {
        return (
            super.toString() +
            "ToStringDemo{" +
            "secondName=" +
            secondName +
            "}"
        );
    }
}

class Super {

    private String firstName;

    @Override
    public String toString() {
        return "Super{" + "firstName=" + firstName + "}";
    }
}

```



### 4.1.6、`BigDecimal` 

#### 4.1.6.1、精度问题

> 禁止使用构造方法 `BigDecimal(double)` 的方式把 `double`值转化为 `BigDecimal` 对象
>
> 影响： 数据精度丢失     
>
> 说明： `BigDecimal(double)` 存在精度损失风险，在精确计算或值比较的场景中可能会导致业务逻辑异常。      
>
> > 如：`BigDecimal` `g` = `new BigDecimal(0.1f)`; 实际的存储值为：0. 100000000000000005551115123125782702118

```
正例：优先推荐入参为 `String` 的构造方法：

BigDecimal recommend1 = new BigDecimal("0.1"); 

BigDecimal recommen d2 = BigDecimal.valueOf(0.1);
或使用BigDecimal的valueOf方法，此方法内部其实执行了Double的toString，而 Double的toString按double的实际能表达的精度对尾数进行了截断。 
```



### 4.1.7、方法的参数个数建议不超过5个,方便代码阅读与理解

> 方法的参数个数建议不超过5个,方便代码阅读与理解
>
> > **影响：降低编码效率，不方便阅读和理解**





### 4.1.8、方法体的行数不能多于70行

> **影响： 降低编码效率，不方便阅读和理解**





### 4.1.8、强转对象操作需要判断对象类型是否匹配

> 说明：强转之前必须使用 `instanceof` 进行类型判断     
>
> **影响： 类型转换失败，抛出`ClassCastException`**    
>
> 理解：个人认为大可不必



### 4.1.8、字符串循环拼接

> 字符串循环拼接，不能用 + 连接, 需要用 `StringBuilder` 代替,提高性能        
>
> **影响：浪费内存，影响性能**













![ContactAuthor](https://raw.githubusercontent.com/HealerJean/HealerJean.github.io/master/assets/img/artical_bottom.jpg)



<!-- Gitalk 评论 start  -->

<link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">

<script src="https://unpkg.com/gitalk@latest/dist/gitalk.min.js"></script> 
<div id="gitalk-container"></div>    
 <script type="text/javascript">
    var gitalk = new Gitalk({
		clientID: `1d164cd85549874d0e3a`,
		clientSecret: `527c3d223d1e6608953e835b547061037d140355`,
		repo: `HealerJean.github.io`,
		owner: 'HealerJean',
		admin: ['HealerJean'],
		id: 'k5F4yhQa0sLwlZWz',
    });
    gitalk.render('gitalk-container');
</script> 




<!-- Gitalk end -->



