---
title: é¡¹ç›®ç»éªŒ_ä¹‹_å…¨é‡æ•°æ®é¢„çƒ­
date: 2024-09-14 00:00:00
tags: 
- Experience
category: 
- Experience
description: é¡¹ç›®ç»éªŒ_ä¹‹_å…¨é‡æ•°æ®é¢„çƒ­
---

**å‰è¨€**     

 Githubï¼š[https://github.com/HealerJean](https://github.com/HealerJean)         

 åšå®¢ï¼š[http://blog.healerjean.com](http://HealerJean.github.io)          



# ä¸€ã€å…¨é‡æ•°æ®é¢„çƒ­ç³»ç»Ÿ

### 1ã€æ–¹æ¡ˆç›®æ ‡

- **æ•°æ®ä¸ä¸¢**ï¼šå³ä½¿ä¸­é—´æœåŠ¡å‡æ­»ï¼Œæ¢å¤åä¹Ÿèƒ½è¿½ä¸Šã€‚
- **ä¸€è‡´æ€§**ï¼š`5000` å°æœºå™¨æ•°æ®åŸºæœ¬ä¸€è‡´ï¼ˆå…è®¸ç§’çº§å»¶è¿Ÿï¼‰
- **æ€§èƒ½**ï¼šé¿å…å¤§ `Key` ã€é¿å…å…¨é‡æ›¿æ¢ã€é¿å…é«˜ `CPU/GC`
- **å¯æ‰©å±•**ï¼šæ”¯æŒæ¯æ—¥å…¨é‡åˆ·æ–° + å¢é‡åŒæ­¥





# äºŒã€å…¨é‡å†™å…¥æ–¹æ¡ˆ

## 1ã€æ–¹æ¡ˆç›®æ ‡

| ç›®æ ‡                       | æè¿°                                                         |
| -------------------------- | ------------------------------------------------------------ |
| **æ”¯æŒåƒä¸‡çº§æ•°æ®å…¨é‡åŠ è½½** | æ•°æ®æ€»é‡çº¦ 10GBï¼ˆæ¯æ¡è®°å½• ~1KBï¼‰ï¼Œéœ€é¿å… OOM å’Œé•¿æ—¶é—´é˜»å¡    |
| **é«˜æ•ˆå­˜å‚¨ä¸ä¼ è¾“**         | å‡å°‘ç£ç›˜å ç”¨ã€ç½‘ç»œå¸¦å®½æ¶ˆè€—ï¼Œä¼˜å…ˆé€‰æ‹©ç´§å‡‘åºåˆ—åŒ–æ ¼å¼ï¼Œæ¯ä¸ªæ•°æ®æºå¯é€‰åºåˆ—åŒ–æ–¹å¼ï¼Œå¯é€‰å‹æµ‹ |
| **åˆ†ç‰‡å¹¶è¡Œå†™å…¥åŠ é€Ÿ**       | åˆ©ç”¨å¤šçº¿ç¨‹æå‡å†™å…¥é€Ÿåº¦ï¼Œç¼©çŸ­æ•´ä½“å¯¼å‡ºè€—æ—¶                     |
| **åŸå­æ€§å‘å¸ƒæœºåˆ¶**         | é˜²æ­¢å®¢æˆ·ç«¯è¯»å–åˆ°â€œéƒ¨åˆ†å®Œæˆâ€çš„å¿«ç…§æ–‡ä»¶                         |
| **ç‰ˆæœ¬æ§åˆ¶ä¸é€šçŸ¥æœºåˆ¶**     | å®ç°æœåŠ¡ç«¯ä¸»åŠ¨é€šçŸ¥ï¼Œç¡®ä¿ä¸‹æ¸¸åŠæ—¶æ„ŸçŸ¥æ–°ç‰ˆæœ¬                   |
| **è‡ªåŠ¨æ¸…ç†æ—§å¿«ç…§**         | é¿å… OSS/S3 å­˜å‚¨æ— é™è†¨èƒ€ï¼Œä¿ç•™æœ€è¿‘ 7 å¤©å†å²                  |
| **å¢é‡èµ·ç‚¹å¯è¿½æº¯**         | è®°å½•æœ¬æ¬¡å…¨é‡å¼€å§‹æ—¶é—´ï¼Œä½œä¸ºåç»­å¢é‡æ‹‰å–çš„èµ·å§‹ä½ç‚¹             |
| **ç”Ÿäº§çº§ç¨³å®šæ€§ä¿éšœ**       | æ”¯æŒå¤±è´¥é‡è¯•ã€ä¸´æ—¶æ–‡ä»¶ä¿æŠ¤ã€æ—¥å¿—ç›‘æ§                         |



## 2ã€æ•´ä½“æ¶æ„æ¦‚è§ˆ

- **æ•°æ®æºè¯»å–**ï¼šåŸºäºä¸»é”®æ¸¸æ ‡åˆ†é¡µï¼Œæµå¼åŠ è½½ï¼Œé¿å… OOMã€‚
- **åˆ†ç‰‡å†™å…¥**ï¼šæŒ‰ `userId` å“ˆå¸Œåˆ†å‘åˆ°å¤šä¸ªåˆ†ç‰‡ï¼Œå¹¶è¡Œå†™å…¥ã€‚
- **åºåˆ—åŒ–å‹ç¼©**ï¼šä½¿ç”¨ Protobuf + GZIPï¼Œæè‡´å‹ç¼©ã€‚
- **åŸå­å‘å¸ƒ**ï¼šå…ˆå†™ `.tmp` ä¸´æ—¶æ–‡ä»¶ï¼Œå®Œæˆå `rename` å‘å¸ƒã€‚
- **ç‰ˆæœ¬é€šçŸ¥**ï¼šå°†æœ€æ–°ç‰ˆæœ¬å·å†™å…¥ Redisï¼Œä¸‹æ¸¸è½®è¯¢æ„ŸçŸ¥ã€‚
- **æ¸…ç†æ—§ç‰ˆæœ¬**ï¼šä¿ç•™æœ€è¿‘ 7 å¤©å¿«ç…§ï¼Œé˜²æ­¢å­˜å‚¨è†¨èƒ€

```
+------------------+     +----------------------------+
|   æºç³»ç»Ÿ (MySQL)   | --> | åˆ†é¡µè¯»å– + æµå¼å¤„ç†å¼•æ“      |
+------------------+     +--------------+-------------+
                                         |
                                         v
                       +----------------------------------+
                       | æŒ‰ userId å“ˆå¸Œåˆ†å‘åˆ° N ä¸ªåˆ†ç‰‡å†™å…¥å™¨ |
                       +----------------+-----------------+
                                        |
                                        v
                   +--------------------+--------------------+
                   |            å¯¹è±¡å­˜å‚¨å±‚ (OSS / S3)           |
                   |  full_data_v{version}_{shardId}.pb.gz     |
                   +--------------------+--------------------+
                                        |
                                        v
                             +----------+-----------+
                             |    Redis ç‰ˆæœ¬ä¸­å¿ƒ     |
                             | snapshot:user_tag:latest |
                             +----------+-----------+
                                        |
                                        v
                            +-----------+------------+
                            | ä¸‹æ¸¸æœåŠ¡ï¼ˆå®šæ—¶è½®è¯¢ Redisï¼‰  |
                            | ä¸‹è½½åˆ†ç‰‡ â†’ è§£å‹ â†’ åŠ è½½å†…å­˜  |
                            +-----------+------------+
```

## 3ã€æ ¸å¿ƒç»„ä»¶è¯¦è§£

### 1ï¼‰æ•°æ®æºè¯»å–æ¨¡å—

- é—®é¢˜èƒŒæ™¯ï¼šç›´æ¥ `SELECT * FROM table` ä¼šä¸€æ¬¡æ€§åŠ è½½å…¨éƒ¨æ•°æ®ï¼Œå¯¼è‡´å†…å­˜æº¢å‡ºï¼ˆ`OOM`ï¼‰ï¼Œå°¤å…¶åœ¨åƒä¸‡çº§ä»¥ä¸Šæ•°æ®é‡æ—¶ä¸å¯æ¥å—ã€‚

- è§£å†³æ–¹æ¡ˆï¼šåŸºäºä¸»é”®çš„æ¸¸æ ‡åˆ†é¡µ
  - ä½¿ç”¨ `user_id`ï¼ˆä¸»é”®æˆ–å”¯ä¸€ç´¢å¼•ï¼‰ä½œä¸ºåˆ†é¡µé”šç‚¹ã€‚
  - æ¯æ¬¡è¯»å– `1W` æ¡ï¼Œé¿å…å†…å­˜å †ç§¯ã€‚
  - ä¸ä¾èµ– `OFFSET`ï¼Œé¿å…æ·±åº¦åˆ†é¡µæ€§èƒ½ä¸‹é™ã€‚

```sql
SELECT user_id, tag_id, tag_value, update_time
FROM user_tag
WHERE user_id > ?
ORDER BY user_id ASC
LIMIT 10000;
```

```java
public List<UserTag> findByPage(Long lastId, int pageSize) {
    String sql = "SELECT ... WHERE user_id > ? ORDER BY user_id LIMIT ?";
    return jdbcTemplate.query(sql, (rs, rowNum) -> mapRowToUserTag(rs), lastId, pageSize);
}
```



### 2ï¼‰åºåˆ—åŒ–æ ¼å¼

> æ¨èä½¿ç”¨ **`Protobuf` + `GZIP`** ç»„åˆï¼Œåœ¨å‹ç¼©ç‡å’Œè§£ææ€§èƒ½ä¹‹é—´å–å¾—æœ€ä½³å¹³è¡¡ï¼Œé€‚åˆè·¨è¯­è¨€ã€é«˜æ€§èƒ½åœºæ™¯ã€‚

- **å†…éƒ¨é«˜æ€§èƒ½æœåŠ¡é€šä¿¡** â†’ ç”¨ `Protobuf`
- **å¯¹å¤– `REST API` / è°ƒè¯•å‹å¥½** â†’ ç”¨ `JSON`ï¼ˆæˆ– `JSON + Gzip` å¦‚æœå¸¦å®½ç´§å¼ ï¼‰
- **æŒä¹…åŒ–å­˜å‚¨ / æ‰¹é‡æ•°æ®å¯¼å‡º** â†’ ç”¨ `Protobuf + Gzip`
- **å·²æœ‰ `JSON` ç³»ç»Ÿæƒ³é™å¸¦å®½** â†’ å¿«é€Ÿå¯ç”¨ `JSON + Gzip`ï¼ˆé›¶ä»£ç æ”¹é€ ï¼‰

| æ ¼å¼                | å¤§å°å¯¹æ¯” | æ€§èƒ½å¯¹æ¯”      | æ˜¯å¦æ¨è | è¯´æ˜                                                        |
| ------------------- | -------- | ------------- | -------- | ----------------------------------------------------------- |
| `JSON`              | 100%     | 1x            | âŒ        | å¯è¯»æ€§å¥½ï¼Œä½†ä½“ç§¯å¤§ã€æ€§èƒ½ä½ï¼Œä¸é€‚åˆé«˜æ€§èƒ½æˆ–å¸¦å®½æ•æ„Ÿåœºæ™¯      |
| `JSON + Gzip`       | ~30%     | ~0.8xï¼ˆç•¥æ…¢ï¼‰ | âœ…        | ä½“ç§¯æ˜¾è‘—å‡å°ï¼Œé€‚åˆç½‘ç»œä¼ è¾“ï¼›ä½† CPU å¼€é”€å¢åŠ ï¼Œä¸”ä»éœ€è§£ææ–‡æœ¬ |
| `Protobuf`          | ~40%     | 3x æ›´å¿«       | âœ…âœ…       | äºŒè¿›åˆ¶ã€é«˜æ•ˆã€è·¨è¯­è¨€ï¼Œé€‚åˆå†…éƒ¨æœåŠ¡é€šä¿¡å’Œå­˜å‚¨                |
| `Protobuf` + `Gzip` | ~15%     | 2.5x          | âœ…âœ…âœ…      | æè‡´å‹ç¼© + é«˜æ€§èƒ½ï¼Œé€‚åˆå†·æ•°æ®å­˜å‚¨æˆ–é«˜æˆæœ¬å¸¦å®½åœºæ™¯           |



### 3ï¼‰æ•°æ®åˆ†ç‰‡ç­–ç•¥ï¼ˆè´Ÿè½½å‡è¡¡ + å°æ–‡ä»¶ä¼˜åŒ–ï¼‰

| å‚æ•°           | åŸå§‹æ–¹æ¡ˆï¼ˆ1000ç‰‡ï¼‰ | ä¼˜åŒ–åæ–¹æ¡ˆï¼ˆ100ç‰‡ï¼‰ |
| -------------- | ------------------ | ------------------- |
| å•ç‰‡å¤§å°       | ~10MB              | ~100â€“150MB          |
| æ–‡ä»¶æ•°é‡       | 1000               | 100                 |
| å¹¶å‘è¿æ¥       | é«˜ï¼ˆæ˜“è¶…é™ï¼‰       | é€‚ä¸­                |
| OSS å…ƒæ•°æ®å‹åŠ› | æé«˜               | å¯æ§                |

- **ä¸ºä»€ä¹ˆæ”¹ä¸º `100` ç‰‡ï¼Ÿ**

  - **`SS`/`S3` æœ€ä½³å®è·µå»ºè®®å•ä¸ªå¯¹è±¡å¤§å° â‰¥ 100MB**ï¼Œä»¥å‡å°‘å…ƒæ•°æ®å¼€é”€å’Œåˆ—ä¸¾å»¶è¿Ÿ
- `1000` ä¸ªå°æ–‡ä»¶ä¼šå¯¼è‡´ `OSS` å…ƒæ•°æ®å‹åŠ›å¤§ã€åˆ—ä¸¾æ…¢ã€æ‰“å¼€å¼€é”€é«˜ã€‚
  - `100` ä¸ªåˆ†ç‰‡å¯åœ¨å¤§å¤šæ•°é›†ç¾¤ç¯å¢ƒä¸­è‰¯å¥½å¹¶è¡Œå¤„ç†ã€‚

- **å“ˆå¸Œç®—æ³•æ”¹è¿›ï¼ˆé˜²å€¾æ–œï¼‰ï¼š**

  - ```
    int shardId = Math.floorMod(Objects.hash(userId), SHARD_COUNT);
    ```

  - ä½¿ç”¨ `Objects.hash()` æä¾›æ›´å¥½çš„æ•£åˆ—åˆ†å¸ƒã€‚

  - `Math.floorMod` ç¡®ä¿ç»“æœä¸ºæ­£æ•´æ•°ï¼Œé¿å…è´Ÿç´¢å¼•å¼‚å¸¸ã€‚



### 4ï¼‰å­˜å‚¨å±‚è®¾è®¡ï¼š å‹ç¼©ä¸Šä¼ ä¸åŸå­å‘å¸ƒ

#### aã€å‹ç¼©æµæ„å»ºï¼ˆ`GZIP` + `Protobuf`ï¼‰

> ä½¿ç”¨ `GZIPOutputStream` åŒ…è£¹è¾“å‡ºæµï¼Œè‡ªåŠ¨å‹ç¼©ï¼š

```java
OutputStream rawStream = storage.getOutputStream(tempFilename);
GZIPOutputStream gos = new GZIPOutputStream(rawStream);
CodedOutputStream cos = CodedOutputStream.newInstance(gos);

// å†™å…¥æ¯æ¡æ¶ˆæ¯ï¼ˆdelimitedï¼‰
for (UserTag record : batch) {
    UserTagProto proto = convertToProto(record);
    proto.writeDelimitedTo(cos); // è‡ªåŠ¨æ·»åŠ é•¿åº¦å‰ç¼€
}
cos.flush();
gos.close(); // è§¦å‘å‹ç¼©ç»“æŸ
```

#### bã€åŸå­å‘å¸ƒæœºåˆ¶ï¼ˆä¸´æ—¶æ–‡ä»¶ + renameï¼‰

- è‹¥ä»»åŠ¡ä¸­æ–­ï¼Œä¸´æ—¶æ–‡ä»¶å­˜åœ¨ï¼Œä¸‹æ¬¡å¯æ¢å¤ï¼›
- å®¢æˆ·ç«¯åªçœ‹åˆ°å®Œæ•´å‘å¸ƒçš„æ–‡ä»¶ï¼Œä¸ä¼šè¯»åˆ°åŠæˆå“ï¼›
- æ”¯æŒå¤šç§åº•å±‚å­˜å‚¨ï¼ˆæœ¬åœ°/`OSS`/`S3`ï¼‰ç»Ÿä¸€è¯­ä¹‰ã€‚

```java
// å†™å…¥ .tmp ä¸´æ—¶æ–‡ä»¶
String tempFile = filename + ".tmp";
try (OutputStream os = storage.getOutputStream(tempFile)) {
    writeData(os);
}

// åŸå­æ€§å‘å¸ƒï¼šrename to final name
storage.publish(tempFile, filename); 
```



### 5ï¼‰ç‰ˆæœ¬é€šçŸ¥æœºåˆ¶ï¼š`Redis` æ›¿ä»£ `ZooKeeper`

#### aã€ `ZooKeeper` çš„å±€é™æ€§ï¼ˆä¸æ¨èç”¨äºäº‹ä»¶å¹¿æ’­ï¼‰

| é£é™©                  | è¯´æ˜                                      |
| --------------------- | ----------------------------------------- |
| `ZK` ç¬æ—¶æ¨é€é£æš´     | ä¸€æ¬¡ `setData()`ï¼ŒZK å‘æ•°åƒå°æœºå™¨å‘é€äº‹ä»¶ |
| `ZK` å»¶è¿Ÿå‡é«˜         | å¤§é‡ Watcher å¯¼è‡´åè°ƒæœåŠ¡å“åº”å˜æ…¢         |
| å®¢æˆ·ç«¯å¤„ç†ä¸è¿‡æ¥      | æ•°åƒå°æœºå™¨åŒæ—¶å‘èµ·ä¸‹è½½ â†’ ç½‘ç»œæ´ªå³°         |
| `ZK` ä¸æ˜¯æ¶ˆæ¯å¹¿æ’­ç³»ç»Ÿ | å®ƒæ˜¯åè°ƒæœåŠ¡ï¼Œä¸é€‚åˆå¤§è§„æ¨¡äº‹ä»¶é€šçŸ¥        |

#### bã€æ¨èæ–¹æ¡ˆï¼š`Redis` è½»é‡çº§ç‰ˆæœ¬ä¸­å¿ƒ

- **`TTL` è®¾ç½®ï¼š**æ‰€æœ‰ `key` è®¾ç½® 7 å¤©è¿‡æœŸï¼Œä¸å¿«ç…§ç”Ÿå‘½å‘¨æœŸä¸€è‡´ã€‚
- **ä¸‹æ¸¸è¡Œä¸ºï¼š**
  - æ¯éš” `1~5` åˆ†é’Ÿè½®è¯¢ä¸€æ¬¡ `snapshot:{dataSource}:latest`ï¼›
  - å‘ç°ç‰ˆæœ¬å˜åŒ–åï¼Œä¸‹è½½å¯¹åº”çš„ `manifest` å¹¶æ ¡éªŒå„åˆ†ç‰‡ã€‚

```bash
 å½“å‰æœ€æ–°ç‰ˆæœ¬å·
snapshot:user_tag:latest â†’ "1730486400"

# ç‰ˆæœ¬è¯¦æƒ…ï¼ˆHashï¼‰
snapshot:user_tag:1730486400.version â†’ "1730486400"
snapshot:user_tag:1730486400.createTime â†’ "1730486400000"
snapshot:user_tag:1730486400.recordCount â†’ "9876543"
snapshot:user_tag:1730486400.manifestUrl â†’ "manifest/user_tag_v1730486400_manifest.json"
```



### 6ï¼‰ æ¸…ç†ç­–ç•¥ï¼šä¿ç•™æœ€è¿‘ 7 å¤©å¿«ç…§

> é˜²æ­¢å­˜å‚¨æ— é™å¢é•¿ã€‚æ”¯æŒå›æ»šåˆ°è¿‡å»ä¸€å‘¨å†…çš„ä»»æ„ç‰ˆæœ¬ã€‚é™ä½å¤‡ä»½æˆæœ¬ã€‚

```java
public void cleanupOld(String dataSource, long currentVersion) {
    try {
        String prefix = dataSource + "_v";

        for (String file : storage.listFiles(prefix)) {
            Long ver = extractVersion(file);
            if (ver != null && ver < currentVersion) {
                storage.delete(file);
                log.info("ğŸ—‘ï¸ åˆ é™¤æ—§å¿«ç…§æ–‡ä»¶: {}", file);
            }
        }

        // æ¸…ç†æ—§ manifest å’Œ checkpoint
        cleanupByPrefix("manifest/" + prefix, currentVersion);
        cleanupByPrefix("checkpoints/" + prefix, currentVersion);

    } catch (IOException e) {
        log.error("æ¸…ç†å¤±è´¥", e);
    }
}

private void cleanupByPrefix(String prefix, long currentVersion) throws IOException {
    for (String file : storage.listFiles(prefix)) {
        Long ver = extractVersion(file);
        if (ver != null && ver < currentVersion) {
            storage.delete(file);
            log.info("ğŸ—‘ï¸ åˆ é™¤æ—§è¾…åŠ©æ–‡ä»¶: {}", file);
        }
    }
}
```





### 7ï¼‰å¢é‡è¡”æ¥ï¼šè®°å½•å…¨é‡å¼€å§‹æ—¶é—´

- å…³é”®å­—æ®µï¼š

  - `startTime`: å½“å‰å…¨é‡ä»»åŠ¡å¼€å§‹çš„æ—¶é—´æˆ³ï¼ˆå³ä¸Šæ¬¡å…¨é‡å®Œæˆåç¬¬ä¸€æ¬¡å¢é‡çš„èµ·ç‚¹ï¼‰

  - ä¹Ÿå¯ä½¿ç”¨ `max(update_time)` ä½œä¸ºæ›´ç²¾ç¡®çš„èµ·ç‚¹ï¼Œå–å†³äºä¸šåŠ¡è¯­ä¹‰ã€‚

- åç»­å¢é‡æ¶ˆè´¹æ–¹å¼ï¼š

  | æ¥æº             | æ‹‰å–æ–¹å¼                          |
  | ---------------- | --------------------------------- |
  | `MySQL` `Binlog` | ä» `update_time > startTime` æŸ¥è¯¢ |
  | `Kafka`          | ä»å¯¹åº”æ—¶é—´ç‚¹çš„ offset å¼€å§‹æ¶ˆè´¹    |
  | `Redis` `Stream` | XREAD with `$` or timestamp       |





### 8ï¼‰é”™è¯¯å¤„ç†ä¸å¥å£®æ€§è®¾è®¡

#### aã€å¥å£®æ€§è®¾è®¡

| é£é™©           | åº”å¯¹æªæ–½                                       |
| -------------- | ---------------------------------------------- |
| å†™å…¥ä¸­é€”å´©æºƒ   | ä½¿ç”¨ä¸´æ—¶æ–‡ä»¶ï¼Œä¸‹æ¬¡å¯åŠ¨å¯åˆ¤æ–­æ˜¯å¦ç»§ç»­           |
| **æ–­ç‚¹ç»­ä¼ **   | è®°å½•å·²å¤„ç†çš„æœ€å¤§ `user_id`ï¼Œå¤±è´¥åä»ä¸­æ–­å¤„æ¢å¤ |
| `ZK` è¿æ¥æ–­å¼€  | è‡ªåŠ¨é‡è¿ + æœ¬åœ°ç¼“å­˜æœ€åç‰ˆæœ¬                    |
| å†…å­˜æº¢å‡º       | æµå¼å¤„ç†ï¼Œæ— ä¸­é—´é›†åˆç¼“å­˜                       |
| æ–‡ä»¶æœªå®Œå…¨å†™å…¥ | åªæœ‰å…¨éƒ¨å†™å®Œæ‰å‘å¸ƒç‰ˆæœ¬                         |

#### bã€éªŒè¯æ–¹å¼

| éªŒè¯é¡¹     | æ–¹æ³•                                              |
| ---------- | ------------------------------------------------- |
| æ–­ç‚¹ç»­ä¼    | kill è¿›ç¨‹ â†’ é‡å¯ â†’ æŸ¥çœ‹æ—¥å¿—æ˜¯å¦ä»ä¸Šæ¬¡ä½ç½®ç»§ç»­     |
| æ•°æ®ä¸€è‡´   | æŸ¥çœ‹ä¸‹æ¸¸æ—¥å¿—æ˜¯å¦æ‰“å° ` åŠ è½½æˆåŠŸï¼Œå…± X æ¡`         |
| æ–‡ä»¶å®Œæ•´æ€§ | `cat /data-preload/snapshots/manifest*.json`      |
| æ–­ç‚¹æ–‡ä»¶   | `cat /data-preload/checkpoints/checkpoint_v*.txt` |



### 9ï¼‰æ–‡ä»¶å‘½åè§„èŒƒ & ç¤ºä¾‹

- `dataSource`: æ•°æ®æºåç§°ï¼ˆå¦‚ `user_tag`, `item_profile`ï¼‰
- `version`: `System.currentTimeMillis()`ï¼Œå…¨å±€å”¯ä¸€ä¸”æœ‰åº
- `shardId`: `[0, N-1]`
- `.pb.gz`: Protobuf + Gzip å‹ç¼©æ ¼å¼

```
full_data_v{version}_{shardId}.pb.gz

ç¤ºä¾‹ï¼š
full_data_v1730486400000_0.pb.gz
full_data_v1730486400000_1.pb.gz
...
full_data_v1730486400000_99.pb.gz
```





### 10ï¼‰æ€§èƒ½ä¼°ç®—ï¼ˆä»¥ `1000` ä¸‡æ¡ä¸ºä¾‹ï¼‰

| æŒ‡æ ‡            | æ•°å€¼                     |
| --------------- | ------------------------ |
| åŸå§‹æ•°æ®å¤§å°    | ~10 GB                   |
| Protobuf å¤§å°   | ~4 GB                    |
| Protobuf + Gzip | **~1.5 GB**              |
| åˆ†ç‰‡æ•°é‡        | 100 ä¸ª                   |
| å¹³å‡æ¯ä¸ªæ–‡ä»¶    | ~15 MB                   |
| å¯¼å‡ºè€—æ—¶        | 5â€“10 åˆ†é’Ÿï¼ˆDB è´Ÿè½½æ­£å¸¸ï¼‰ |
| å†…å­˜å ç”¨        | < `200 MB`ï¼ˆæµå¼å¤„ç†ï¼‰   |
| `CPU` å ç”¨      | ä¸­ç­‰ï¼ˆProtobuf åºåˆ—åŒ–ï¼‰  |



### 11ï¼‰æ–¹æ¡ˆä¼˜åŠ¿æ€»ç»“

| ç»´åº¦         | è¯´æ˜                                               |
| ------------ | -------------------------------------------------- |
| **é«˜æ•ˆæ€§**   | Protobuf + Gzip æè‡´å‹ç¼©ï¼ŒèŠ‚çœ 85% å­˜å‚¨            |
| **ä¸€è‡´æ€§**   | ä¸´æ—¶æ–‡ä»¶ + ZK åŸå­å‘å¸ƒï¼Œæœç»è„è¯»                   |
| **å¯ç»´æŠ¤æ€§** | è‡ªåŠ¨æ¸…ç†æ—§ç‰ˆæœ¬ï¼Œé˜²æ­¢æ•°æ®è†¨èƒ€                       |
| **å¯è§‚æµ‹æ€§** | ç‰ˆæœ¬ä¿¡æ¯ä¸°å¯Œï¼Œæ”¯æŒç›‘æ§å‘Šè­¦                         |
| **æ‰©å±•æ€§**   | åˆ†ç‰‡ç»“æ„å¤©ç„¶æ”¯æŒæ°´å¹³æ‰©å±•                           |
| **å…¼å®¹æ€§**   | `Protobuf` è·¨è¯­è¨€ï¼Œæ˜“äºè¢« Go/Python/C++ å®¢æˆ·ç«¯è§£æ |





## 4ã€ä»£ç å®ç°

```
src/
â”œâ”€â”€ main/
â”‚   â”œâ”€â”€ java/
â”‚   â”‚   â”œâ”€â”€ core/
â”‚   â”‚   â”‚   â”œâ”€â”€ SnapshotDataProvider.java
â”‚   â”‚   â”‚   â”œâ”€â”€ DataSerializer.java
â”‚   â”‚   â”‚   â””â”€â”€ FullSnapshotGenerator.java
â”‚   â”‚   â”œâ”€â”€ provider/
â”‚   â”‚   â”‚   â”œâ”€â”€ SnapshotDataProviderManager.java
â”‚   â”‚   â”‚   â””â”€â”€ UserTagProvider.java
â”‚   â”‚   â”œâ”€â”€ serializer/
â”‚   â”‚   â”‚   â”œâ”€â”€ ProtobufSerializer.java
â”‚   â”‚   â”‚   â””â”€â”€ JsonSerializer.java
â”‚   â”‚   â”œâ”€â”€ storage/
â”‚   â”‚   â”‚   â”œâ”€â”€ StorageService.java
â”‚   â”‚   â”‚   â”œâ”€â”€ LocalStorageService.java
â”‚   â”‚   â”‚   â””â”€â”€ OssStorageService.java
â”‚   â”‚   â”œâ”€â”€ checkpoint/
â”‚   â”‚   â”‚   â”œâ”€â”€ Checkpoint.java
â”‚   â”‚   â”‚   â””â”€â”€ CheckpointManager.java
â”‚   â”‚   â”œâ”€â”€ shard/
â”‚   â”‚   â”‚   â”œâ”€â”€ ShardWriter.java
â”‚   â”‚   â”‚   â””â”€â”€ ShardWriterManager.java
â”‚   â”‚   â”œâ”€â”€ manifest/
â”‚   â”‚   â”‚   â”œâ”€â”€ ManifestGenerator.java
â”‚   â”‚   â”‚   â””â”€â”€ DataIntegrityException.java
â”‚   â”‚   â”œâ”€â”€ publish/
â”‚   â”‚   â”‚   â””â”€â”€ SnapshotPublisher.java
â”‚   â”‚   â”œâ”€â”€ cleanup/
â”‚   â”‚   â”‚   â””â”€â”€ SnapshotCleanupService.java
â”‚   â”‚   â”œâ”€â”€ diff/
â”‚   â”‚   â”‚   â”œâ”€â”€ DataDiffTool.java
â”‚   â”‚   â”‚   â”œâ”€â”€ DiffReport.java
â”‚   â”‚   â”‚   â””â”€â”€ ChangedRecord.java
â”‚   â”‚   â””â”€â”€ config/
â”‚   â”‚       â””â”€â”€ SnapshotConfig.java
â”‚   â””â”€â”€ resources/
â”‚       â”œâ”€â”€ logback.xml
â”‚       â””â”€â”€ application.properties
â””â”€â”€ test/
    â””â”€â”€ ...
```





### 1ï¼‰åŠ¨æ€é…ç½®

#### aã€`SnapshotDatasetConfig`

```java
/**
 * å•ä¸ªæ•°æ®é›†çš„å¿«ç…§ç”Ÿæˆé…ç½®é¡¹ã€‚
 * å¯åœ¨è¿è¡Œæ—¶ç”±é…ç½®ä¸­å¿ƒåŠ¨æ€åˆ·æ–°ã€‚
 *
 * @author zhangyujin
 * @date 2025/11/3
 */
@Data
public class SnapshotDatasetConfig {

    /**
     * åˆ†ç‰‡æ•°é‡ï¼Œé»˜è®¤ 8ã€‚
     */
    private Integer shardCount = 8;

    /**
     * æ¯æ‰¹æ¬¡åŠ è½½è®°å½•æ•°ï¼Œé»˜è®¤ 1000ã€‚
     */
    private Integer batchSize = 1000;

    /**
     * æ˜¯å¦å¯ç”¨ GZIP å‹ç¼©è¾“å‡ºæ–‡ä»¶ã€‚
     */
    private Boolean compress = true;

    /**
     * åºåˆ—åŒ–ç­–ç•¥ï¼šæ”¯æŒ fastjsonã€protobufã€‚
     */
    private String serializer = "fastjson";

    /**
     * ä½¿ç”¨çš„çº¿ç¨‹æ± åç§°ï¼Œéœ€åœ¨ ThreadPoolFactory ä¸­æ³¨å†Œã€‚
     */
    private String threadPool = "default-pool";

    /**
     * å†™å…¥å¹¶å‘åº¦ï¼Œé»˜è®¤ 10ã€‚
     */
    private Integer maxConcurrent = 1000;

    /**
     * æ˜¯å¦å¯ç”¨æ–­ç‚¹ç»­ä¼ åŠŸèƒ½
     */
    private Boolean enableCheckpoint = true;

}
```

#### bã€`HotSnapshotConfig`

```java
/**
 * å†…å­˜å…¨å±€é…ç½®æ–‡ä»¶
 *
 * @author zhangyujin
 * @date 2025/11/3
 */
@Data
@Slf4j
@Configuration
@ConfigurationProperties(prefix = "hot-snapshot")
public class HotSnapshotConfig {

    /**
     * é»˜è®¤é…ç½®æ¨¡æ¿ï¼Œç”¨äºæœªæ˜¾å¼æŒ‡å®šçš„æ•°æ®é›†ã€‚
     */
    private SnapshotDatasetConfig defaultConfig = new SnapshotDatasetConfig();
    /**
     * å„ä¸ªæ•°æ®é›†çš„ä¸ªæ€§åŒ–é…ç½®æ˜ å°„ã€‚
     * Key: datasetName (e.g., "user-tag")
     */
    private Map<String, SnapshotDatasetConfig> datasets;

    /**
     * æ ¹æ®æ•°æ®é›†åç§°è·å–æœ€ç»ˆç”Ÿæ•ˆé…ç½®ï¼ˆä¼˜å…ˆçº§ï¼šdatasets > defaultï¼‰
     */
    public DatasetRunConfig instanceRunConfig(String datasetName) {
        DatasetRunConfig runConfig = new DatasetRunConfig();
        runConfig.setDatasetName(datasetName);

        // è·å–é…ç½®ï¼šä¼˜å…ˆä½¿ç”¨datasetsä¸­çš„é…ç½®ï¼Œå¦åˆ™ä½¿ç”¨é»˜è®¤é…ç½®
        SnapshotDatasetConfig config = datasets != null ? datasets.get(datasetName) : null;
        if (config == null) {
            config = defaultConfig;
            log.info("ä½¿ç”¨é»˜è®¤é…ç½®ç”Ÿæˆæ•°æ®é›†: {}", datasetName);
        } else {
            log.info("ä½¿ç”¨ä¸ªæ€§åŒ–é…ç½®ç”Ÿæˆæ•°æ®é›†: {}", datasetName);
        }
        runConfig.setSnapshotDatasetConfig(config);
        runConfig.setDataSerializer(getDataSerializer(datasetName, config.getSerializer()));
        return runConfig;
    }


    /**
     * è·å–åºåˆ—è¯æ–¹å¼
     *
     * @param
     * @return {@link DataSerializer}
     */
    private DataSerializer<?> getDataSerializer(String datasetName, String serializer) {
        HotCacheEnum.DatesetKeyEnum datesetKeyEnum = HotCacheEnum.DatesetKeyEnum.getDatesetKeyEnum(datasetName);
        HotCacheEnum.DataSerializerEnum dataSerializerEnum = HotCacheEnum.DataSerializerEnum.getDataSerializerEnum(serializer);
        switch (dataSerializerEnum) {
            case FAST_JSON:
                return new FastjsonDataSerializer<>(datesetKeyEnum.getClazz());
            default:
                return null;
        }
    }
}

```

#### cã€`DatasetRunConfig`

```java
/**
 * SnapshotConfig
 *
 * @author zhangyujin
 * @date 2025/11/3
 */
@Data
public class DatasetRunConfig {

    /**
     * æ•°æ®é›†åç§°
     */
    private String datasetName;

    /**
     * è¿è¡Œæ—¶å†…å­˜é…ç½®ï¼Œå¯é€šè¿‡é…ç½®ä¸­å¿ƒè¿›è¡Œå˜æ›´
     */
    private SnapshotDatasetConfig snapshotDatasetConfig;

    /**
     * dataSerializer
     */
    private DataSerializer<?> dataSerializer;


}

```

#### dã€`hot-snapshot.yml`

```yml
hot-snapshot:
  # é»˜è®¤å…¨å±€é…ç½®
  default:
    shard-count: 8
    batch-size: 1000
    compress: true
    serializer: fastjson  # å¯é€‰: fastjson, protobuf
    thread-pool: default-pool
  # å„ä¸ªæ•°æ®é›†ç‹¬ç«‹é…ç½®ï¼ˆå¯è¢«é…ç½®ä¸­å¿ƒè¦†ç›–ï¼‰
  datasets:
    user_tag:
      shard-count: 100
      batch-size: 10000
      compress: false
      serializer: fastjson
      thread-pool: user_tag
      max-concurrent: 10
      enable-checkpoint: true
      enable-integrity-check: true
    product_info:
      shard-count: 8
      batch-size: 1000
      compress: true
      serializer: fastjson
      thread-pool: product_info

```



#### eã€`HotCacheEnum`

```java

import com.healerjean.proj.hotcache.data.UserTag;
import lombok.AllArgsConstructor;
import lombok.Getter;

import java.util.Arrays;

/**
 * HotCacheEnum
 *
 * @author zhangyujin
 * @date 2025/11/3
 */
public interface HotCacheEnum {

    /**
     * HotCacheKeyEnum
     */
    @AllArgsConstructor
    @Getter
    enum DatesetKeyEnum implements HotCacheEnum {
        USER_TAG("user_tag", UserTag.class,"ç”¨æˆ·æ ‡ç­¾"),
        ;

        /**
         * code
         */
        private final String code;

        private final Class<?> clazz;
        /**
         * desc
         */
        private final String desc;


        /**
         * getHotCacheKeyEnumByCode
         *
         * @param code code
         * @return {@link DatesetKeyEnum}
         */
        public static DatesetKeyEnum getDatesetKeyEnum(String code) {
            return Arrays.stream(DatesetKeyEnum.values()).filter(item -> item.getCode().equals(code)).findFirst().orElse(null);
        }
    }


    @Getter
    @AllArgsConstructor
    enum DataSerializerEnum implements HotCacheEnum {
        FAST_JSON("fastjson"),
        PROTOBUF("Protobuf"),
        ;
        private final String code;


        /**
         * getHotCacheKeyEnumByCode
         *
         * @param code code
         * @return {@link DataSerializerEnum}
         */
        public static DataSerializerEnum getDataSerializerEnum(String code) {
            return Arrays.stream(DataSerializerEnum.values()).filter(item -> item.getCode().equals(code)).findFirst().orElse(null);
        }
    }

}

```



#### fã€`PathConstants`

```java

/**
 * PathConstants
 *
 * @author zhangyujin
 * @date 2025/11/3
 */
public class PathConstants {

    // å¿«ç…§åˆ†ç‰‡æ–‡ä»¶è·¯å¾„æ ¼å¼
    public static final String SNAPSHOT_FILE_FORMAT = "%s/snapshots/%s_v%s_part_%03d";

    // æ£€æŸ¥ç‚¹æ–‡ä»¶è·¯å¾„æ ¼å¼
    public static final String CHECKPOINT_FILE_FORMAT = "%s/checkpoints/%s_v%s.cp";

    // æ¸…å•æ–‡ä»¶è·¯å¾„æ ¼å¼
    public static final String MANIFEST_FILE_FORMAT = "%s/manifest/%s_v%s_manifest.json";

    // ä¸´æ—¶æ–‡ä»¶åç¼€
    public static final String TEMP_FILE_SUFFIX = ".tmp";

    // Redisé”®æ ¼å¼
    public static final String REDIS_LATEST_KEY_FORMAT = "snapshot:%s:latest";
    public static final String REDIS_INFO_KEY_FORMAT = "snapshot:%s:%s";
  
    // æœ€è¿‘çš„å‡ ä¸ªredisç‰ˆæœ¬ï¼ˆä¿ç•™æœ€è¿‘çš„10ä¸ªç‰ˆæœ¬ï¼‰
    public static final String REDIS_VERSION_KEY_FORMAT = "snapshot:%s:versions";


    // å­˜å‚¨æœåŠ¡æ ¹ç›®å½•
    public static final String STORAGE_ROOT = "snapshots";

    // æ£€æŸ¥ç‚¹å­˜å‚¨ç›®å½•
    public static final String CHECKPOINT_ROOT = "checkpoints";

    // æ¸…å•å­˜å‚¨ç›®å½•
    public static final String MANIFEST_ROOT = "manifest";

    // ä¸´æ—¶æ–‡ä»¶ç›®å½•
    public static final String TEMP_ROOT = "temp";
}

```



### 2ï¼‰åºåˆ—åŒ–æ–¹å¼

#### aã€`DataSerializer`

```java

import java.io.IOException;

/**
 * é€šç”¨åºåˆ—åŒ–æ¥å£ï¼Œå®šä¹‰æ•°æ®çš„è¯»å†™è¡Œä¸ºã€‚
 * æ”¯æŒå¤šç§æ ¼å¼ï¼ˆProtobuf/JSONï¼‰ï¼Œå®ç°è§£è€¦ä¸æ’ä»¶åŒ–ã€‚
 *
 * @param <T> è¦åºåˆ—åŒ–çš„æ•°æ®ç±»å‹ã€‚
 */
public interface DataSerializer<T> {
    /**
     * å°†å•æ¡è®°å½•å†™å…¥è¾“å‡ºæµï¼ˆæ”¯æŒæµå¼å†™å…¥ï¼‰ã€‚
     *
     * @param record è¦å†™å…¥çš„å¯¹è±¡ã€‚
     * @param out è¾“å‡ºæµã€‚
     * @throws IOException å†™å…¥å¤±è´¥æ—¶æŠ›å‡ºå¼‚å¸¸ã€‚
     */
    void write(T record, java.io.OutputStream out) throws java.io.IOException;

    /**
     * ä»è¾“å…¥æµä¸­ååºåˆ—åŒ–ä¸€æ¡è®°å½•ã€‚
     *
     * @param in è¾“å…¥æµã€‚
     * @return ååºåˆ—åŒ–åçš„å¯¹è±¡ã€‚
     * @throws IOException è¯»å–å¤±è´¥æˆ–æ ¼å¼é”™è¯¯æ—¶æŠ›å‡ºã€‚
     */
    T read(java.io.InputStream in) throws java.io.IOException;

    /**
     * å°†å¯¹è±¡åºåˆ—åŒ–ä¸ºå­—èŠ‚æ•°ç»„ã€‚
     *
     * @param record å¾…åºåˆ—åŒ–çš„å¯¹è±¡ã€‚
     * @return å­—èŠ‚æ•°ç»„è¡¨ç¤ºã€‚
     * @throws IOException åºåˆ—åŒ–å¤±è´¥æ—¶æŠ›å‡ºã€‚
     */
    byte[] serialize(T record) throws java.io.IOException;

    /**
     * å°†å­—èŠ‚æ•°ç»„ååºåˆ—åŒ–ä¸ºå¯¹è±¡ã€‚
     *
     * @param data å­—èŠ‚æ•°æ®ã€‚
     * @return ååºåˆ—åŒ–ç»“æœã€‚
     * @throws IOException ååºåˆ—åŒ–å¤±è´¥æ—¶æŠ›å‡ºã€‚
     */
    T deserialize(byte[] data) throws java.io.IOException;
}
```

#### bã€`FastjsonDataSerializer`

```java

import com.alibaba.fastjson.JSON;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;

public class FastjsonDataSerializer<T> implements DataSerializer<T> {
    private final Class<T> clazz;

    public FastjsonDataSerializer(Class<T> clazz) {
        this.clazz = clazz;
    }

    @Override
    public void write(T record, OutputStream out) throws IOException {
        byte[] bytes = serialize(record);
        out.write(bytes);
        out.write('\n');
    }

    @Override
    public T read(InputStream in) throws IOException {
        ByteArrayOutputStream buffer = new ByteArrayOutputStream();
        int b;
        while ((b = in.read()) != -1 && b != '\n') {
            buffer.write(b);
        }
        if (buffer.size() == 0) return null;
        return JSON.parseObject(buffer.toByteArray(), clazz);
    }

    @Override
    public byte[] serialize(T record) throws IOException {
        return JSON.toJSONBytes(record);
    }

    @Override
    public T deserialize(byte[] data) throws IOException {
        return JSON.parseObject(data, clazz);
    }
}
```



#### cã€`ProtobufDataSerializer`

```java

import com.google.protobuf.Message;
import com.google.protobuf.Parser;
import java.io.IOException;
import java.io.OutputStream;

public class ProtobufDataSerializer<T extends Message> implements DataSerializer<T> {
    private final Parser<T> parser;

    public ProtobufDataSerializer(Parser<T> parser) {
        this.parser = parser;
    }

    @Override
    public void write(T record, OutputStream out) throws IOException {
        record.writeDelimitedTo(out);
    }

    @Override
    public T read(java.io.InputStream in) throws IOException {
        return parser.parseDelimitedFrom(in);
    }

    @Override
    public byte[] serialize(T record) throws IOException {
        return record.toByteArray();
    }

    @Override
    public T deserialize(byte[] data) throws IOException {
        return parser.parseFrom(data);
    }
}

```



### 3ï¼‰å…ƒæ•°æ®å¯¹è±¡

#### aã€`SnapshotFileMetadata`

```java


/**
 * å¿«ç…§å…ƒæ•°æ®å¯¹è±¡ï¼Œç”¨äºåœ¨Rediså’Œæ¸…å•æ–‡ä»¶ä¸­å­˜å‚¨ç»Ÿä¸€çš„å…ƒæ•°æ®ä¿¡æ¯
 */

import com.healerjean.proj.hotcache.config.SnapshotDatasetConfig;
import lombok.Data;

import java.util.List;

@Data
public class SnapshotFileMetadata {
    /**
     * æ•°æ®æºåç§°
     */
    private String dataSource;

    /**
     * å¿«ç…§ç‰ˆæœ¬
     */
    private String version;

    /**
     * åˆ›å»ºæ—¶é—´æˆ³
     */
    private long createTime;

    /**
     * è®°å½•æ€»æ•°
     */
    private int recordTotalCount;

    /**
     * é…ç½®ä¿¡æ¯
     */
    private SnapshotDatasetConfig config;

    /**
     * æ–‡ä»¶ä¿¡æ¯åˆ—è¡¨
     */
    private List<FileInfo> files;

    /**
     * æ¸…å•ä¸­å•ä¸ªæ–‡ä»¶çš„å…ƒä¿¡æ¯ã€‚
     */
    @Data
    public static class FileInfo {
        /**
         * æ–‡ä»¶åã€‚
         */
        public String filename;

        /**
         * è¯¥æ–‡ä»¶åŒ…å«çš„è®°å½•æ•°ã€‚
         */
        public int recordCount;

        /**
         * æ–‡ä»¶å¤§å°ï¼ˆå­—èŠ‚ï¼‰ã€‚
         */
        public long fileSize;

        /**
         * æ–‡ä»¶çš„ MD5 æ ¡éªŒå’Œã€‚
         */
        public String md5;
    }
}

```





#### bã€`SnapshotRedisMetadata`

```java

import com.healerjean.proj.hotcache.config.SnapshotDatasetConfig;
import lombok.Data;

/**
 * Redisä¸­å­˜å‚¨çš„å¿«ç…§å…ƒæ•°æ®å¯¹è±¡
 */
@Data
public class SnapshotRedisMetadata {
    /**
     * æ•°æ®æºåç§°
     */
    private String dataSource;

    /**
     * å¿«ç…§ç‰ˆæœ¬
     */
    private String version;

    /**
     * åˆ›å»ºæ—¶é—´æˆ³
     */
    private long createTime;

    /**
     * è®°å½•æ€»æ•°
     */
    private int recordCount;

    /**
     * æ¸…å•æ–‡ä»¶URL
     */
    private String manifestUrl;

    /**
     * é…ç½®ä¿¡æ¯
     */
    private SnapshotDatasetConfig config;
}

```



### 4ï¼‰çº¿ç¨‹æ± å·¥å‚

```java

/**
 * çº¿ç¨‹æ± å·¥å‚ï¼Œæ”¯æŒé€šè¿‡åç§°åˆ›å»ºæˆ–è·å–é¢„å®šä¹‰çº¿ç¨‹æ± ã€‚
 * å¯é…åˆé…ç½®ä¸­å¿ƒåŠ¨æ€é‡å»ºçº¿ç¨‹æ± ã€‚
 *
 * @author zhangyujin
 * @date 2025/11/3
 */
public class ThreadPoolFactory {

    private static final java.util.Map<String, ExecutorService> threadPools = new java.util.HashMap<>();

    static {
        // é¢„åˆ›å»ºé»˜è®¤çº¿ç¨‹æ± 
        createThreadPool("default-pool", 8);
    }

    public static ExecutorService getThreadPool(String poolName) {
        return threadPools.computeIfAbsent(poolName, name -> createThreadPool(name, 4));
    }

    private static ExecutorService createThreadPool(String poolName, int coreSize) {
        ExecutorService executor = Executors.newFixedThreadPool(
                coreSize,
                r -> {
                    Thread t = new Thread(r, "DataLoader-" + poolName);
                    t.setDaemon(true);
                    return t;
                }
        );
        threadPools.put(poolName, executor);
        return executor;
    }

    public static void shutdownAll() {
        for (ExecutorService executor : threadPools.values()) {
            executor.shutdown();
        }
    }
}
```



### 5ï¼‰å­˜å‚¨æœåŠ¡æŠ½è±¡æ¥å£

#### aã€`StorageService`

```java


import java.io.IOException;


/**
 * å­˜å‚¨æœåŠ¡æŠ½è±¡æ¥å£ï¼Œå±è”½åº•å±‚å­˜å‚¨ç»†èŠ‚ï¼ˆå¦‚æœ¬åœ°æ–‡ä»¶ã€OSSã€S3ï¼‰ã€‚
 * ä¾¿äºåœ¨ä¸åŒç¯å¢ƒï¼ˆå¼€å‘ã€æµ‹è¯•ã€ç”Ÿäº§ï¼‰åˆ‡æ¢å®ç°ã€‚
 */
public interface StorageService {
    /**
     * è·å–æŒ‡å®šæ–‡ä»¶åçš„è¾“å‡ºæµï¼Œç”¨äºå†™å…¥æ•°æ®ã€‚
     * @param filename æ–‡ä»¶åã€‚
     * @return è¾“å‡ºæµã€‚
     * @throws IOException è·å–å¤±è´¥æ—¶æŠ›å‡ºã€‚
     */
    java.io.OutputStream getOutputStream(String filename) throws IOException;

    /**
     * å°†ä¸´æ—¶æ–‡ä»¶å‘å¸ƒä¸ºæœ€ç»ˆæ–‡ä»¶ï¼Œç¡®ä¿åŸå­æ€§ã€‚
     * @param tempFilename ä¸´æ—¶æ–‡ä»¶åã€‚
     * @param finalFilename æœ€ç»ˆæ–‡ä»¶åã€‚
     * @throws IOException å‘å¸ƒå¤±è´¥æ—¶æŠ›å‡ºã€‚
     */
    void publish(String tempFilename, String finalFilename) throws IOException;

    /**
     * åˆ—å‡ºæŒ‡å®šå‰ç¼€çš„æ‰€æœ‰æ–‡ä»¶ã€‚
     * @param prefix æ–‡ä»¶å‰ç¼€ã€‚
     * @return æ–‡ä»¶ååˆ—è¡¨ã€‚
     * @throws IOException åˆ—å‡ºå¤±è´¥æ—¶æŠ›å‡ºã€‚
     */
    java.util.List<String> listFiles(String prefix) throws IOException;

    /**
     * æ£€æŸ¥æ–‡ä»¶æ˜¯å¦å­˜åœ¨ã€‚
     * @param filename æ–‡ä»¶åã€‚
     * @return true è¡¨ç¤ºå­˜åœ¨ã€‚
     * @throws IOException æ£€æŸ¥å¤±è´¥æ—¶æŠ›å‡ºã€‚
     */
    boolean exists(String filename) throws IOException;

    /**
     * è·å–æ–‡ä»¶å¤§å°ã€‚
     * @param filename æ–‡ä»¶åã€‚
     * @return æ–‡ä»¶å¤§å°ï¼ˆå­—èŠ‚ï¼‰ã€‚
     * @throws IOException è·å–å¤±è´¥æ—¶æŠ›å‡ºã€‚
     */
    long getFileSize(String filename) throws IOException;

    /**
     * è®¡ç®—å¹¶è¿”å›æ–‡ä»¶çš„ MD5 æ ¡éªŒå’Œã€‚
     * @param filename æ–‡ä»¶åã€‚
     * @return MD5 å­—ç¬¦ä¸²ã€‚
     * @throws IOException è®¡ç®—å¤±è´¥æ—¶æŠ›å‡ºã€‚
     */
    String getFileMd5(String filename) throws IOException;

    /**
     * ä¸‹è½½æ–‡ä»¶å¹¶è¿”å›è¾“å…¥æµã€‚
     * @param filename æ–‡ä»¶åã€‚
     * @return æ–‡ä»¶è¾“å…¥æµã€‚
     * @throws IOException ä¸‹è½½å¤±è´¥æ—¶æŠ›å‡ºã€‚
     */
    java.io.InputStream download(String filename) throws IOException;

    /**
     * åˆ é™¤æŒ‡å®šæ–‡ä»¶ã€‚
     * @param filename æ–‡ä»¶åã€‚
     * @throws IOException åˆ é™¤å¤±è´¥æ—¶æŠ›å‡ºã€‚
     */
    void delete(String filename) throws IOException;
}

```



#### bã€`LocalStorageService`

```java

import com.healerjean.proj.hotcache.constants.PathConstants;
import com.healerjean.proj.hotcache.storage.StorageService;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Component;

import java.io.BufferedOutputStream;
import java.io.FileOutputStream;
import java.io.InputStream;
import java.io.OutputStream;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardCopyOption;
import java.util.List;
import java.util.stream.Collectors;
import java.util.stream.Stream;

/**
 * æœ¬åœ°æ–‡ä»¶ç³»ç»Ÿå®ç°çš„å­˜å‚¨æœåŠ¡ã€‚
 * é€‚ç”¨äºå¼€å‘å’Œé›†æˆæµ‹è¯•åœºæ™¯ã€‚
 */
@Component
public class LocalStorageService implements StorageService {
    private static final Logger log = LoggerFactory.getLogger(LocalStorageService.class);
    public static final Path SNAPSHOT_DIR = Paths.get("/Users/zhangyujin1/Desktop/logs/hotcache", "/tmp");

    static {
        try {
            Files.createDirectories(SNAPSHOT_DIR);
        } catch (java.io.IOException e) {
            throw new RuntimeException("åˆ›å»ºæœ¬åœ°ç›®å½•å¤±è´¥", e);
        }
    }

    @Override
    public OutputStream getOutputStream(String filename) throws java.io.IOException {
        Path tempFile = SNAPSHOT_DIR.resolve(filename + PathConstants.TEMP_FILE_SUFFIX);
        // ç¡®ä¿çˆ¶ç›®å½•å­˜åœ¨
        Path parent = tempFile.getParent();
        if (parent != null) {
            Files.createDirectories(parent);
        }
        return new BufferedOutputStream(new FileOutputStream(tempFile.toFile()));
    }

    @Override
    public void publish(String tempFilename, String finalFilename) throws java.io.IOException {
        Path temp = SNAPSHOT_DIR.resolve(tempFilename);
        Path target = SNAPSHOT_DIR.resolve(finalFilename);
        Files.move(temp, target, StandardCopyOption.REPLACE_EXISTING);
    }

    @Override
    public List<String> listFiles(String prefix) throws java.io.IOException {
        try (Stream<Path> stream = Files.walk(SNAPSHOT_DIR, 5)) {
            return stream
                    .filter(path -> path.getFileName().toString().startsWith(prefix))
                    .map(path -> path.getFileName().toString())
                    .collect(Collectors.toList());
        }
    }

    @Override
    public boolean exists(String filename) throws java.io.IOException {
        return Files.exists(SNAPSHOT_DIR.resolve(filename));
    }

    @Override
    public long getFileSize(String filename) throws java.io.IOException {
        return Files.size(SNAPSHOT_DIR.resolve(filename));
    }

    @Override
    public String getFileMd5(String filename) throws java.io.IOException {
        Path path = SNAPSHOT_DIR.resolve(filename);
        try (InputStream is = Files.newInputStream(path)) {
            return org.apache.commons.codec.digest.DigestUtils.md5Hex(is);
        }
    }

    @Override
    public InputStream download(String filename) throws java.io.IOException {
        return Files.newInputStream(SNAPSHOT_DIR.resolve(filename));
    }

    @Override
    public void delete(String filename) throws java.io.IOException {
        Files.deleteIfExists(SNAPSHOT_DIR.resolve(filename));
    }
}

```

#### cã€`OssStorageService`

```java

import com.aliyun.oss.OSS;
import com.aliyun.oss.OSSClientBuilder;
import com.aliyun.oss.model.OSSObject;
import com.aliyun.oss.model.OSSObjectSummary;
import com.healerjean.proj.hotcache.storage.StorageService;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.*;
import java.security.DigestInputStream;
import java.security.MessageDigest;
import java.util.List;
import java.util.stream.Collectors;
import java.util.stream.Stream;

public class OssStorageService implements StorageService {
    private static final Logger log = LoggerFactory.getLogger(OssStorageService.class);
    private final OSS ossClient;
    private final String bucketName;
    private final String tempDir;

    public OssStorageService(String endpoint, String accessKeyId, String secretAccessKey, String bucketName) {
        this.ossClient = new OSSClientBuilder().build(endpoint, accessKeyId, secretAccessKey);
        this.bucketName = bucketName;
        this.tempDir = System.getProperty("java.io.tmpdir", "/tmp");
    }

    @Override
    public OutputStream getOutputStream(String filename) throws IOException {
        File tmp = new File(tempDir, filename + ".tmp");
        return new FileOutputStream(tmp);
    }

    @Override
    public void publish(String tempFilename, String finalFilename) throws IOException {
        File tmpFile = new File(tempDir, tempFilename);
        if (!tmpFile.exists()) throw new IOException("Temp file not found: " + tmpFile);

        ossClient.putObject(bucketName, finalFilename, tmpFile);
        if (!tmpFile.delete()) log.warn("Failed to delete temp file: " + tmpFile);
    }

    @Override
    public List<String> listFiles(String prefix) throws IOException {
        try ( Stream<OSSObjectSummary> objects = ossClient.listObjects(bucketName, prefix).getObjectSummaries().stream()) {
            return objects.map(OSSObjectSummary::getKey).collect(Collectors.toList());
        } catch (Exception e) {
            throw new IOException("List files failed", e);
        }
    }

    @Override
    public boolean exists(String filename) throws IOException {
        try {
            return ossClient.doesObjectExist(bucketName, filename);
        } catch (Exception e) {
            throw new IOException("Check exists failed", e);
        }
    }

    @Override
    public long getFileSize(String filename) throws IOException {
        try {
            OSSObject obj = ossClient.getObject(bucketName, filename);
            long size = obj.getObjectMetadata().getContentLength();
            obj.close();
            return size;
        } catch (Exception e) {
            throw new IOException("Get file size failed", e);
        }
    }

    @Override
    public String getFileMd5(String filename) throws IOException {
        try (OSSObject obj = ossClient.getObject(bucketName, filename);
             DigestInputStream dis = new DigestInputStream(obj.getObjectContent(), MessageDigest.getInstance("MD5"))) {
            byte[] buffer = new byte[8192];
            while (dis.read(buffer) != -1);
            byte[] digest = dis.getMessageDigest().digest();
            StringBuilder sb = new StringBuilder();
            for (byte b : digest) sb.append(String.format("%02x", b));
            return sb.toString();
        } catch (Exception e) {
            throw new IOException("Compute MD5 failed", e);
        }
    }

    @Override
    public InputStream download(String filename) throws IOException {
        try {
            OSSObject obj = ossClient.getObject(bucketName, filename);
            return obj.getObjectContent();
        } catch (Exception e) {
            throw new IOException("Download failed", e);
        }
    }

    @Override
    public void delete(String filename) throws IOException {
        try {
            ossClient.deleteObject(bucketName, filename);
        } catch (Exception e) {
            throw new IOException("Delete failed", e);
        }
    }

    public void shutdown() {
        if (ossClient != null) ossClient.shutdown();
    }
}
```



### 6ï¼‰æ•°æ®é›†ç¤ºä¾‹å¯¹è±¡

#### aã€`UserTag`

```java
@Data
public class UserTag {
    /**
     * userId
     */
    private String userId;

    /**
     * tags
     */
    private Map<String, String> tags;

}
```



### 7ï¼‰æ•°æ®é›†æä¾›è€…

#### aã€`SnapshotDataProvider`

```java
/**
 * å¿«ç…§æ•°æ®æä¾›è€…æ¥å£ï¼Œå®šä¹‰äº†æ‰€æœ‰å¯ç”Ÿæˆå¿«ç…§çš„æ•°æ®å®ä½“å¿…é¡»å®ç°çš„æ–¹æ³•ã€‚
 * é¿å…ä¸ javax.sql.DataSource å†²çªã€‚
 *
 * @param <T> æ•°æ®å®ä½“çš„æ³›å‹ç±»å‹ï¼Œä¾‹å¦‚ UserTag, ItemProfileã€‚
 */
public interface SnapshotDataProvider<T> {

    /**
     * åˆ†é¡µåŠ è½½ä¸€æ‰¹æ•°æ®è®°å½•ã€‚
     */
    List<T> loadBatch(Object lastKey);

    /**
     * ä»æ•°æ®å®ä½“ä¸­æå–ç”¨äºåˆ†ç‰‡çš„ä¸šåŠ¡ä¸»é”®ã€‚
     */
    Object extractKey(T record);

    /**
     * é¢„ä¼°å½“å‰æ•°æ®æºçš„æ€»è®°å½•æ•°ï¼Œç”¨äºæœ€ç»ˆå®Œæ•´æ€§æ ¡éªŒã€‚
     */
    long estimateTotalCount();
}
```

#### bã€`UserTagInDatasetProvider`

```java

import com.healerjean.proj.hotcache.data.UserTag;
import com.healerjean.proj.hotcache.providor.SnapshotDataProvider;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Component;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * UserTagDataSource
 *
 * @author zhangyujin
 * @date 2025/11/3
 */
@Component("user_tag")
@Slf4j
public class UserTagInDatasetProvider implements SnapshotDataProvider<UserTag> {

    @Override
    public List<UserTag> loadBatch(Object lastKey) {
        // æ¨¡æ‹Ÿä»æ•°æ®åº“åŠ è½½æ•°æ®
        List<UserTag> batch = new ArrayList<>();
        String startId = lastKey != null ? (String) lastKey : "0";
        long start = Long.parseLong(startId);
        long estimateTotalCount = estimateTotalCount();
        // æ¨¡æ‹ŸåŠ è½½100ä¸‡æ¡æ•°æ®
        if (start >= estimateTotalCount) {
            return new ArrayList<>();
        }

        int batchSize = 10000;
        for (int i = 0; i < batchSize && (start + i + 1) <= estimateTotalCount; i++) {
            String userId = String.format("%010d", start + i + 1);
            Map<String, String> tags = new HashMap<>();
            tags.put("age", String.valueOf(20 + ((start + i) % 50)));
            tags.put("gender", ((start + i) % 2 == 0) ? "M" : "F");
            tags.put("city", "City" + (((start + i) % 100) + 1));
            tags.put("level", "Level" + (((start + i) % 5) + 1));
            UserTag userTag = new UserTag();
            userTag.setUserId(userId);
            userTag.setTags(tags);
            batch.add(userTag);
        }

        log.debug("åŠ è½½æ‰¹æ¬¡: start={}, size={}", startId, batch.size());
        return batch;
    }

    @Override
    public Object extractKey(UserTag record) {
        return record.getUserId();
    }

    /**
     * æ¨¡æ‹Ÿæ€»æ•°
     */
    @Override
    public long estimateTotalCount() {
        return 5000002L;
    }
}

```



### 8ï¼‰åˆ†ç‰‡å†™å…¥

#### aã€`ShardWriter`

```java

import com.healerjean.proj.hotcache.constants.PathConstants;
import com.healerjean.proj.hotcache.serializer.DataSerializer;
import com.healerjean.proj.hotcache.storage.StorageService;
import lombok.extern.slf4j.Slf4j;

import java.io.IOException;

/**
 * å•ä¸ªåˆ†ç‰‡æ–‡ä»¶çš„å†™å…¥å™¨ï¼Œè´Ÿè´£å°†æ•°æ®å†™å…¥ç‰¹å®š shardã€‚
 * æ”¯æŒ GZIP å‹ç¼©ï¼Œå¹¶ç¡®ä¿ä¸´æ—¶æ–‡ä»¶åŸå­å‘å¸ƒã€‚
 *
 * @param <T> æ•°æ®ç±»å‹ã€‚
 */
@Slf4j
public class ShardWriter<T> implements java.io.Closeable {
    private final int shardId;
    private final String filename;
    private final StorageService storage;
    private final DataSerializer<T> serializer;
    private java.io.OutputStream outputStream;
    private boolean closed = false;
    private final java.util.concurrent.atomic.AtomicInteger recordCount = new java.util.concurrent.atomic.AtomicInteger(0);

    /**
     * æ„é€ å‡½æ•°ã€‚
     *
     * @param shardId åˆ†ç‰‡ç¼–å·ï¼ˆ0 ~ N-1ï¼‰ã€‚
     * @param filename è¾“å‡ºæ–‡ä»¶åã€‚
     * @param storage å­˜å‚¨æœåŠ¡ã€‚
     * @param serializer åºåˆ—åŒ–å™¨ã€‚
     * @param compress æ˜¯å¦å‹ç¼©
     * @throws IOException åˆå§‹åŒ–å¤±è´¥æ—¶æŠ›å‡ºã€‚
     */
    public ShardWriter(int shardId, String filename, StorageService storage, DataSerializer<T> serializer, boolean compress) throws IOException {
        this.shardId = shardId;
        this.filename = filename;
        this.storage = storage;
        this.serializer = serializer;

        // æ ¹æ®é…ç½®å†³å®šæ˜¯å¦ä½¿ç”¨å‹ç¼©
        java.io.OutputStream rawStream = storage.getOutputStream(filename);
        if (compress) {
            this.outputStream = new java.util.zip.GZIPOutputStream(rawStream);
        } else {
            this.outputStream = rawStream;
        }
    }

    /**
     * æ·»åŠ ä¸€æ¡è®°å½•åˆ°å½“å‰åˆ†ç‰‡ã€‚
     *
     * @param record è¦å†™å…¥çš„è®°å½•ã€‚
     * @throws IOException å†™å…¥å¤±è´¥æ—¶æŠ›å‡ºã€‚
     */
    public void add(T record) throws IOException {
        if (closed) throw new IOException("ShardWriter å·²å…³é—­ï¼Œæ— æ³•ç»§ç»­å†™å…¥");
        serializer.write(record, outputStream);
        recordCount.incrementAndGet();
    }

    @Override
    public void close() throws IOException {
        if (closed) return;
        try {
            outputStream.flush();
        } finally {
            try {
                outputStream.close();
            } finally {
                closed = true;
            }
        }
        storage.publish(filename + PathConstants.TEMP_FILE_SUFFIX, filename);
    }

    /**
     * è·å–å½“å‰åˆ†ç‰‡å·²å†™å…¥çš„è®°å½•æ€»æ•°ã€‚
     *
     * @return æ¡æ•°ã€‚
     */
    public int getRecordCount() { return recordCount.get(); }

    public String getFilename() { return filename; }
}

```



#### bã€`ShardWriterManager`

```java


import com.healerjean.proj.hotcache.config.DatasetRunConfig;
import com.healerjean.proj.hotcache.config.SnapshotDatasetConfig;
import com.healerjean.proj.hotcache.constants.PathConstants;
import com.healerjean.proj.hotcache.factory.ThreadPoolFactory;
import com.healerjean.proj.hotcache.serializer.DataSerializer;
import com.healerjean.proj.hotcache.storage.StorageService;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;

import java.io.IOException;
import java.util.List;
import java.util.concurrent.CompletableFuture;

/**
 * åˆ†ç‰‡å†™å…¥å™¨çš„ç»Ÿä¸€ç®¡ç†å™¨ã€‚
 * è´Ÿè´£åˆ›å»ºã€è·å–å’Œæ‰¹é‡å…³é—­ ShardWriterã€‚
 *
 * @author zhangyujin
 * @date 2025-11-04 09:11:53
 */
@Slf4j
public class ShardWriterManager<T> {

    @Getter
    private final List<ShardWriter<T>> writers;
    private final int shardCount;
    private final java.util.concurrent.ExecutorService writerPool;

    public ShardWriterManager(String name, String version, DatasetRunConfig runConfig, StorageService storage) throws IOException {
        SnapshotDatasetConfig config = runConfig.getSnapshotDatasetConfig();
        this.shardCount = config.getShardCount();
        this.writers = createWriters(name, version, config, storage, (DataSerializer<T>) runConfig.getDataSerializer());

        // ä½¿ç”¨æ•°æ®é›†ç‰¹å®šçš„çº¿ç¨‹æ± 
        String threadPoolName = config.getThreadPool();
        this.writerPool = ThreadPoolFactory.getThreadPool(threadPoolName);
    }

    private List<ShardWriter<T>> createWriters(String name, String version, SnapshotDatasetConfig cfg, StorageService storage, DataSerializer<T> serializer) throws IOException {
        List<ShardWriter<T>> ws = new java.util.ArrayList<>(shardCount);

        for (int i = 0; i < shardCount; i++) {
            String filename = String.format(PathConstants.SNAPSHOT_FILE_FORMAT, name, name, version, i);
            ws.add(new ShardWriter<>(i, filename, storage, serializer, cfg.getCompress()));
        }
        return ws;
    }

    /**
     * å°†ä¸€æ¡è®°å½•åˆ†å‘åˆ°å¯¹åº”çš„åˆ†ç‰‡ã€‚
     */
    public void distribute(T record, Object key) throws IOException {
        int shardId = Math.abs(key.hashCode()) % shardCount;
        writers.get(shardId).add(record);
    }

    /**
     * å¹¶è¡Œå…³é—­æ‰€æœ‰å†™å…¥å™¨ã€‚
     */
    public void closeAllInParallel() {
        CompletableFuture.allOf(writers.stream()
                .map(writer -> CompletableFuture.runAsync(() -> {
                    try {
                        writer.close();
                    } catch (IOException e) {
                        log.error("å…³é—­ ShardWriter å¤±è´¥: {}", e.getMessage(), e);
                        throw new RuntimeException(e);
                    }
                }, writerPool)).toArray(CompletableFuture[]::new)).join();
    }

}
```





### 9ï¼‰æ–­ç‚¹ç»­ä¼ æ§åˆ¶å™¨

#### aã€`Checkpoint`

```java

/**
 * å¿«ç…§ä»»åŠ¡æ–­ç‚¹çŠ¶æ€ï¼ŒæŒä¹…åŒ–ä»¥æ”¯æŒä¸­æ–­åæ¢å¤ã€‚
 *
 * å­˜å‚¨å†…å®¹åŒ…æ‹¬ï¼š
 * - æœ€åå¤„ç†çš„ä¸»é”®
 * - å·²æˆåŠŸå†™å…¥æ¡æ•°
 * - æ›´æ–°æ—¶é—´æˆ³
 *
 * æ–‡ä»¶å­˜å‚¨è·¯å¾„æ ¼å¼ï¼šcheckpoints/{datasetName}_v{version}.cp
 *
 * @author zhangyujin
 * @date 2025/11/3
 */
@Data
public class Checkpoint {

    /**
     * å¿«ç…§ç‰ˆæœ¬å·ï¼ˆé€šå¸¸ä¸ºæ—¶é—´æˆ³ï¼‰
     */
    private String version;

    /**
     * ä¸Šä¸€æ¬¡å·²å¤„ç†çš„æœ€åä¸€æ¡è®°å½•ä¸»é”®ï¼ˆå­—ç¬¦ä¸²å½¢å¼ï¼‰
     */
    private String lastKey;

    /**
     * å·²æˆåŠŸåˆ†å¸ƒå¹¶å†™å…¥çš„è®°å½•æ€»æ•°
     */
    private int processedCount;

    /**
     * æ–­ç‚¹æœ€åæ›´æ–°æ—¶é—´ï¼ˆæ¯«ç§’æ—¶é—´æˆ³ï¼‰
     */
    private long updateTime;

    /**
     * æ„é€ å‡½æ•°
     */
    public Checkpoint() {}

    public Checkpoint(String version, String lastKey, int processedCount) {
        this.version = version;
        this.lastKey = lastKey;
        this.processedCount = processedCount;
        this.updateTime = System.currentTimeMillis();
    }
}
```

#### bã€`CheckpointManager`

```java


import com.healerjean.proj.hotcache.constants.PathConstants;
import com.healerjean.proj.hotcache.storage.StorageService;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Component;

/**
 * æ–­ç‚¹ç»­ä¼ æ§åˆ¶å™¨ï¼ŒæŒä¹…åŒ–ä»»åŠ¡è¿›åº¦ä»¥ä¾¿ä¸­æ–­åæ¢å¤ã€‚
 * å­˜å‚¨ lastKey å’Œå·²å†™å…¥æ¡æ•°ï¼Œé˜²æ­¢é‡å¤å¤„ç†ã€‚
 */
@Slf4j
@Component
public class CheckpointManager {
    private final StorageService storage;

    public CheckpointManager(StorageService storage) {
        this.storage = storage;
    }



    /**
     * åŠ è½½æŒ‡å®šæ•°æ®æºå’Œç‰ˆæœ¬çš„æ£€æŸ¥ç‚¹ä¿¡æ¯ã€‚
     *
     * @param datasetName æ•°æ®æºåç§°ã€‚
     * @param version å¿«ç…§ç‰ˆæœ¬å·ã€‚
     * @return Checkpoint å¯¹è±¡ï¼›è‹¥ä¸å­˜åœ¨åˆ™è¿”å› nullã€‚
     */
    public Checkpoint load(String datasetName, String version) {
        String path = String.format(PathConstants.CHECKPOINT_FILE_FORMAT, datasetName, datasetName, version);        try {
            if (!storage.exists(path)) {
                log.info("æ£€æŸ¥ç‚¹æ–‡ä»¶ä¸å­˜åœ¨: {}", path);
                return null;
            }
        } catch (Exception e) {
            log.warn("è¯»å– checkpoint å¤±è´¥: è·¯å¾„={}, é”™è¯¯={}", path, e.getMessage());
            return null;
        }

        try (java.io.InputStreamReader reader = new java.io.InputStreamReader(storage.download(path))) {
            com.google.gson.Gson gson = new com.google.gson.Gson();
            return gson.fromJson(reader, Checkpoint.class);
        } catch (Exception e) {
            log.warn("è¯»å– checkpoint å¤±è´¥: è·¯å¾„={}, é”™è¯¯={}", path, e.getMessage());
            return null;
        }
    }


    /**
     * ä¿å­˜å½“å‰å¤„ç†è¿›åº¦ã€‚
     *
     * @param datasetName æ•°æ®æºåç§°ã€‚
     * @param version ç‰ˆæœ¬å·ã€‚
     * @param lastKey å·²å¤„ç†åˆ°æœ€åä¸€æ¡è®°å½•çš„é”®ã€‚
     * @param totalCount å·²æˆåŠŸå†™å…¥çš„æ€»è®°å½•æ•°ã€‚
     */
    public void save(String datasetName, String version, Object lastKey, int totalCount) throws java.io.IOException {
        Checkpoint cp = new Checkpoint();
        cp.setVersion(version);
        cp.setLastKey(String.valueOf(lastKey));
        cp.setProcessedCount(totalCount);
        cp.setUpdateTime(System.currentTimeMillis());

        com.google.gson.Gson gson = new com.google.gson.Gson();
        String json = gson.toJson(cp);
        String path = String.format(PathConstants.CHECKPOINT_FILE_FORMAT, datasetName, datasetName, version);

        try (java.io.OutputStream os = storage.getOutputStream(path)) {
            os.write(json.getBytes(java.nio.charset.StandardCharsets.UTF_8));
        }
        storage.publish(path + PathConstants.TEMP_FILE_SUFFIX, path);

        log.debug("ä¿å­˜æ£€æŸ¥ç‚¹: dataset={}, version={}, processed={}", datasetName, version, totalCount);
    }

}
```





### 10ï¼‰å…ƒæ•°æ®å‘å¸ƒåˆ° `redis` `SnapshotPublisher`

```java


import com.healerjean.proj.hotcache.config.SnapshotDatasetConfig;
import com.healerjean.proj.hotcache.constants.PathConstants;
import com.healerjean.proj.hotcache.metadata.SnapshotFileMetadata;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.redis.core.StringRedisTemplate;
import org.springframework.stereotype.Component;

import java.util.concurrent.TimeUnit;

/**
 * å°†å¿«ç…§å…ƒæ•°æ®å‘å¸ƒåˆ° Redisï¼Œä¾›ä¸‹æ¸¸æœåŠ¡å‘ç°æœ€æ–°ç‰ˆæœ¬ã€‚
 */
@Component
public class SnapshotPublisher {

    @Autowired
    private StringRedisTemplate redisTemplate;

    /**
     * å‘å¸ƒå¿«ç…§ä¿¡æ¯è‡³ Redisã€‚
     * ä½¿ç”¨ç»Ÿä¸€çš„å…ƒæ•°æ®å¯¹è±¡ç»“æ„
     */
    public void publish(String dataSource, String version, long startTime, int totalRecords, SnapshotDatasetConfig config) {
        // è®°å½•æœ€æ–°çš„ç‰ˆæœ¬
        String latestKey = String.format(PathConstants.REDIS_LATEST_KEY_FORMAT, dataSource);
        redisTemplate.opsForValue().set(latestKey, version);


        // è®°å½•æœ€è¿‘çš„10ä¸ªç‰ˆæœ¬
        String versionsKey = String.format(PathConstants.REDIS_VERSION_KEY_FORMAT, dataSource);
        redisTemplate.opsForList().leftPush(versionsKey, version);
        redisTemplate.opsForList().trim(versionsKey, 0, 9);

        // å°†å¯¹è±¡åºåˆ—åŒ–ä¸ºJSONå¹¶å­˜å‚¨åˆ°Redis
        SnapshotFileMetadata metadata = new SnapshotFileMetadata();
        metadata.setDataSource(dataSource);
        metadata.setVersion(version);
        metadata.setCreateTime(startTime);
        metadata.setRecordTotalCount(totalRecords);
        metadata.setConfig(config);
        com.google.gson.Gson gson = new com.google.gson.Gson();
        String metadataJson = gson.toJson(metadata);
        String infoKey = String.format(PathConstants.REDIS_INFO_KEY_FORMAT, dataSource, version);
        redisTemplate.opsForValue().set(infoKey, metadataJson);

        redisTemplate.expire(latestKey, 7, TimeUnit.DAYS);
        redisTemplate.expire(infoKey, 7, TimeUnit.DAYS);

        System.out.printf("âœ… å¿«ç…§å·²å‘å¸ƒåˆ° Redis: %s, ç‰ˆæœ¬=%s%n", dataSource, version);
    }
}

```



### 11ï¼‰å®šæœŸæ¸…ç† `SnapshotCleanupService`

```java

import com.healerjean.proj.hotcache.storage.StorageService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

import java.io.IOException;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * å®šæœŸæ¸…ç†è¿‡æœŸå¿«ç…§æ–‡ä»¶å’Œæ£€æŸ¥ç‚¹ï¼Œé‡Šæ”¾å­˜å‚¨ç©ºé—´ã€‚
 */
@Component
public class SnapshotCleanupService {

    @Autowired
    private StorageService storage;
    private static final Pattern VERSION_PATTERN = Pattern.compile("_v(\\d+)");

    /**
     * æ¸…ç†æ—©äº currentVersion çš„å†å²å¿«ç…§ã€‚
     *
     * @param dataSource æ•°æ®æºåã€‚
     * @param currentVersion å½“å‰ç‰ˆæœ¬ã€‚
     */
    public void cleanupOld(String dataSource, long currentVersion) {
        try {
            // æ¸…ç†æ£€æŸ¥ç‚¹æ–‡ä»¶
            String checkpointPrefix = String.format("%s/checkpoints/%s_v", dataSource, dataSource);
            for (String file : storage.listFiles(checkpointPrefix)) {
                Long ver = extractVersion(file);
                if (ver != null && ver < currentVersion) {
                    storage.delete(file);
                    System.out.println("ğŸ—‘ï¸ åˆ é™¤æ—§æ£€æŸ¥ç‚¹æ–‡ä»¶: " + file);
                }
            }

            // æ¸…ç†æ¸…å•æ–‡ä»¶
            String manifestPrefix = String.format("%s/manifest/%s_v", dataSource, dataSource);
            for (String file : storage.listFiles(manifestPrefix)) {
                Long ver = extractVersion(file);
                if (ver != null && ver < currentVersion) {
                    storage.delete(file);
                    System.out.println("ğŸ—‘ï¸ åˆ é™¤æ—§æ¸…å•æ–‡ä»¶: " + file);
                }
            }

            // æ¸…ç†å¿«ç…§åˆ†ç‰‡æ–‡ä»¶
            String snapshotPrefix = String.format("%s/snapshots/%s_v", dataSource, dataSource);
            for (String file : storage.listFiles(snapshotPrefix)) {
                Long ver = extractVersion(file);
                if (ver != null && ver < currentVersion) {
                    storage.delete(file);
                    System.out.println("ğŸ—‘ï¸ åˆ é™¤æ—§å¿«ç…§åˆ†ç‰‡: " + file);
                }
            }

        } catch (IOException e) {
            System.err.println("æ¸…ç†å¤±è´¥: " + e.getMessage());
        }
    }

    private Long extractVersion(String filename) {
        Matcher m = VERSION_PATTERN.matcher(filename);
        return m.find() ? Long.parseLong(m.group(1)) : null;
    }
}
```

### 12ï¼‰ç”Ÿæˆå¿«ç…§çš„æ¸…å•æ–‡ä»¶  `ManifestGenerator`

```java

import com.google.gson.Gson;
import com.healerjean.proj.hotcache.config.SnapshotDatasetConfig;
import com.healerjean.proj.hotcache.constants.PathConstants;
import com.healerjean.proj.hotcache.metadata.SnapshotFileMetadata;
import com.healerjean.proj.hotcache.storage.StorageService;
import com.healerjean.proj.hotcache.write.ShardWriter;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

import java.io.IOException;
import java.io.OutputStream;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.List;

/**
 * ç”Ÿæˆå¿«ç…§çš„æ¸…å•æ–‡ä»¶ï¼ˆmanifest.jsonï¼‰ï¼ŒåŒ…å«æ‰€æœ‰åˆ†ç‰‡æ–‡ä»¶çš„å…ƒä¿¡æ¯å’Œæ ¡éªŒå’Œã€‚
 * è¿™æ˜¯æ•°æ®å®Œæ•´æ€§æ ¡éªŒçš„æ ¸å¿ƒã€‚
 */
@Component
public class ManifestGenerator {
    private static final Logger log = LoggerFactory.getLogger(ManifestGenerator.class);
    private static final Gson GSON = new Gson();

    @Autowired
    private StorageService storage;

    /**
     * ç”Ÿæˆæ¸…å•æ–‡ä»¶ã€‚
     * æ­¤æ–¹æ³•ä¼šæ‰§è¡Œå…³é”®çš„ **æ•°æ®å®Œæ•´æ€§æ ¡éªŒ**ï¼š
     * 1. æ£€æŸ¥å®é™…å†™å…¥çš„æ€»è®°å½•æ•°æ˜¯å¦ç­‰äºé¢„æœŸæ€»æ•°ã€‚
     * 2. ä¸ºæ¯ä¸ªæ–‡ä»¶è®¡ç®— MD5 å’Œå¤§å°ã€‚
     *
     * @param dataSource æ•°æ®æºåç§°ã€‚
     * @param version å¿«ç…§ç‰ˆæœ¬ã€‚
     * @param config é…ç½®ä¿¡æ¯
     * @param writers æ‰€æœ‰åˆ†ç‰‡å†™å…¥å™¨åˆ—è¡¨ã€‚
     * @param expectedTotal é¢„æœŸçš„æ€»è®°å½•æ•°ï¼ˆä»æ•°æ®æºé¢„ä¼°æˆ–åŠ è½½å¾—åˆ°ï¼‰ã€‚
     * @throws IOException ç”Ÿæˆæˆ–å†™å…¥å¤±è´¥æ—¶æŠ›å‡ºã€‚
     */
    public void generate(String dataSource, String version, SnapshotDatasetConfig config, List<ShardWriter<?>> writers, int expectedTotal) throws IOException {
        SnapshotFileMetadata metadata = new SnapshotFileMetadata();
        metadata.setDataSource(dataSource);
        metadata.setVersion(version);
        metadata.setCreateTime(System.currentTimeMillis());
        metadata.setRecordTotalCount(expectedTotal);
        metadata.setConfig(config);

        List<SnapshotFileMetadata.FileInfo> files = new ArrayList<>();
        int actualTotal = 0;

        for (ShardWriter<?> w : writers) {
            String filename = w.getFilename();

            SnapshotFileMetadata.FileInfo fi = new SnapshotFileMetadata.FileInfo();
            fi.setFilename(filename);
            fi.setRecordCount(w.getRecordCount());
            fi.setFileSize(storage.getFileSize(filename));
            fi.setMd5(storage.getFileMd5(filename));

            files.add(fi);
            actualTotal += fi.getRecordCount();
        }

        metadata.setFiles(files);

        // **æ ¸å¿ƒæ ¡éªŒï¼šæ•°æ®å®Œæ•´æ€§**
        if (actualTotal != expectedTotal) {
            throw new RuntimeException(
                    String.format("ã€æ•°æ®å®Œæ•´æ€§æ ¡éªŒå¤±è´¥ã€‘è®°å½•æ€»æ•°ä¸ä¸€è‡´ï¼æ•°æ®æº=%s, ç‰ˆæœ¬=%s, é¢„æœŸ=%d, å®é™…=%d",
                            dataSource, version, expectedTotal, actualTotal)
            );
        }

        String json = GSON.toJson(metadata);
        String manifestPath = String.format(PathConstants.MANIFEST_FILE_FORMAT, dataSource, dataSource, version);
        try (OutputStream os = storage.getOutputStream(manifestPath)) {
            os.write(json.getBytes(StandardCharsets.UTF_8));
        }
        storage.publish(manifestPath + PathConstants.TEMP_FILE_SUFFIX, manifestPath);

        log.info("âœ… Manifest ç”Ÿæˆå®Œæˆ: {}, æ€»æ¡æ•°: {}", manifestPath, actualTotal);
    }
}
```



### 13ï¼‰å…¨é‡æ•°æ®åŠ è½½

#### aã€`DataLoader`

```java

import com.healerjean.proj.hotcache.checkpoint.Checkpoint;
import com.healerjean.proj.hotcache.checkpoint.CheckpointManager;
import com.healerjean.proj.hotcache.config.DatasetRunConfig;
import com.healerjean.proj.hotcache.config.SnapshotDatasetConfig;
import com.healerjean.proj.hotcache.factory.ThreadPoolFactory;
import com.healerjean.proj.hotcache.providor.SnapshotDataProvider;
import com.healerjean.proj.hotcache.write.ShardWriterManager;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Component;

import javax.annotation.Resource;
import java.io.IOException;
import java.util.List;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Semaphore;

/**
 * è´Ÿè´£ä»æ•°æ®æºåŠ è½½æ•°æ®ï¼Œå¹¶åˆ†å‘åˆ°åˆ†ç‰‡ç®¡ç†å™¨ã€‚
 * æ”¯æŒæ–­ç‚¹ç»­ä¼ ã€‚
 */
@Slf4j
@Component
public class DataLoader<T> {


    /**
     * checkpointManager
     */
    @Resource
    private CheckpointManager checkpointManager;

    public int loadDataAndDistribute(
            SnapshotDataProvider<T> provider,
            ShardWriterManager<T> writerManager,
            DatasetRunConfig runConfig,
            String version) throws Exception {

        // 1ã€è·å–é…ç½®åŸºæœ¬æ•°æ®
        String datasetName = runConfig.getDatasetName();
        SnapshotDatasetConfig config = runConfig.getSnapshotDatasetConfig();
        int batchSize = config.getBatchSize();
        boolean enableCheckpoint = config.getEnableCheckpoint() != null ? config.getEnableCheckpoint() : true;

        int total = 0;
        Object lastKey = null;

        // 2ã€æŒ‰ç…§ç‰ˆæœ¬æ¢å¤æ–­ç‚¹
        if (enableCheckpoint) {
            Checkpoint cp = checkpointManager.load(datasetName, version);
            if (cp != null) {
                lastKey = cp.getLastKey();
                total = cp.getProcessedCount();
                log.info("æ¢å¤æ–­ç‚¹: dataset={}, lastKey={}, processed={}", datasetName, lastKey, total);
            }
        }

        // 3ã€çº¿ç¨‹æ± ç­‰ç›¸å…³é…ç½®
        ExecutorService dataLoadExecutor = ThreadPoolFactory.getThreadPool(config.getThreadPool());
        Semaphore semaphore = new Semaphore(config.getMaxConcurrent());

        // 3ã€è¿›è¡Œæ•°æ®åŠ è½½
        try {
            while (true) {
                // aã€åŠ è½½ä¸€æ‰¹æ•°æ®
                List<T> batch = provider.loadBatch(lastKey);
                if (batch.isEmpty()) {
                    break;
                }

                // bã€å€’è®¡æ—¶å™¨ï¼Œåˆ¤æ–­çº¿ç¨‹æ± å®Œæˆ
                CountDownLatch latch = new CountDownLatch(batch.size());

                // cã€çº¿ç¨‹æ± ä»»åŠ¡æ‰§è¡Œä¸é™æµæ§åˆ¶
                for (T record : batch) {
                    Object key = provider.extractKey(record);
                    semaphore.acquire();
                    dataLoadExecutor.submit(() -> {
                        try {
                            writerManager.distribute(record, key);
                        } catch (IOException e) {
                            log.error("Failed to write record to shard: {}", e.getMessage(), e);
                            throw new RuntimeException("Failed to write record to shard", e);
                        }finally {
                            // é‡Šæ”¾è®¸å¯
                            semaphore.release();
                            latch.countDown();
                        }
                    });
                }

                // dã€ç­‰å¾…å½“å‰æ‰¹æ¬¡å…¨éƒ¨å®Œæˆï¼ˆç¡®ä¿ total/lastKey æ›´æ–°å‰æ•°æ®å·²å†™å®Œï¼‰
                latch.await();

                // eã€æ¯å¤„ç† 100 ä¸ªæ‰¹æ¬¡ï¼ˆå³ 100 Ã— batchSize æ¡è®°å½•ï¼‰ä¿å­˜ä¸€æ¬¡ã€‚
                total += batch.size();
                lastKey = provider.extractKey(batch.get(batch.size() - 1));
                if (enableCheckpoint && total % (batchSize * 1000) == 0) {
                    checkpointManager.save(datasetName, version, lastKey, total);
                    log.info("ä¿å­˜æ–­ç‚¹: dataset={}, processed={}", datasetName, total);
                }
            }
        } finally {
            // æ— è®ºæˆåŠŸä¸å¦ï¼Œéƒ½å°è¯•ä¿å­˜æœ€ç»ˆæ–­ç‚¹
            if (enableCheckpoint && lastKey != null) {
                checkpointManager.save(datasetName, version, lastKey, total);
                log.info("ä¿å­˜æœ€ç»ˆæ–­ç‚¹: dataset={}, processed={}", datasetName, total);
            }
        }

        return total;
    }
}
```



#### bã€`FullSnapshotGenerator`

```java

import com.healerjean.proj.hotcache.checkpoint.CheckpointManager;
import com.healerjean.proj.hotcache.clearup.SnapshotCleanupService;
import com.healerjean.proj.hotcache.config.DatasetRunConfig;
import com.healerjean.proj.hotcache.config.HotSnapshotConfig;
import com.healerjean.proj.hotcache.manifest.ManifestGenerator;
import com.healerjean.proj.hotcache.providor.SnapshotDataProvider;
import com.healerjean.proj.hotcache.publish.SnapshotPublisher;
import com.healerjean.proj.hotcache.storage.StorageService;
import com.healerjean.proj.hotcache.write.ShardWriterManager;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

import javax.annotation.Resource;
import java.util.Map;

/**
 * å…¨é‡å¿«ç…§ç”Ÿæˆä¸»æµç¨‹æ§åˆ¶å™¨ã€‚
 */
@Slf4j
@Component
public class FullSnapshotGenerator {

    @Autowired
    private StorageService storage;
    @Autowired
    private CheckpointManager checkpointManager;
    @Autowired
    private ManifestGenerator manifestGenerator;
    @Autowired
    private SnapshotPublisher snapshotPublisher;
    @Autowired
    private SnapshotCleanupService cleanupService;
    @Autowired
    private HotSnapshotConfig hotSnapshotConfig;
    @Autowired
    private DataLoader dataLoader;


    /**
     * snapshotDataProviders
     */
    @Resource
    private Map<String, SnapshotDataProvider<?>> snapshotDataProviders;


    public <T> void generate(String datasetName) throws Exception {
        // ç”Ÿæˆç‰ˆæœ¬å·
        String version = String.valueOf(System.currentTimeMillis() / 1000);

        // é€šè¿‡åç§°è·å–æ•°æ®æº
        SnapshotDataProvider<?> dataSource = snapshotDataProviders.get(datasetName);
        if (dataSource == null) {
            throw new IllegalArgumentException("æœªæ‰¾åˆ°æ•°æ®æº: " + datasetName);
        }

        // æ ¹æ®æ•°æ®é›†åç§°è·å–è¿è¡Œé…ç½®
        DatasetRunConfig runConfig = hotSnapshotConfig.instanceRunConfig(datasetName);

        long start = System.currentTimeMillis();
        log.info("ğŸš€ å¼€å§‹ç”Ÿæˆå¿«ç…§: dataset={}, version={}", datasetName, version);

        try {
            // 2. åˆ›å»ºåˆ†ç‰‡ç®¡ç†å™¨
            ShardWriterManager writerManager = new ShardWriterManager<>(datasetName, version, runConfig, storage);

            // 3. åŠ è½½å¹¶åˆ†å‘æ•°æ®
            int total = dataLoader.loadDataAndDistribute(dataSource, writerManager, runConfig, version);

            // 4. å¹¶è¡Œå…³é—­æ‰€æœ‰åˆ†ç‰‡
            writerManager.closeAllInParallel();

            // 5. ç”Ÿæˆæ¸…å•
            manifestGenerator.generate(datasetName, version, runConfig.getSnapshotDatasetConfig(), writerManager.getWriters(), total);

            // 6. å‘å¸ƒåˆ° Redis
            snapshotPublisher.publish(datasetName, version, start, total, runConfig.getSnapshotDatasetConfig());

            // 7. æ¸…ç†æ—§ç‰ˆæœ¬
            cleanupService.cleanupOld(datasetName, Long.parseLong(version));

            log.info("âœ… å¿«ç…§ç”Ÿæˆå®Œæˆ: dataset={}, version={}, records={}, duration={}ms",
                    datasetName, version, total, System.currentTimeMillis() - start);

        } catch (Exception e) {
            log.error("âŒ å¿«ç…§ç”Ÿæˆå¤±è´¥: dataset={}, error={}", datasetName, e.getMessage(), e);
            throw e;
        }
    }


}
```



# äºŒã€å¢é‡å†™å…¥æ–¹æ¡ˆ







# ä¸‰ã€å…¨é‡åŠ è½½æ–¹æ¡ˆ

## 1ã€ä¸‹è½½æ§åˆ¶

- **å®¢æˆ·ç«¯éšæœºå»¶è¿Ÿï¼ˆæœ€ç®€å•æœ‰æ•ˆï¼‰**
  - æ¯å°æœºå™¨æ”¶åˆ°â€œæ–°ç‰ˆæœ¬å¯ç”¨â€é€šçŸ¥åï¼Œ**ä¸æ˜¯ç«‹å³ä¸‹è½½**ï¼Œè€Œæ˜¯éšæœºç­‰å¾… `0 ~ T` ç§’å†å¼€å§‹ã€‚

- **å•æœºé™æµï¼š**åˆ·æ–°æœŸé—´è¿›è¡Œé™æµï¼Œæ¯”å¦‚å¤šåˆ†ç‰‡åŒæ—¶ä¸‹è½½ç­‰

### 1ï¼‰`OSS` å…¨é‡æ‹‰å–

é—®é¢˜1ï¼š`OSS`  èƒ½å¦æ”¯æŒæ•°åƒå°æœºå™¨åŒæ—¶ä¸‹è½½åŒä¸€ä¸ªæ–‡ä»¶ï¼Ÿ

ç­”æ¡ˆï¼šï¼š**å®Œå…¨å¯ä»¥ï¼Œä½†å¿…é¡»ä¼˜åŒ–æ–¹å¼ï¼Œä¸èƒ½5000 å°æœºå™¨åŒæ—¶ä¸‹è½½ï¼Œå¯¼è‡´ æ‰€æœ‰è¯·æ±‚æ‰“åˆ°åŒä¸€ä¸ª `Object`ï¼Œè¿™æ ·ä¼šå¯¼è‡´**

- `OSS` å†…éƒ¨çƒ­ç‚¹ï¼ˆè™½ç„¶ä¼šè‡ªåŠ¨è´Ÿè½½å‡è¡¡ï¼‰
- å‡ºå£å¸¦å®½ç“¶é¢ˆï¼ˆå¦‚æœéƒ½åœ¨ä¸€ä¸ª VPC å‡ºå£ï¼‰
- ä¸‹è½½æ…¢ã€è¶…æ—¶ã€å¤±è´¥ç‡é«˜

é—®é¢˜2ï¼šæ­£ç¡®åšæ³•æ˜¯ä»€ä¹ˆå‘¢ï¼Ÿ   

ç­”æ¡ˆï¼šæ­£ç¡®åšæ³•ï¼š**`OSS` + CDN åŠ é€Ÿï¼ˆæ¨èæ–¹æ¡ˆï¼‰**

- `10GB` æ–‡ä»¶ï¼Œ`CDN` ç¼“å­˜åï¼Œ**`3000` å°æœºå™¨å¯åœ¨ 10 åˆ†é’Ÿå†…å…¨éƒ¨ä¸‹è½½å®Œæˆ**ï¼ˆå¹³å‡ 50MB/sï¼‰
- **`CDN` ç¼“å­˜ç­–ç•¥**ï¼š
  - ç¼“å­˜ `.pb.gz` æ–‡ä»¶ï¼Œ`TTL` è®¾ç½®ä¸º `0`ï¼ˆä¸è‡ªåŠ¨è¿‡æœŸï¼‰
  - æ‰‹åŠ¨è°ƒç”¨ `Refresh` åˆ·æ–°ç¼“å­˜ï¼ˆæ¯æ¬¡å‘å¸ƒæ–°ç‰ˆæœ¬æ—¶ï¼‰
- **`OSS` + `CDN`  å¼€å¯ `HTTPS`**
- **ä½¿ç”¨å†…ç½‘ `CDN`ï¼ˆå¦‚æœæ”¯æŒï¼‰** â†’ æ›´å¿«ã€æ›´ä¾¿å®œ

| ä¼˜åŠ¿                         | è¯´æ˜                                    |
| ---------------------------- | --------------------------------------- |
| **é¦–è¯·æ±‚å›æºï¼Œåç»­å‘½ä¸­ç¼“å­˜** | ç¬¬ä¸€å°æœºå™¨ä¸‹è½½åï¼Œ`CDN` ç¼“å­˜æ•´ä¸ªæ–‡ä»¶    |
| **å°±è¿‘æ¥å…¥ç‚¹ï¼ˆEdgeï¼‰ä¸‹è½½**   | æ¯å°æœºå™¨ä»æœ€è¿‘çš„ `CDN` èŠ‚ç‚¹æ‹‰å–ï¼Œé€Ÿåº¦å¿« |
| **æ”¯æŒç™¾ä¸‡çº§å¹¶å‘ä¸‹è½½**       | `CDN` å¤©ç”Ÿä¸ºé«˜å¹¶å‘è®¾è®¡                  |
| **å‡è½» OSS å‹åŠ›**            | åªæœ‰å°‘é‡å›æºè¯·æ±‚                        |



### 2ï¼‰å®šæ—¶æ‹‰å–

> **`Redis` + è½®è¯¢ï¼ˆç®€å•ï¼Œé€‚åˆå®¹å¿å»¶è¿Ÿï¼‰**

```java
while (true) {
    Long latest = redis.get("latest_snapshot_version");
    if (latest > currentVersion) {
        downloadFromCDN(latest);
        break;
    }
    Thread.sleep(5000); // æ¯ 5 ç§’æŸ¥ä¸€æ¬¡
}
```









# å››ã€å¢é‡åŠ è½½æ–¹æ¡ˆ





# äº”ã€æ•°æ®å¯¹æ¯”æ–¹æ¡ˆ

## 1ã€å¯¹æ¯”ä»€ä¹ˆ

### **1ï¼‰éªŒè¯æ•°æ®ä¸€è‡´æ€§ï¼ˆé˜²ä¸¢ã€é˜²é”™ï¼‰**

> ä½ ä»Šå¤©ç”Ÿæˆäº†ä¸€ä¸ªå…¨é‡å¿«ç…§ `V123456789`ï¼Œæ˜å¤©åˆç”Ÿæˆä¸€ä¸ª `V123457000`

```
// V123456789 çš„ manifest
{
  "version": 123456789,
  "totalRecords": 2345678,
  "shardCount": 100
}

// V123457000 çš„ manifest
{
  "version": 123457000,
  "totalRecords": 2300000,   // âŒ å°‘äº† 4.5 ä¸‡æ¡ï¼
  "shardCount": 99           // âŒ å°‘äº†ä¸€ä¸ªåˆ†ç‰‡ï¼
}
```



### **2ã€å®šä½æ•°æ®å˜åŒ–ï¼ˆè°å˜äº†ï¼Ÿæ€ä¹ˆå˜çš„ï¼Ÿï¼‰**

> ä½ æƒ³çŸ¥é“ï¼š**å“ªäº›ç”¨æˆ·çš„æ ‡ç­¾è¢«æ›´æ–°äº†ï¼Ÿ**æ¯”ä¸¤ä¸ªç‰ˆæœ¬çš„ **æ•°æ®æ–‡ä»¶å†…å®¹**ï¼ˆä¸æ˜¯ `manifest`ï¼Œæ˜¯ `.pb.gz`ï¼‰ã€‚

- ç”¨æˆ·ç”»åƒå˜åŒ–åˆ†æ
- æ•°æ®åŒæ­¥é“¾è·¯æ˜¯å¦å‡†ç¡®
- å®¡è®¡ï¼šè°æ”¹äº†æ•°æ®ï¼Ÿ

| ç”¨æˆ·ID | V123456789 | V123457000 | å˜åŒ–                     |
| ------ | ---------- | ---------- | ------------------------ |
| 1001   | åŸå¸‚: åŒ—äº¬ | åŸå¸‚: ä¸Šæµ· | âœ… æ›´æ–°                   |
| 1002   | æ ‡ç­¾: ç”·   | ï¼ˆæ— ï¼‰     | âŒ åˆ é™¤ï¼ˆå¯èƒ½æ˜¯ç”¨æˆ·æ³¨é”€ï¼‰ |
| 1003   | ï¼ˆæ— ï¼‰     | å…´è¶£: æ¸¸æˆ | â• æ–°å¢                   |

### **3ã€ç°åº¦å‘å¸ƒ & A/B æµ‹è¯•**

ä½ æ”¹äº†æ ‡ç­¾è®¡ç®—é€»è¾‘ï¼Œæƒ³éªŒè¯æ–°æ—§ä¸¤ç‰ˆç»“æœæ˜¯å¦ä¸€è‡´ã€‚

1. ç”¨æ—§é€»è¾‘ç”Ÿæˆå¿«ç…§ A
2. ç”¨æ–°é€»è¾‘ç”Ÿæˆå¿«ç…§ B
3. å¯¹æ¯” A å’Œ B çš„ `manifest`ï¼ˆçœ‹æ€»é‡ï¼‰
4. å¯¹æ¯” A å’Œ B çš„ æ•°æ®å†…å®¹ï¼ˆçœ‹å·®å¼‚ç‡ï¼‰



### 3ï¼‰ä»£ç å®ç°

#### aã€**å¯¹æ¯”ä¸¤ä¸ªç‰ˆæœ¬çš„ `manifest`ï¼Œå¿«é€Ÿå‘ç°å…ƒæ•°æ®å¼‚å¸¸**

```java
import java.util.Map;
import java.util.HashMap;

/**
 * æ¸…å•å¯¹æ¯”å™¨ï¼šç”¨äºæ¯”è¾ƒä¸¤ä¸ªå¿«ç…§ç‰ˆæœ¬çš„å…ƒæ•°æ®å·®å¼‚
 * ç”¨é€”ï¼šç›‘æ§æ•°æ®é‡çªå˜ã€åˆ†ç‰‡ä¸¢å¤±ã€æ–‡ä»¶æŸåç­‰
 */
public class ManifestComparator {

    public static class DiffResult {
        public final long versionA, versionB;
        public final long totalRecordsDiff;
        public final int shardCountDiff;
        public final int missingFiles;     // A æœ‰ B æ²¡æœ‰
        public final int addedFiles;       // B æœ‰ A æ²¡æœ‰
        public final int sizeMismatch;     // åŒåæ–‡ä»¶ size ä¸åŒ
        public final int md5Mismatch;      // åŒåæ–‡ä»¶ md5 ä¸åŒ

        public DiffResult(long versionA, long versionB, long totalRecordsDiff, int shardCountDiff,
                         int missingFiles, int addedFiles, int sizeMismatch, int md5Mismatch) {
            this.versionA = versionA;
            this.versionB = versionB;
            this.totalRecordsDiff = totalRecordsDiff;
            this.shardCountDiff = shardCountDiff;
            this.missingFiles = missingFiles;
            this.addedFiles = addedFiles;
            this.sizeMismatch = sizeMismatch;
            this.md5Mismatch = md5Mismatch;
        }

        public boolean hasError() {
            return missingFiles > 0 || addedFiles > 0 || sizeMismatch > 0 || md5Mismatch > 0;
        }

        public boolean hasWarning() {
            return Math.abs(totalRecordsDiff) > 1000; // æ¡æ•°å˜åŒ–è¶…è¿‡ 1000 è§†ä¸ºè­¦å‘Š
        }

        @Override
        public String toString() {
            return String.format("ManifestDiff[V%dâ†’V%d] totalDiff=%d, shardDiff=%d, " +
                               "missing=%d, added=%d, sizeErr=%d, md5Err=%d]",
                versionA, versionB, totalRecordsDiff, shardCountDiff,
                missingFiles, addedFiles, sizeMismatch, md5Mismatch);
        }
    }

    /**
     * å¯¹æ¯”ä¸¤ä¸ª manifest
     */
    public DiffResult compare(ManifestGenerator.SnapshotManifest manifestA,
                              ManifestGenerator.SnapshotManifest manifestB) {

        long totalRecordsDiff = manifestB.totalRecords - manifestA.totalRecords;
        int shardCountDiff = manifestB.shardCount - manifestA.shardCount;

        Map<String, ManifestGenerator.ManifestEntry> mapA = new HashMap<>();
        for (ManifestGenerator.ManifestEntry e : manifestA.entries) {
            mapA.put(e.filename, e);
        }

        int missing = 0, added = 0, sizeMismatch = 0, md5Mismatch = 0;

        for (ManifestGenerator.ManifestEntry entryB : manifestB.entries) {
            ManifestGenerator.ManifestEntry entryA = mapA.get(entryB.filename);
            if (entryA == null) {
                added++;
            } else {
                if (entryA.size != entryB.size) {
                    sizeMismatch++;
                }
                if (entryA.md5 != null && entryB.md5 != null &&
                    !entryA.md5.equals(entryB.md5)) {
                    md5Mismatch++;
                }
                mapA.remove(entryB.filename);
            }
        }
        missing = mapA.size(); // å‰©ä¸‹çš„éƒ½æ˜¯ A æœ‰ B æ²¡æœ‰

        return new DiffResult(
            manifestA.version, manifestB.version,
            totalRecordsDiff, shardCountDiff,
            missing, added, sizeMismatch, md5Mismatch
        );
    }
}
```



#### bã€**å¯¹æ¯”ä¸¤ä¸ªå¿«ç…§çš„æ•°æ®å†…å®¹ï¼Œåˆ†æå…·ä½“å“ªäº›ç”¨æˆ·æ ‡ç­¾å˜äº†**

```java
import com.example.proto.UserTagProto;
import java.io.InputStream;
import java.util.Map;
import java.util.HashMap;
import java.util.concurrent.atomic.AtomicLong;

/**
 * æ•°æ®å†…å®¹å¯¹æ¯”å·¥å…·
 *
 * åŠŸèƒ½ï¼š
 * - è¯»å–ä¸¤ä¸ªç‰ˆæœ¬çš„åˆ†ç‰‡æ–‡ä»¶ï¼ˆæŒ‰ shardId å¯¹åº”ï¼‰
 * - è§£æ Protobuf æµï¼Œæ„å»º userId â†’ tagId â†’ value æ˜ å°„
 * - å¯¹æ¯”å˜åŒ–ï¼šæ–°å¢ã€åˆ é™¤ã€ä¿®æ”¹
 *
 * æ³¨æ„ï¼šé€‚åˆä¸­å°è§„æ¨¡æ•°æ®ï¼ˆå•åˆ†ç‰‡ < 1GBï¼‰ï¼Œå¤§è§„æ¨¡ç”¨ Spark
 */
public class DataDiffTool {

    private final OssService ossService;

    public DataDiffTool(OssService ossService) {
        this.ossService = ossService;
    }

    public static class DiffStats {
        public final AtomicLong added = new AtomicLong(0);  // æ–°å¢æ ‡ç­¾
        public final AtomicLong removed = new AtomicLong(0); // åˆ é™¤æ ‡ç­¾
        public final AtomicLong changed = new AtomicLong(0); // ä¿®æ”¹æ ‡ç­¾å€¼
        public final AtomicLong same = new AtomicLong(0);    // æœªå˜

        public void log() {
            Log.info("ğŸ“Š æ•°æ®å¯¹æ¯”ç»“æœ: æ–°å¢=%d, åˆ é™¤=%d, ä¿®æ”¹=%d, ä¸å˜=%d",
                     added.get(), removed.get(), changed.get(), same.get());
        }
    }

    /**
     * å¯¹æ¯”ä¸¤ä¸ªç‰ˆæœ¬çš„æŒ‡å®šåˆ†ç‰‡
     * @param shardId åˆ†ç‰‡ ID
     * @param versionA æ—§ç‰ˆæœ¬
     * @param versionB æ–°ç‰ˆæœ¬
     */
    public DiffStats compareShard(int shardId, long versionA, long versionB) throws IOException {
        String fileA = getShardFilename(versionA, shardId);
        String fileB = getShardFilename(versionB, shardId);

        Map<Long, Map<Integer, String>> dataA = loadFromFile(fileA);
        Map<Long, Map<Integer, String>> dataB = loadFromFile(fileB);

        DiffStats stats = new DiffStats();

        // éå†æ–°æ•°æ®ï¼Œå¯¹æ¯”æ—§æ•°æ®
        for (Map.Entry<Long, Map<Integer, String>> entry : dataB.entrySet()) {
            long userId = entry.getKey();
            Map<Integer, String> tagsB = entry.getValue();
            Map<Integer, String> tagsA = dataA.getOrDefault(userId, new HashMap<>());

            for (Map.Entry<Integer, String> tag : tagsB.entrySet()) {
                int tagId = tag.getKey();
                String valueB = tag.getValue();
                String valueA = tagsA.get(tagId);

                if (valueA == null) {
                    stats.added.incrementAndGet();
                } else if (!valueA.equals(valueB)) {
                    stats.changed.incrementAndGet();
                } else {
                    stats.same.incrementAndGet();
                }
                tagsA.remove(tagId); // æ ‡è®°å·²å¤„ç†
            }
        }

        // å‰©ä¸‹çš„éƒ½æ˜¯è¢«åˆ é™¤çš„
        for (Map<Integer, String> left : dataA.values()) {
            stats.removed.addAndGet(left.size());
        }

        return stats;
    }

    /**
     * åŠ è½½ä¸€ä¸ªåˆ†ç‰‡æ–‡ä»¶åˆ°å†…å­˜æ˜ å°„
     * æ ¼å¼ï¼šuserId â†’ tagId â†’ value
     */
    private Map<Long, Map<Integer, String>> loadFromFile(String filename) throws IOException {
        Map<Long, Map<Integer, String>> result = new HashMap<>();
        InputStream is = ossService.download(filename);
        try (InputStream compressed = new GZIPInputStream(is)) {
            UserTagProto.UserTag tag;
            while ((tag = UserTagProto.UserTag.parseDelimitedFrom(compressed)) != null) {
                result.computeIfAbsent(tag.getUserId(), k -> new HashMap<>())
                      .put(tag.getTagId(), tag.getTagValue());
            }
        }
        return result;
    }

    private String getShardFilename(long version, int shardId) {
        return String.format("full_data_v%d_%d.pb.gz", version, shardId);
    }
}
```

#### cã€**éªŒè¯æŸä¸ª `manifest` å¯¹åº”çš„æ‰€æœ‰æ–‡ä»¶æ˜¯å¦å®Œæ•´ã€æœªæŸå**

```java
/**
 * Manifest æ ¡éªŒå™¨ï¼šéªŒè¯æ‰€æœ‰æ–‡ä»¶æ˜¯å¦å­˜åœ¨ã€å¤§å°å’Œ MD5 æ˜¯å¦åŒ¹é…
 */
public class ManifestValidator {

    private final OssService ossService;

    public ManifestValidator(OssService ossService) {
        this.ossService = ossService;
    }

    public static class ValidationResult {
        public final boolean success;
        public final int totalFiles;
        public final int missingFiles;
        public final int sizeErrors;
        public final int md5Errors;

        public ValidationResult(boolean success, int totalFiles, int missingFiles, int sizeErrors, int md5Errors) {
            this.success = success;
            this.totalFiles = totalFiles;
            this.missingFiles = missingFiles;
            this.sizeErrors = sizeErrors;
            this.md5Errors = md5Errors;
        }

        public String summary() {
            return String.format("æ ¡éªŒç»“æœ: %s, æ–‡ä»¶æ•°=%d, ç¼ºå¤±=%d, å¤§å°é”™=%d, MD5é”™=%d",
                success ? "âœ… æˆåŠŸ" : "âŒ å¤±è´¥", totalFiles, missingFiles, sizeErrors, md5Errors);
        }
    }

    /**
     * éªŒè¯ manifest ä¸­æ‰€æœ‰æ–‡ä»¶çš„å®Œæ•´æ€§
     */
    public ValidationResult validate(ManifestGenerator.SnapshotManifest manifest) {
        int missing = 0, sizeErr = 0, md5Err = 0;

        for (ManifestGenerator.ManifestEntry entry : manifest.entries) {
            try {
                if (!ossService.exists(entry.filename)) {
                    Log.error("æ–‡ä»¶ä¸å­˜åœ¨: %s", entry.filename);
                    missing++;
                    continue;
                }

                long actualSize = ossService.getFileSize(entry.filename);
                if (actualSize != entry.size) {
                    Log.error("æ–‡ä»¶å¤§å°ä¸ç¬¦: %s, æœŸæœ›=%d, å®é™…=%d", entry.filename, entry.size, actualSize);
                    sizeErr++;
                    continue;
                }

                if (entry.md5 != null && !entry.md5.isEmpty()) {
                    String actualMd5 = ossService.getFileMd5(entry.filename);
                    if (!entry.md5.equals(actualMd5)) {
                        Log.error("MD5 æ ¡éªŒå¤±è´¥: %s, æœŸæœ›=%s, å®é™…=%s", entry.filename, entry.md5, actualMd5);
                        md5Err++;
                    }
                }
            } catch (Exception e) {
                Log.error("æ ¡éªŒæ–‡ä»¶æ—¶å¼‚å¸¸: %s", e, entry.filename);
                missing++;
            }
        }

        boolean success = missing == 0 && sizeErr == 0 && md5Err == 0;
        return new ValidationResult(success, manifest.entries.size(), missing, sizeErr, md5Err);
    }
}
```



## 4ï¼‰å¦‚ä½•ä½¿ç”¨ï¼Ÿ

#### aã€ç”Ÿæˆå¿«ç…§åï¼š**ç”Ÿæˆ + æ ¡éªŒ `manifest`**

```
// ç”Ÿæˆ manifest
manifestGenerator.generate(version, writers);

// ç«‹å³è‡ªæ£€
SnapshotManifest manifest = manifestGenerator.readManifest(version);
ValidationResult result = validator.validate(manifest);
if (!result.success) {
    throw new RuntimeException("å¿«ç…§æ ¡éªŒå¤±è´¥ï¼š" + result.summary());
}
```



#### bã€æ¯æ—¥ç›‘æ§ï¼š**å¯¹æ¯”æ˜¨å¤©å’Œä»Šå¤©çš„ manifest**

```java
SnapshotManifest yesterday = manifestLoader.load(version - 1);
SnapshotManifest today     = manifestLoader.load(version);

DiffResult diff = new ManifestComparator().compare(yesterday, today);
if (diff.hasError()) {
    alertService.send("å…¨é‡å¿«ç…§å¼‚å¸¸: " + diff.toString());
}
if (diff.hasWarning()) {
    Log.warn("æ•°æ®é‡å˜åŒ–è¾ƒå¤§: " + diff.toString());
}
```



#### cã€å‘å¸ƒå‰éªŒè¯ï¼š**å¯¹æ¯”æ–°æ—§ç‰ˆæœ¬æ•°æ®å†…å®¹**

```java
DataDiffTool diffTool = new DataDiffTool(ossService);
DiffStats stats = diffTool.compareShard(0, oldVersion, newVersion); // å…ˆæ¯”ä¸€ä¸ªåˆ†ç‰‡
stats.log();

if (stats.changed.get() > 1000) {
    Log.warn("æ ‡ç­¾å˜åŒ–è¿‡å¤šï¼Œéœ€äººå·¥ç¡®è®¤");
}
```































![ContactAuthor](https://raw.githubusercontent.com/HealerJean/HealerJean.github.io/master/assets/img/artical_bottom.jpg)



<!-- Gitalk è¯„è®º start  -->

<link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">

<script src="https://unpkg.com/gitalk@latest/dist/gitalk.min.js"></script>Â 
<div id="gitalk-container"></div>Â    
 <script type="text/javascript">
    var gitalk = new Gitalk({
		clientID: `1d164cd85549874d0e3a`,
		clientSecret: `527c3d223d1e6608953e835b547061037d140355`,
		repo: `HealerJean.github.io`,
		owner: 'HealerJean',
		admin: ['HealerJean'],
		id: 'o6Fh1rEi5GbzvuNe',
    });
    gitalk.render('gitalk-container');
</script>Â 




<!-- Gitalk end -->



