---
title: Caffeine本地缓存
date: 2023-01-03 00:00:00
tags: 
- Java
category: 
- Java
description: Caffeine本地缓存
---

**前言**     

 Github：[https://github.com/HealerJean](https://github.com/HealerJean)         

 博客：[http://blog.healerjean.com](http://HealerJean.github.io)          



# 1、缓存创建

## 1.1、`Cache`

```java

  /**
   * 一、Cache
   * 说明Cache 接口提供了显式搜索查找、更新和移除缓存元素的能力。当缓存的元素无法生成或者在生成的过程中抛出异常而导致生成元素失败，cache.get 也许会返回 null 。
   * 1、查找一个缓存元素， 没有查找到的时候返回null
   * 2、查找缓存，如果缓存不存在则生成缓存元素,  如果无法生成则返回null
   * 3、添加或者更新一个缓存元素
   * 4、移除一个缓存元素
   */
  @Test
  public void test() {
      Cache<String, String> cache = Caffeine.newBuilder()
              .expireAfterWrite(10, TimeUnit.MINUTES)
              .maximumSize(10000)
              .build();
      String key = "KeyName";

      // 1、查找一个缓存元素， 没有查找到的时候返回null
      String value = cache.getIfPresent(key);

      // 2、查找缓存，如果缓存不存在则生成缓存元素,  如果无法生成则返回null
      value = cache.get(key, k -> createExpensiveValue(key));

      // 3、添加或者更新一个缓存元素
      cache.put(key, value);

      // 4、移除一个缓存元素
      cache.invalidate(key);
  }


  /**
   * createExpensiveValue
   *
   * @param key key
   * @return String
   */
  private String createExpensiveValue(String key) {
      return RandomUtils.nextInt() + key;
  }

```

## 1.2、`LoadingCache`

```java
    /**
     * 二、LoadingCache
     * 说明：一个LoadingCache是一个Cache 附加上 CacheLoader能力之后的缓存实现。如果缓存不错在，则会通过CacheLoader.load来生成对应的缓存元素。
     */
    @Test
    public void loadingCache() {
        LoadingCache<String, String> cache = Caffeine.newBuilder()
                .maximumSize(10000)
                .expireAfterWrite(10, TimeUnit.MINUTES)
                .build(this::createExpensiveValue);
        // 批量查找缓存，如果缓存不存在则生成缓存元素
        List<String> keys = Lists.newArrayList("key1", "key2");
        Map<String, String> valueMap = cache.getAll(keys);

        cache.asMap().get("key");
        String key = cache.get("key");
    }

```

## 1.3、`AsyncCache`

```java
  /**
   * 三、asyncCache
   * 说明：
   * 1、AsyncCache就是Cache的异步形式，提供了Executor生成缓存元素并返回CompletableFuture的能力。
   * 2、默认的线程池实现是 ForkJoinPool.commonPool() ，当然你也可以通过覆盖并实现 Caffeine.executor(Executor)方法来自定义你的线程池选择。
   * 功能：
   * 1、查找一个缓存元素， 没有查找到的时候返回null
   * 2、查找缓存元素，如果不存在，则异步生成
   * 3、添加或者更新一个缓存元素
   * 4、移除一个缓存元素
   */
  @Test
  public void asyncCache() {
      AsyncCache<String, String> cache = Caffeine.newBuilder()
              .expireAfterWrite(10, TimeUnit.MINUTES)
              .maximumSize(10_000)
              .buildAsync();
      String key = "KeyName";

      // 1、查找一个缓存元素， 没有查找到的时候返回null
      CompletableFuture<String> graph = cache.getIfPresent(key);
      // 2、查找缓存元素，如果不存在，则异步生成
      graph = cache.get(key, k -> createExpensiveValue(key));
      // 3、添加或者更新一个缓存元素
      cache.put(key, graph);
      // 4、移除一个缓存元素
      cache.synchronous().invalidate(key);
  }


```



## 1.4、`AsyncLoadingCache`

```java

    /**
     * asyncLoadingCache
     * 说明：AsyncLoadingCache就是LoadingCache的异步形式，提供了异步load生成缓存元素的功能。
     * 功能：
     * 1、查找缓存元素，如果其不存在，将会异步进行生成
     * 2、批量查找缓存元素，如果其不存在，将会异步进行生成
     */
    @Test
    public void asyncLoadingCache() {

        AsyncLoadingCache<String, String> cache = Caffeine.newBuilder()
                .maximumSize(10_000)
                .expireAfterWrite(10, TimeUnit.MINUTES)
                // 你可以选择: 去异步的封装一段同步操作来生成缓存元素
                .buildAsync(this::createExpensiveValue);
                // 你也可以选择: 构建一个异步缓存元素操作并返回一个future
                // .buildAsync((key, executor) -> createExpensiveGraphAsync(key, executor));


        // 1、查找缓存元素，如果其不存在，将会异步进行生成
        String key = "KeyName";
        CompletableFuture<String> graph = cache.get(key);

        // 2、批量查找缓存元素，如果其不存在，将会异步进行生成
        List<String> keys = Lists.newArrayList("key1", "key2");
        CompletableFuture<Map<String, String>> graphs = cache.getAll(keys);
    }
```



# 2、驱逐策略

## 2.1、基于容量

### 2.1.1、基于缓存内的元素个数进行驱逐

```java
// 基于缓存内的元素个数进行驱逐
LoadingCache<Key, Graph> graphs = Caffeine.newBuilder()
    .maximumSize(10_000)
    .build(key -> createExpensiveGraph(key));
```

### 2.1.2、基于缓存内元素权重进行驱逐

```java
// 基于缓存内元素权重进行驱逐
LoadingCache<Key, Graph> graphs = Caffeine.newBuilder()
    .maximumWeight(10_000)
    .weigher((Key key, Graph graph) -> graph.vertices().size())
    .build(key -> createExpensiveGraph(key));
```



## 2.2、基于时间

### 2.2.1、基于固定的过期时间驱逐策略

```java
// 基于固定的过期时间驱逐策略
LoadingCache<Key, Graph> graphs = Caffeine.newBuilder()
    .expireAfterAccess(5, TimeUnit.MINUTES)
    .build(key -> createExpensiveGraph(key));
LoadingCache<Key, Graph> graphs = Caffeine.newBuilder()
    .expireAfterWrite(10, TimeUnit.MINUTES)
    .build(key -> createExpensiveGraph(key));
```



### 2.2.2、基于不同的过期驱逐策略

```java
// 基于不同的过期驱逐策略
LoadingCache<Key, Graph> graphs = Caffeine.newBuilder()
    .expireAfter(new Expiry<Key, Graph>() {
      public long expireAfterCreate(Key key, Graph graph, long currentTime) {
        // Use wall clock time, rather than nanotime, if from an external resource
        long seconds = graph.creationDate().plusHours(5)
            .minus(System.currentTimeMillis(), MILLIS)
            .toEpochSecond();
        return TimeUnit.SECONDS.toNanos(seconds);
      }
      public long expireAfterUpdate(Key key, Graph graph, 
          long currentTime, long currentDuration) {
        return currentDuration;
      }
      public long expireAfterRead(Key key, Graph graph,
          long currentTime, long currentDuration) {
        return currentDuration;
      }
    })
    .build(key -> createExpensiveGraph(key));
```



## 2.3、基于引用

### 2.3.1、当 `key` 和 缓存元素 都不再存在其他强引用的时候驱逐

```java

// 当key和缓存元素都不再存在其他强引用的时候驱逐
LoadingCache<Key, Graph> graphs = Caffeine.newBuilder()
    .weakKeys()
    .weakValues()
    .build(key -> createExpensiveGraph(key));
```



### 2.3.2、当进行GC的时候进行驱逐

```java
// 当进行GC的时候进行驱逐
LoadingCache<Key, Graph> graphs = Caffeine.newBuilder()
    .softValues()
    .build(key -> createExpensiveGraph(key));
```



# 3、刷新机制

> 只有在 `LoadingCache` 中可以使用刷新策略，与驱逐不同的是，在刷新的时候如果查询缓存元素，其旧值将仍被返回，直到该元素的刷新完毕后结束后才会返回刷新后的新值。

```java
LoadingCache<Key, Graph> graphs = Caffeine.newBuilder()
  .maximumSize(10_000)
  .refreshAfterWrite(1, TimeUnit.MINUTES)
  .build(key -> createExpensiveGraph(key));
```



# 4、统计

> 通过使用 `Caffeine.recordStats()` 方法可以打开数据收集功能。`Cache.stats()` 方法将会返回一个`CacheStats` 对象，其将会含有一些统计指标，比如：

```java
Cache<Key, Graph> graphs = Caffeine.newBuilder()
    .maximumSize(10_000)
    .recordStats()
    .build();
```



| 方法                   | 说明                 |
| ---------------------- | -------------------- |
| ` hitRate():`          | 查询缓存的命中率     |
| `evictionCount():`     | 被驱逐的缓存数量     |
| `averageLoadPenalty()` | 新值被载入的平均耗时 |









![ContactAuthor](https://raw.githubusercontent.com/HealerJean/HealerJean.github.io/master/assets/img/artical_bottom.jpg)



<!-- Gitalk 评论 start  -->

<link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">

<script src="https://unpkg.com/gitalk@latest/dist/gitalk.min.js"></script> 
<div id="gitalk-container"></div>    
 <script type="text/javascript">
    var gitalk = new Gitalk({
		clientID: `1d164cd85549874d0e3a`,
		clientSecret: `527c3d223d1e6608953e835b547061037d140355`,
		repo: `HealerJean.github.io`,
		owner: 'HealerJean',
		admin: ['HealerJean'],
		id: 'VwxcEL1qy9jX5gHm',
    });
    gitalk.render('gitalk-container');
</script> 




<!-- Gitalk end -->



