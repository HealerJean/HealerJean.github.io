---
title: 本地缓存
date: 2023-01-03 00:00:00
tags: 
- Java
category: 
- Java
description: 本地缓存
---

**前言**     

 Github：[https://github.com/HealerJean](https://github.com/HealerJean)         

 博客：[http://blog.healerjean.com](http://HealerJean.github.io)          

# 1、`JVM` 缓存

## 1.1、简单本地缓存

```java
@Slf4j
@Service
public class BypassTaskCacheImpl implements BypassTaskCacheService {

    /**
     * key 为版本号，value为旁路配置
     */
    private Map<String, BypassTaskConfigDto> bypassTaskMap;

    /**
     * 实时旁路 realtimeBypass
     */
    private List<BypassTaskConfigDto> realtimeBypassList;

    /**
     * 历史旁路 historyBypass
     */
    private List<BypassTaskConfigDto> historyBypassList;

    /**
     * bypassTaskMapper
     */
    @Resource
    private BypassTaskMapper bypassTaskMapper;

    /**
     * umpAlarmService
     */
    @Resource
    private UmpAlarmService umpAlarmService;

    /**
     * 启动就加载
     */
    @PostConstruct
    public void init() {
        try {
            log.info("[BypassTaskSwitchCache#init]：start");
            BypassTaskQuery taskQuery = new BypassTaskQuery();
            taskQuery.setType(BypassEnum.BypassTypeEnum.REALTIME.getCode());
            taskQuery.setTaskStatus(BypassEnum.BypassTaskStatusEnum.EXECUTING.getCode());
            taskQuery.setStatus(StatusEnum.VALID.getCode());
            Map<String, BypassTaskConfigDto> newMap = new HashMap<>(8);
            List<BypassTask> dbRealtimeBypassTasks = bypassTaskMapper.selectByExample(taskQuery);
            List<BypassTaskConfigDto> newRealtimeBypassList = new ArrayList<>();
            if (!CollectionUtils.isEmpty(dbRealtimeBypassTasks)) {
                for (BypassTask bypassTask : dbRealtimeBypassTasks) {
                    BypassTaskConfigDto bypassTaskConfigDto = BeanUtils.bypassTaskToConfigDto(bypassTask);
                    newRealtimeBypassList.add(bypassTaskConfigDto);
                    newMap.put(bypassTask.getVersion(), bypassTaskConfigDto);
                }
            }

            taskQuery = new BypassTaskQuery();
            taskQuery.setType(BypassEnum.BypassTypeEnum.HISTORY.getCode());
            taskQuery.setTaskStatusList(Arrays.asList(BypassEnum.BypassTaskStatusEnum.CREATED.getCode(), BypassEnum.BypassTaskStatusEnum.EXECUTING.getCode()));
            taskQuery.setStatus(StatusEnum.VALID.getCode());
            List<BypassTask> dbHistoryBypassTasks = bypassTaskMapper.selectByExample(taskQuery);
            List<BypassTaskConfigDto> newHistoryBypassList = new ArrayList<>();
            if (!CollectionUtils.isEmpty(dbHistoryBypassTasks)) {
                for (BypassTask bypassTask : dbHistoryBypassTasks) {
                    BypassTaskConfigDto bypassTaskConfigDto = BeanUtils.bypassTaskToConfigDto(bypassTask);
                    newHistoryBypassList.add(bypassTaskConfigDto);
                    newMap.put(bypassTask.getVersion(), bypassTaskConfigDto);
                }
            }

            bypassTaskMap = newMap;
            realtimeBypassList = newRealtimeBypassList;
            historyBypassList = newHistoryBypassList;
            log.info("[BypassTaskSwitchCache#init]：end");

        } catch (Exception e) {
            log.error("[BypassTaskSwitchCache#init] error", e);
            umpAlarmService.businessAlarm("旁路[BypassTaskSwitchCache] 失败，请关注");
        }
    }

    /**
     * 任务执行( 1分钟执行 1次)
     */
    @Scheduled(cron = "0 0/1 * * * ?")
    public void refresh() {
        log.info("[BypassTaskSwitchCache#refresh]：start");
        init();
        log.info("[BypassTaskSwitchCache#refresh]：end");
    }


    /**
     * getBypassTaskMap
     *
     * @return bypassTaskMap
     */
    @Override
    public Map<String, BypassTaskConfigDto> getBypassTaskMap() {
        return bypassTaskMap;
    }

    /**
     * getRealtimeBypassList
     *
     * @return realtimeBypassList
     */
    @Override
    public List<BypassTaskConfigDto> getRealtimeBypassList() {
        return realtimeBypassList;
    }

    /**
     * getHistoryBypassList
     *
     * @return historyBypassList
     */
    @Override
    public List<BypassTaskConfigDto> getHistoryBypassList() {
        return historyBypassList;
    }

    /**
     * getBypassTaskByVersion
     *
     * @param version version
     * @return BypassTaskConfigDto
     */
    @Override
    public BypassTaskConfigDto getBypassTaskByVersion(String version) {
        Map<String, BypassTaskConfigDto> bypassTaskMap = getBypassTaskMap();
        if (CollectionUtils.isEmpty(bypassTaskMap)) {
            return null;
        }
        return bypassTaskMap.get(version);
    }

    /**
     * 险种获取开关状态
     * 1、判断开关状态
     * 2、判断险种是否存在
     *
     * @param version       旁路版本
     * @param insuranceId   险种Id
     * @param insuranceType 子险种Id
     * @return
     */
    @Override
    public boolean getSwitch(String version, String insuranceId, String insuranceType) {
        BypassTaskConfigDto bypassTaskByVersion = getBypassTaskByVersion(version);
        if (Objects.isNull(bypassTaskByVersion)) {
            return false;
        }
        List<BypassInsuranceDto> insurances = bypassTaskByVersion.getInsurances();
        return insurances.stream().anyMatch(item -> {
            if (StringUtils.isNotBlank(item.getInsuranceType())){
                return item.getInsuranceId().equals(insuranceId) && item.getInsuranceType().equals(insuranceType);
            }
            return item.getInsuranceId().equals(insuranceId);
        });
    }


    /**
     * 获取旁路数据
     * @param version  版本号
     * @param insuranceId 险种Id
     * @param insuranceType 子险种Id
     * @return
     */
    @Override
    public MerchantBypassDto getMerchantBypassDto(String version, String insuranceId, String insuranceType) {
        BypassTaskConfigDto bypassTaskByVersion = getBypassTaskByVersion(version);
        if (Objects.isNull(bypassTaskByVersion)) {
            return null;
        }
        List<BypassInsuranceDto> insurances = bypassTaskByVersion.getInsurances();
        boolean switchFlag = insurances.stream().anyMatch(item -> {
            if (StringUtils.isNotBlank(item.getInsuranceType())) {
                return item.getInsuranceId().equals(insuranceId) && item.getInsuranceType().equals(insuranceType);
            }
            return item.getInsuranceId().equals(insuranceId);
        });
        if (Boolean.FALSE.equals(switchFlag)) {
            return null;
        }
        MerchantBypassDto merchantBypassDto = new MerchantBypassDto();
        merchantBypassDto.setVersion(bypassTaskByVersion.getVersion());
        merchantBypassDto.setBypassTaskBusinessConfigDto(bypassTaskByVersion.getBypassTaskBusinessConfig());
        return merchantBypassDto;
    }

}
```



## 1.2、`HashMap`

### 1.2.1、`LRUCache`

```java

import java.util.LinkedHashMap;
import java.util.Map;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantReadWriteLock;

/**
 * LRUCache
 * 优点：简单粗暴，不需要引入第三方包，比较适合一些比较简单的场景。
 * 缺点：没有缓存淘汰策略，定制化开发成本高。
 *
 * @author zhangyujin
 * @date 2023/1/3  13:54.
 */

public class LRUCache<K, V> extends LinkedHashMap<K, V> {

    /**
     * 可重入读写锁，保证并发读写安全性
     */
    private final ReentrantReadWriteLock readWriteLock = new ReentrantReadWriteLock();
    /**
     * readLock
     */
    private final Lock readLock = readWriteLock.readLock();
    /**
     * writeLock
     */
    private final Lock writeLock = readWriteLock.writeLock();

    /**
     * 缓存大小限制
     */
    private final int maxSize;

    public LRUCache(int maxSize) {
        super(maxSize + 1, 1.0f, true);
        this.maxSize = maxSize;
    }

    /**
     * @param key key
     * @return Object
     */
    @Override
    public V get(Object key) {
        readLock.lock();
        try {
            return super.get(key);
        } finally {
            readLock.unlock();
        }
    }

    /**
     * put
     *
     * @param key   key
     * @param value value
     * @return Object
     */
    @Override
    public V put(K key, V value) {
        writeLock.lock();
        try {
            return super.put(key, value);
        } finally {
            writeLock.unlock();
        }
    }

    /**
     * removeEldestEntry
     *
     * @param eldest eldest
     * @return boolean
     */
    @Override
    protected boolean removeEldestEntry(Map.Entry eldest) {
        return this.size() > maxSize;
    }
}
```





# 2、`GuavaCache`

## 2.1、`GuavaCache-定时刷新`

> 本方式适用于，缓存不经常变化，切已知要缓存的数据的情况（缓存不过期，通过定时进行刷新）

### 2.1.1、`AbstractLocalCacheManager`

```java

import com.google.common.cache.Cache;
import com.google.common.cache.CacheBuilder;
import com.google.common.collect.Sets;
import com.healerjean.proj.util.json.JsonUtils;
import lombok.extern.slf4j.Slf4j;
import org.springframework.scheduling.annotation.EnableScheduling;
import org.springframework.util.CollectionUtils;

import javax.annotation.PostConstruct;
import java.util.*;
import java.util.stream.Collectors;

/**
 * AbstractLocalCacheManager
 *
 * @author zhangyujin
 * @date 2023/1/3  13:19.
 */
@Slf4j
@EnableScheduling
public abstract class AbstractLocalCacheManager<K, V> {

    /**
     * 缓存容器
     */
    private final Cache<String, V> localCache = CacheBuilder.newBuilder()
            .maximumSize(200000)
            .recordStats()
            .build();

    /**
     * 初始化数据
     */
    @PostConstruct
    public void init() {
        refreshAll();
    }


    /**
     * @param k k
     * @return V
     */
    protected abstract V load(K k);

    /**
     * load
     *
     * @param keys keys
     * @return Map<K, V>
     */
    protected abstract Map<K, V> load(Set<K> keys);

    /**
     * loadAll
     *
     * @return Map<K, V>
     */
    protected abstract Map<K, V> loadAll();


    /**
     * 获取多个keys结果
     *
     * @param keys keys
     * @return Map<K, V>
     */
    public Map<K, V> getCaches(Set<K> keys) {
        if (CollectionUtils.isEmpty(keys)) {
            return Collections.emptyMap();
        }
        // 转成本地key
        Map<String, K> localKeyMap = keys.stream().collect(Collectors.toMap(this::toLocalKey, k -> k));
        // 先获取本地结果
        Map<String, V> localResultMap = localCache.getAllPresent(localKeyMap.keySet());
        // reload的结果
        Map<K, V> loadResultMap = Collections.emptyMap();
        if (localKeyMap.size() > localResultMap.size()) {
            Set<String> absentLocalKeys = Sets.difference(localKeyMap.keySet(), localResultMap.keySet());
            Set<K> absentKeys = absentLocalKeys.stream().map(localKeyMap::get).collect(Collectors.toSet());
            // 存在失效的key
            if (absentKeys.size() > 0) {
                loadResultMap = refresh(absentKeys);
            }
        }
        // 合并结果
        Map<K, V> retMap = new HashMap<>(loadResultMap);
        localResultMap.forEach((localKey, v) -> {
            K k = localKeyMap.get(localKey);
            retMap.put(k, v);
        });
        return retMap;
    }

    /**
     * 获取单个key
     *
     * @param k k
     * @return V
     */
    public V getCache(K k) {
        String localKey = toLocalKey(k);
        V ret = localCache.getIfPresent(localKey);
        if (ret == null) {
            return refresh(k);
        }
        return ret;
    }

    /**
     * 删除key
     *
     * @param keys keys
     */
    protected void delCaches(Collection<K> keys) {
        if (CollectionUtils.isEmpty(keys)) {
            return;
        }
        // 转成本地key
        Set<String> localKeys = keys.stream().map(this::toLocalKey).collect(Collectors.toSet());
        localCache.invalidateAll(localKeys);
    }

    /**
     * 重新加载key
     *
     * @param k k
     * @return V
     */
    public V refresh(K k) {
        V v = load(k);
        if (v != null) {
            writeCache(k, v);
        }
        return v;
    }

    /**
     * 重新加载多个key
     *
     * @param keys keys
     * @return Map<K, V>
     */
    public Map<K, V> refresh(Set<K> keys) {
        Map<K, V> map = load(keys);
        if (!CollectionUtils.isEmpty(map)) {
            map.forEach(this::writeCache);
        }
        return map;
    }

    /**
     * 刷新所有key
     */
    public void refreshAll() {
        long t1 = System.currentTimeMillis();
        Map<K, V> map = loadAll();
        if (!CollectionUtils.isEmpty(map)) {
            map.forEach(this::writeCache);
        }
        log.info("[AbstractLocalCacheManager#refreshAll] {}, loadAll use time: {}ms , total: {} , stats:{}", this.getClass().getSimpleName(), System.currentTimeMillis() - t1, localCache.size(), JsonUtils.toJsonString(localCache.stats()));
    }


    /**
     * toLocalKey
     *
     * @param k k
     * @return String
     */
    private String toLocalKey(K k) {
        return String.format("%s_%s", this.getClass().getSimpleName(), k.toString());
    }

    /**
     * 写入缓存
     *
     * @param k k
     * @param v v
     */
    protected void writeCache(K k, V v) {
        String localKey = toLocalKey(k);
        localCache.put(localKey, v);
    }
}
```

### 2.1.2、`StringLocalCache`

```java

import java.util.List;
import java.util.Map;
import java.util.Set;

/**
 *
 * StringLocalCache
 * @author zhangyujin
 * @date 2023/1/3  13:30.
 */
@Slf4j
@Component
public class StringLocalCache extends AbstractLocalCacheManager<String, List<String>> {

    /**
     * @param s s
     * @return load
     */
    @Override
    protected List<String> load(String s) {
        return null;
    }

    /**
     * load
     *
     * @param keys keys
     * @return Map<String, String>
     */
    @Override
    protected Map<String, List<String>> load(Set<String> keys) {
        return null;
    }


    /**
     * loadAll
     *
     * @return Map<String, String>
     */
    @Override
    protected Map<String, List<String>> loadAll() {
        return null;
    }


    /**
     * 每5分钟更新一次缓存
     */
    @Scheduled(fixedRate = 5 * 60 * 1000)
    @Override
    public void refreshAll() {
        super.refreshAll();
    }

}

```





# 3、`Caffeine`

> ⬤  `Guava` `Cache` 是由 `Google` 开源的基于 `LRU` 替换算法的缓存技术。但 `Guava`  `Cache`由于被下面即将介绍的 `Caffeine`全面超越而被取代，其和 `Caffeine` 方法基本一致      
>
> ⬤  通过对 `guava` `cache` 和 `caffeine` 从性能到算法及使用的对比中，可以发现 `Caffeine` 基本是在 `Guava` 的基础上进行优化而来的，提供的功能基本一致，但是通过对算法和部分逻辑的优化，完成了对性能极大的提升，而且我们可以发现，两者切换几乎没有成本，毕竟 `caffeine` 就是以替换 `guava` `cache` 为目的而来的。      
>
> ⬤  那么为什么这么好的东西需要被淘汰呢，如果对于本地 `Cache` 有过深入研究的人应该知道 `LRU `算法基本可以满足大部分的场景，但是很多人为了精益求精，基于 `LRU`的算法，又在此基础上提出了一系列更好的，更有效果的淘汰策略。比如有 `ARC`，`LIRS` 和 `W-TinyLFU` 等都提供了接近最理想的命中率，他们这些算法进一步提高了本地缓存的效率 （`Caffein`e 采用了一种结合 `LRU`、`LFU` 优点的算法：`W-TinyLFU`，其特点是：高命中率、低内存占用。）
>
> **注意：**
>
> > ⬤  需要注意的是，在使用 `Guava` 的 `get()` 方法时，当缓存的 `load()` 方法返回 `null` 时，会抛出 `ExecutionException`。切换到`Caffeine` 后，`get()` 方法不会抛出异常，允许返回为` null` 。

## 3.2、`Caffeine` — 定时刷新

### 3.2.1、`AbstractLocalCacheManager`

```java

import com.github.benmanes.caffeine.cache.Cache;
import com.github.benmanes.caffeine.cache.Caffeine;
import com.google.common.collect.Sets;
import com.healerjean.proj.util.json.JsonUtils;
import lombok.extern.slf4j.Slf4j;
import org.springframework.scheduling.annotation.EnableScheduling;
import org.springframework.util.CollectionUtils;

import javax.annotation.PostConstruct;
import java.util.*;
import java.util.stream.Collectors;

/**
 * AbstractLocalCacheManager
 *
 * @author zhangyujin
 * @date 2023/1/3  13:19.
 */
@Slf4j
@EnableScheduling
public abstract class AbstractLocalCacheManager<K, V> {

    /**
     * 缓存容器
     */
    private final Cache<String, V> localCache = Caffeine.newBuilder()
            .maximumSize(200000)
            .recordStats()
            .build();

    /**
     * 初始化数据
     */
    @PostConstruct
    public void init() {
        refreshAll();
    }


    /**
     * @param k k
     * @return V
     */
    protected abstract V load(K k);

    /**
     * load
     *
     * @param keys keys
     * @return Map<K, V>
     */
    protected abstract Map<K, V> load(Set<K> keys);

    /**
     * loadAll
     *
     * @return Map<K, V>
     */
    protected abstract Map<K, V> loadAll();


    /**
     * 获取多个keys结果
     *
     * @param keys keys
     * @return Map<K, V>
     */
    public Map<K, V> getCaches(Set<K> keys) {
        if (CollectionUtils.isEmpty(keys)) {
            return Collections.emptyMap();
        }
        // 转成本地key
        Map<String, K> localKeyMap = keys.stream().collect(Collectors.toMap(this::toLocalKey, k -> k));
        // 先获取本地结果
        Map<String, V> localResultMap = localCache.getAllPresent(localKeyMap.keySet());
        // reload的结果
        Map<K, V> loadResultMap = Collections.emptyMap();
        if (localKeyMap.size() > localResultMap.size()) {
            Set<String> absentLocalKeys = Sets.difference(localKeyMap.keySet(), localResultMap.keySet());
            Set<K> absentKeys = absentLocalKeys.stream().map(localKeyMap::get).collect(Collectors.toSet());
            // 存在失效的key
            if (absentKeys.size() > 0) {
                loadResultMap = refresh(absentKeys);
            }
        }
        // 合并结果
        Map<K, V> retMap = new HashMap<>(loadResultMap);
        localResultMap.forEach((localKey, v) -> {
            K k = localKeyMap.get(localKey);
            retMap.put(k, v);
        });
        return retMap;
    }

    /**
     * 获取单个key
     *
     * @param k k
     * @return V
     */
    public V getCache(K k) {
        String localKey = toLocalKey(k);
        V ret = localCache.getIfPresent(localKey);
        if (ret == null) {
            return refresh(k);
        }
        return ret;
    }

    /**
     * 删除key
     *
     * @param keys keys
     */
    protected void delCaches(Collection<K> keys) {
        if (CollectionUtils.isEmpty(keys)) {
            return;
        }
        // 转成本地key
        Set<String> localKeys = keys.stream().map(this::toLocalKey).collect(Collectors.toSet());
        localCache.invalidateAll(localKeys);
    }

    /**
     * 重新加载key
     *
     * @param k k
     * @return V
     */
    public V refresh(K k) {
        V v = load(k);
        if (v != null) {
            writeCache(k, v);
        }
        return v;
    }

    /**
     * 重新加载多个key
     *
     * @param keys keys
     * @return Map<K, V>
     */
    public Map<K, V> refresh(Set<K> keys) {
        Map<K, V> map = load(keys);
        if (!CollectionUtils.isEmpty(map)) {
            map.forEach(this::writeCache);
        }
        return map;
    }

    /**
     * 刷新所有key
     */
    public void refreshAll() {
        long t1 = System.currentTimeMillis();
        Map<K, V> map = loadAll();
        if (!CollectionUtils.isEmpty(map)) {
            map.forEach(this::writeCache);
        }
        log.info("[AbstractLocalCacheManager#refreshAll] {}, loadAll use time: {}ms , estimatedSize: {} , stats:{}", this.getClass().getSimpleName(), System.currentTimeMillis() - t1, localCache.estimatedSize(), JsonUtils.toJsonString(localCache.stats()));
    }


    /**
     * toLocalKey
     *
     * @param k k
     * @return String
     */
    private String toLocalKey(K k) {
        return String.format("%s_%s", this.getClass().getSimpleName(), k.toString());
    }

    /**
     * 写入缓存
     *
     * @param k k
     * @param v v
     */
    protected void writeCache(K k, V v) {
        String localKey = toLocalKey(k);
        localCache.put(localKey, v);
    }
}
```



### 3.2.2、`StringLocalCache`

```java

import lombok.extern.slf4j.Slf4j;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Component;

import java.util.List;
import java.util.Map;
import java.util.Set;

/**
 *
 * StringLocalCache
 * @author zhangyujin
 * @date 2023/1/3  13:30.
 */
@Slf4j
@Component
public class StringLocalCache extends AbstractLocalCacheManager<String, List<String>> {

    /**
     * @param s s
     * @return load
     */
    @Override
    protected List<String> load(String s) {
        return null;
    }

    /**
     * load
     *
     * @param keys keys
     * @return Map<String, String>
     */
    @Override
    protected Map<String, List<String>> load(Set<String> keys) {
        return null;
    }


    /**
     * loadAll
     *
     * @return Map<String, String>
     */
    @Override
    protected Map<String, List<String>> loadAll() {
        return null;
    }


    /**
     * 每5分钟更新一次缓存
     */
    @Scheduled(fixedRate = 1 * 60 * 1000)
    @Override
    public void refreshAll() {
        super.refreshAll();
    }

}

```

















![ContactAuthor](https://raw.githubusercontent.com/HealerJean/HealerJean.github.io/master/assets/img/artical_bottom.jpg)



<!-- Gitalk 评论 start  -->

<link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">

<script src="https://unpkg.com/gitalk@latest/dist/gitalk.min.js"></script> 
<div id="gitalk-container"></div>    
 <script type="text/javascript">
    var gitalk = new Gitalk({
		clientID: `1d164cd85549874d0e3a`,
		clientSecret: `527c3d223d1e6608953e835b547061037d140355`,
		repo: `HealerJean.github.io`,
		owner: 'HealerJean',
		admin: ['HealerJean'],
		id: 'GPNnLjIcWlVfrtFs',
    });
    gitalk.render('gitalk-container');
</script> 



<!-- Gitalk end -->



