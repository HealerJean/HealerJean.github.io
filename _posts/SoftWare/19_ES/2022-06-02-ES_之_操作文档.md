---
title: ES_之_操作文档
date: 2022-06-02 00:00:00
tags: 
- SoftWare
category: 
- SoftWare
description: ES_之_操作文档
---

**前言**     

 Github：[https://github.com/HealerJean](https://github.com/HealerJean)         

 博客：[http://blog.healerjean.com](http://HealerJean.github.io)          



# 1、读写文档

> `Elasticsearch` 中的每个索引都分为多个分片，每个分片可以有 多个副本，这些副本称为复制组    
>
> **注意：**在添加或删除文档时必须保持同 步。如果不这样做，将导致从一个副本中读取的数据与从另一个副本 中读取的数据表现出截然不同的结果。保持主分片和副本间       
>
> **复制模型：**两两副 本间的数据同步并提供读取服务的过程，我们称之为数据复制模型。

 

下图展示了复制组的具体含义，此复制组有三个分片，加粗的是主分片，其他两个是副本，这三个分片的数据必须保持一致

![image-20220601174517312](/Users/healerjean/Desktop/HealerJean/HCode/HealerJean.github.io/blogImages/image-20220601174517312.png)

## 1.1、主备模型

> `Elasticsearch` 的数据复制模型是基于主备 ( `primary` - `backup` ) 模型的，这个模型在微软研究中心的 `Pacifica` 论文中有很好的描述。 该模型基于复制组中作为主分片的单个数据分片。意思是，假设一个 索引有3个分片、2个副本，那么每个子索引共有3个分片，其中一个 是主分片，两个是副本，      
>
> 为了便于描述主分片，我们称主分片为 `primary`，称副本为 `replica` 。**`primary` 用作所有索引操作的主入口点**，它负责验证它们并确保它们是正确的。一旦索引操作被primary 接受，`primary` 还负责将该操作复制到其他replica(分发请求到其他 replica)。另外约定，集群中有若干个节点，其中只有一个是活跃的 主节点，它负载管理集群，我们把它称为master。



## 1.2、基本写模型

> `Elasticsearch` 中的每个索引操作首先使用路由 (通常基于文档  `ID` )解析到一个复制组。一旦确定了复制组，该操作将在内部转发到 该组的当前 `primary`。     
>
> ⬤ `primary` 负责验证操作并将其转发到其他 `replica`。由于 `replica` 可以离线，因此不需要 `primary`复制到所有 `replica`。 
>
> ⬤  相反，`Elasticsearch` 维护一个应该完成接收操作的 `replica` 列表，此列表称为同步副本组，由主节点维护。顾名思义，这些是一 组“好”的分片拷贝，保证已经处理了所有的索引和删除操作，这些 操作已经被用户确认。`primary` 负责维护这个不变量，因此必须将所 有操作复制到这个同步副本组中的每个 `replica`

### 1.3.1、`primary` 写流程

> 1、验证传入操作，如果结构无效则拒绝该操作。例如，向一个数 字字段传输一个对象类型。     
>
> 2、在本地执行操作，即索引或删除相关文档。这还将验证字段的内容，并在需要时拒绝。例如，关键字值对于 `Lucene`中的索引而言太长了。
>
> 3、将操作转发到当前同步副本组中的每个 `replica`，如果有多个 `replica`，这是并行完成的。
>
> 4、一旦所有 `replica` 都成功地执行了操作并对 `primary` 作出了响 应，`primary` 就确认完成了请求并返回给用户。



### 1.3.2、写流程错误处理

> 索引数据期间可能会有多种异常情况发生，磁盘可能损坏，节点可能彼此断开，或者某些配置错误可能导致操作在 `replica` 失败，尽管 在 `primary` 上成功。这种情况虽然不常见，但 `primary` 必须对它们作 出反应。

**1、故障转移：**如果 `primary` 本身发生故障，`primary` 所在的节点将向 `master` 节点发送相关的消息。索引操作将等待(默认情况下最多1分钟) `master` 将其中一个 `replica` 提升为新的 `primary`。然后该操作将被转发 到新的 `primary` 进行处理。同时，`master` 还监视节点的运行状况，并可能决定主动降级 `primary` 为 `replica`，当包含 `primary` 的节点由于网络问题与集群隔离时，通常会发生这种情况。

**2、副本摘除：**一旦在 `primary`上成功执行了操作，`primary` 就必须处理在 ` replica`上执行时潜在的故障。这可能是由于 `replica`上的实际故障或 网络问题导致操作无法到达 `replica` (或阻止`replica`响应)。所有这 些问题会造成相同的最终结果: 作为同步副本组的一部分的 `replica`会 错过即将被确认的操作。为了避免违反不变量，`primary` 向 `master` 发 送一条消息，请求从同步副本组中删除有问题的`replica`。只有在 `master` 确认清除 `replica` 后，`primary` 才会确认该操作。同时， `master` 还将指示另一个节点开始构建新的副本，以便将系统恢复到健 康状态。    

**3、主节点下线：** 在将操作转发到其他 `replica` 时，`primary` 将使用 `replica` 来验证它是否仍然是活动的 `primary`。如果由于网络分区(或GC时间过长)而 隔离了`primary`，则在知道到它已降级之前，它可能会继续处理传入的索引操作。来自过时 `primary` 的操作将被 `replica`拒绝，当 `primar`y 接收到来自拒绝其请求的 `replica`的响应时，它将到达 `master`并知道 它已经被替换，然后将操作路由到新的 `primary`。

## 1.3、基本读模型

> `Elasticsearch` 中的读取可以是非常轻量的按 `ID` 查找，也可以是 一个具有复杂聚合的繁重搜索请求，这些聚合需要非常大的 `CPU` 能 力。主备 (`primary` - `backup` )模型的一个优点是它保持所有的分片 (`primary` 和 `replica` )是等同的。因此，单个同步拷贝(称之为相关分片组)就足以满足读取请求。        

### 1.3.1、读流程

> **当节点接收到读取请求时，该节点负责将其转发到保存相关分片的节点整理响应，并向客户机返回结果。该节点被称为该请求的协调 节点。基本流程如下：**

1、将读取请求解析到相关分片组。注意，由于大多数搜索将被发送到一个或多个索引，所以它们通常需要从多个分片中读取，每个分片表示数据的不同子集。

2、从同步副本组中选择一个相关 `shard` 的活动分片。这可以是 `primary`，也可以是 `replica`。默认情况下，`Elasticsearch` 只需在分 片之间循环搜索。

3、向所选分片发送读取请求。

4、将结果整合。请注意，在按 `ID` 查找的情况下，只有一个分片是 相关的，可以跳过此步骤。



### 1.3.2、读流程错误处理

> 当一个分片未能响应读取请求时，协调节点将请求发送到同步副 本组中的另一个分片。重复失败可能导致没有可用的分片。为了确保快速响应，如果一个或多个分片失败，以下 `API` 将以部分结果响应:

⬤ Search API  

⬤ Multi Search      

⬤ Bulk     

⬤ Multi Get

包含部分结果的响应仍然提供200 OK HTTP状态代码。相关分 片的失败信息记录在响应头部字段里。



# 2、索引 `API`

> 索引操作成功执行时，`successful` 至少是 `1`。    
>
> **说明：默认情况下，当索引操作成功返回时，有可能一些`replica` 还没有开始或完成，因为只要 `primary`成功执行，就会返回，这种行 为可以调整。其实这样做的目的是快速响应，一般的场景并不需要等 待所有分片都完成索引操作再返回，除非对数据安全要求极高的场 景。**

| `key`        | 说明                                                         |
| ------------ | ------------------------------------------------------------ |
| `_shards `   | 头提供有关索引操作的复制过程的信息                           |
| `total`      | 指示索引操作应在多少个分片 (主 `primary` 和  `replica` )上执行 |
| `successful` | 指示索引操作成功执行的分片数                                 |
| `failed`     | 在副本分片上索引操作失败的情况下包含与复制相关的错误的数组。 |

**入参：**

```json
PUT twitter/_doc/1
{
    "user" : "kimchy",
    "post_date" : "2009-11-15T14:12:12",
    "message" : "trying out Elasticsearch"
}
```

**出参：**

```json
{
    "_shards" : {
        "total" : 2,
        "failed" : 0,
        "successful" : 2
    },
    "_index" : "twitter",
    "_type" : "_doc",
    "_id" : "1",
    "_version" : 1,
    "_seq_no" : 0,
    "_primary_term" : 1,
    "result" : "created"
}
```



## 2.1、自动创建索引

> 当索引文档时，如果索引不存在，会自动创建索引。索引操作还 将创建一个动态映射(如果尚未存在)。默认情况下，如果需要，新字段和对象将自动添加到映射定义中。
>
> 自动创建索引由 `action.auto_create_index` 设置控制。     
>
> 1、此设置默 认为 `true`，这意味着索引总是自动创建的。     
>
> 2、也可以设置只有匹配特定模式的索引才允许自动创建索引，方法是将此设置的值更改为这些匹配模式的逗号分隔列表。     
>
> 3、还可以通过在列表中的模式前面加上 + 或 - ， 明确地允许和禁止使用它。     
>
> **4、最后，通过将此设置更改为 `false`，可以完 全禁用它。可以在 `elasticsearch.ym`l 中配置，也可以通过如下`URL` 配置。下面是几个示例**。



### 2.1.1、特定模式才允许创建

> 只允许自动创建名为 `twitter`、`index` `10` 的索引，不允许创建其他与 `index1*` 匹配的索引

```json

PUT _cluster/settings
{
  "persistent": {
    "action.auto_create_index": "twitter,index10,-index1*,+ind*"  
  }

```

### 2.1.2、完全禁用索引的自动创建

```json

PUT _cluster/settings
{
  "persistent": {
    "action.auto_create_index": "false" 
  }

```

### 2.1.3、允许使用任何名称自动创建索引

> 是默认设置

```json
PUT _cluster/settings
{
  "persistent": {
    "action.auto_create_index": "true" 
  }
```

### 2.1.4、索引存在 ( 覆盖&失败 )

> 索引操作还接受一个 `op_type` 参数，它可以用来强制 `create` 操 作，允许 `put-if-absent` 的行为。使用`create` 时，如果索引中已存在具 有该 `ID`的文档，则索引操作将失败。       
>
> ⬤ 默认情况下，当文 档存在时直接覆盖。       
>
> ⬤ 当索引文档时，如果带有 `&op_type=true` 参 数，明确指明是创建文档，如果文档存在就报错。

**入参：**

```
PUT twitter/_doc/1?op_type=create
{
    "user" : "kimchy",
    "post_date" : "2009-11-15T14:12:12",
    "message" : "trying out Elasticsearch"
}
```

**出参：**

```
{
  "error" : {
    "root_cause" : [
      {
        "type" : "version_conflict_engine_exception",
        "reason" : "[1]: version conflict, document already exists (current version [1])",
        "index_uuid" : "d9PDPxM-Tja9Hb1k1jsEbA",
        "shard" : "0",
        "index" : "twitter"
      }
    ],
    "type" : "version_conflict_engine_exception",
    "reason" : "[1]: version conflict, document already exists (current version [1])",
    "index_uuid" : "d9PDPxM-Tja9Hb1k1jsEbA",
    "shard" : "0",
    "index" : "twitter"
  },
  "status" : 409
}

```



## 2.2、`ID` 自动生成

> 索引操作可以在不指定 `ID` 的情况下执行。在这种情况下，将自动 生成一个 `ID`。此外，`op_type`将自动设置为`create`。下面是一个例子 (注意使用 `POST` 而不是 `PUT` )



## 2.3、路由

> 默认情况下，碎片放置(或路由)是通过使用文档 `id` 值的散列来控制的。为了实现更明确的控制，可以使用路由参数直接在每个操作的基础上指定路由器使用的散列函数的值。       
>
> 注意：在设置显式 `mapping` 时，可以选择使用  `routing` 字段从文档本身 提取路由值。如果定义了 `mapping` 的`_routing` 值并将其设置为必需， 则如果没有提供可提取路由值，索引操作将失败。

```json
POST /twitter/_doc?routing=kimchy
{
    "user" : "kimchy",
    "post_date" : "2009-11-15T14:12:12",
    "message" : "trying out Elasticsearch"
}
```



## 2.4、分发

> 索引操作根据路由定向到 `primary` ，并在包含此分片的实际节点 上执行。在 `primary` 完成操作后，如果需要，操作将分发到需要的其他分片。



## 2.5、等待活动分片

> 为了兼顾系统写入的效率和可靠性，可以将索引操作配置为在继 续操作之前等待一定数量的活动分片。如果所需数量的活动分片不可 用，则写入操作必须等待并重试，直到所需分片已启动或发生超时。 默认情况下，写入操作仅在继续之前等待 `primary` 完成 (即  `wait_for_active_shards` = `1` ) 。         
>
> 1、可以通过设置 `index.write.wait_for_active_shards` 来 动 态 重 写 此 默 认 值 。        
>
> 2、要 更 改 每个请求操作的此行为，可以使用 `wait_for_active_shards` 请求参 数。`wait_for_active_shards` 的有效值是任何正整数，最多为分片总 数。指定负值或大于分片数的数字将引发错误。



**例如：假设有一个由 `3` 个节点 ( `A` 、`B` 和 `C` ) 组成的集群，并且创 建了一个索引 `index` ，其中副本数设置为 `3`  (结果是共 `4` 个分片)。 如果我们尝试索引操作**      

1、默认情况下，该操作将仅确保 `primary` 在继续操作之前可用。这意味着，即使 `B` 和 `C` 发生故障，并且 `A` 托管了 `primary` ， 索 引 操 作 仍 然 继 续 进 行 。        

2、如果在请求中将 `wait_for_active_shards` 设置为 `3` ( 并且所有 `3` 个节点都已启动)，那么索引操作将需要3个活动的 `shard` 副本才能继续。这一要求应该满足，因为集群中有 `3` 个活动的节点，每个节点都保存一个 `shard` 副本。 但是，如果我们将 `wait_for_active_shards` 设置为 `all` ( 或设置为 `41`， 这是相同的)，则索引操作将不会继续，因为索引中没有每个 `shard` 的所有4个副本。除非在集群中出现新节点以承载分片的第四副本， 否则操作将超时



## 2.6、`detect_noop` 参数

> 使用索引 `API` 更新文档时，即使文档没有更改，也会始终创建文 档的新版本。如果不想这样做，可以使用`detect_noop` = `true` 参数。这 个参数的作用是在更新之前与原文档对比，如果没有字段值的变化， 则不做更新操作。



# 3、`GET` `API`

> `GET API` 允许根据其 `ID` 从索引中获取 `JSON` 文档。以下示例从 `twitter` 的索引中获取 `ID` 值为 `1` 的 `JSON`文档:



**入参：**

```http
GET twitter/_doc/1
```

**出参：**

```

```









![ContactAuthor](https://raw.githubusercontent.com/HealerJean/HealerJean.github.io/master/assets/img/artical_bottom.jpg)



<!-- Gitalk 评论 start  -->

<link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">

<script src="https://unpkg.com/gitalk@latest/dist/gitalk.min.js"></script> 
<div id="gitalk-container"></div>    
 <script type="text/javascript">
    var gitalk = new Gitalk({
		clientID: `1d164cd85549874d0e3a`,
		clientSecret: `527c3d223d1e6608953e835b547061037d140355`,
		repo: `HealerJean.github.io`,
		owner: 'HealerJean',
		admin: ['HealerJean'],
		id: 'lwEXOoSTCaIsybNJ',
    });
    gitalk.render('gitalk-container');
</script> 




<!-- Gitalk end -->



