---
title: Redis集群之_众志成城_Cluster
date: 2020-04-22 03:33:00
tags: 
- Redis
category: 
- Redis
description: Redis集群之_众志成城_Cluster
---



**前言**     

 Github：[https://github.com/HealerJean](https://github.com/HealerJean)         

 博客：[http://blog.healerjean.com](http://HealerJean.github.io)          



# 1、引入

> `RedisCluster` 是 `Redis` 的亲儿子，它是 `Redis` 作者自己提供的 `Redis` 集群化方案。
>
> **相对于 `Codis` 的不同，它是去中心化的**，**如图所示，该集群有三个 `Redis` 节点组成， 每个节点负责整个集群的一部分数据，每个节点负责的数据多少可能不一样。这三个节点相 互连接组成一个对等的集群，它们之间通过一种特殊的二进制协议相互交互集群信息。**



![image-20210609195358458](https://raw.githubusercontent.com/HealerJean/HealerJean.github.io/master/blogImages/image-20210609195358458.png)

1、`Redis` `Cluster` 将所有数据划分为 `16384 (2^14)` 的 `slots`，它比 `Codis` 的 `1024` 个槽划分的更为 精细，每个节点负责其中一部分槽位。槽位的信息存储于每个节点中，它不像 `Codis`，它不需要另外的分布式存储来存储节点槽位信息。       

2、当 `Redis` `Cluster` 的客户端来连接集群时，它也会得到一份集群的槽位配置信息。这样当客户端要查找某个 `key` 时，可以直接定位到目标节点。    这点不同于 `Codis`，`Codis` 需要通过 `Proxy` 来定位目标节点，`RedisCluster` 是直接定位。客户端为了可以直接定位某个具体的 `key` 所在的节点，它就需要缓存槽位相关信息，这样才可以准确快速地定位到相应的节点。      

**3、同时因为槽位的信息可能会存在客户端与服务器不一致的情况，还需要纠正机制来实现槽位信息的校验调整（下面的跳转）**。

**另外，`RedisCluster` 的每个节点会将集群的配置信息持久化到配置文件中，所以必须确保配置文件是可写的，而且尽量不要依靠人工修改配置文件**。



# 2、槽位定位算法

> 1、`Cluster` 默认会对 `key` 值使用 `crc32` 算法进行 `hash` 得到一个整数值，然后用这个整数 值对 `16384` 进行取模来得到具体槽位    
>
> **2、`Cluster` 还允许用户强制某个 `key` 挂在特定槽位上，通过在 `key` 字符串里面嵌入 `tag` 标 记，这就可以强制 `key` 所挂在的槽位等于 `tag` 所在的槽位**。



# 3、跳转(纠正槽位)

> 当客户端向一个错误的节点发出了指令，该节点会发现指令的 `key` 所在的槽位并不归自 己管理，这时它会向客户端发送一个特殊的跳转指令携带目标操作的节点地址，告诉客户端去连这个节点去获取数据。

```
GET x
-MOVED 3999 127.0.0.1:6381
```

1、`MOVED` 指令的第一个参数 `3999` 是 `key` 对应的槽位编号，后面是目标节点地址。`MOVED` 指令前面有一个减号，表示该指令是一个错误消息。

2、客户端收到 `MOVED` 指令后，要立即纠正本地的槽位映射表。后续所有 `key` 将使用新的槽位映射表。



# 4、迁移

> `Redis` `Cluster` 提供了工具 `redis-trib` 可以让运维人员手动调整槽位的分配情况，它使用 `Ruby` 语言进行开发，通过组合各种原生的 `Redis` `Cluster` 指令来实现。          

⬤ 这点 `Codis` 做的更加 人性化，它不但提供了 `UI` 界面可以让我们方便的迁移，还提供了自动化平衡槽位工具，无 需人工干预就可以均衡集群负载。    

⬤ 不过 `Redis` 官方向来的策略就是提供最小可用的工具，其 它都交由社区完成。



## 4.1、迁移过程

> `Redis` 迁移的单位是槽，`Redis` 一个槽一个槽进行迁移，当一个槽正在迁移时，这个槽就处于中间过渡状态。这个槽在原节点的状态为 `migrating`，在目标节点的状态为 `importing`，表 示数据正在从源流向目标。          
>
> > **从源节点获取内容 => 存到目标节点 => 从源节点删除内容**。    



1、迁移工具 `redis-trib` 首先会在源节点和目标节点设置好中间过渡状态，然后一次性获取源节点槽位的所有 `key` 列表(`keysinslot` 指令，可以部分获取)      再挨个 `key` 进行迁移      

2、原节点对当前的 `key` 执行 `dump` 指令得 到序列化内容（`RDB`文件）    

3、源节点向目标节点发送指令  `restore`  携带序列化的内容作为参数，目标节点再进行反序列化就可以将内容恢复到目标节点的内存中     

4、接着，目标节点向源节点「客户端」返回 `OK`，源节点「客户端」收到后再把当前节点的 `key` 删除掉就完成了单个 `key` 迁移的整个过 程。



![image-20210609201348637](https://raw.githubusercontent.com/HealerJean/HealerJean.github.io/master/blogImages/image-20210609201348637.png)

## 4.2、迁移说明

**1、迁移过程是同步的，原节点主线程会阻塞**     

迁移过程是同步的，在目标节点执行 `restore ` 指令到原节点删除 `key` 之间，原节点的主线程会处于阻塞状态，直到 `key` 被成功删除。     



**2、出现网络中断，网络恢复后会继续**      

如果迁移过程中突然出现网络故障，整个 `slot` 的迁移只进行了一半。这时两个节点依旧处于中间过渡状态。待下次迁移工具重新连上时，会提示用户继续进行迁移。                



**3、避免出现大`key`**         

在迁移过程中，如果每个 `key` 的内容都很小，`migrate` (`dump` + `resotre` + `del`) 指令执行会很快，它就并不会影响 客户端的正常访问。如果 `key` 的内容很大，因为 `migrate` 指令是阻塞指令会同时导致原节点和 目标节点卡顿，影响集群的稳定型。所以在集群环境下业务逻辑要尽可能避免大 `key `的产 生。



## 4.3、迁移过程，客户端的变化

> 在迁移过程中，客户端访问的流程会有很大的变化。

1、首先新旧两个节点对应的槽位都存在部分 `key` 数据。客户端先尝试访问旧节点，如果对应的数据还在旧节点里面，那么旧节点正常处理。      

2、如果对应的数据不在旧节点里面，那么有两种可能，要么该数据在新节点里，要么根本就不存在。旧节点不知道是哪种情况，所以它 会向客户端返回一个 `-ASK targetNodeAddr` 的重定向指令。客户端收到这个重定向指令后，先去目标节点执行一个不带任何参数的 `asking` 指令，然后在目标节点再重新执行原先的操作指令。



**问题1：为什么需要执行一个不带参数的 `asking` 指令呢?**

答案：**因为在迁移没有完成之前，按理说这个槽位还是不归新节点管理的**，如果这个时候向目 标节点发送该槽位的指令，节点是不认的，它会向客户端返回一个`-MOVED` 重定向指令告诉 它去源节点去执行。如此就会形成 重定向循环。`asking` 指令的目标就是打开目标节点的选 项，告诉它下一条指令不能不理，而要当成自己的槽位来处理。   





## 4.4、槽位迁移感知

**问题1：如果 `Cluster` 中某个槽位正在迁移或者已经迁移完了，`client `如何能感知到槽位的变化呢?**     

答案：客户端保存了槽位和节点的映射关系表，它需要即时得到更新，才可以正常地将某条指 令发到正确的节点中。      



**问题2：客户端怎么槽位变化感知呢？**    

答案：  `Cluster` 有两个特殊的 `error` 指令，一个是 `moved`，一个是` asking`。     

⬤  **`moved` 是用来纠正槽位的**。如果我们将指令发送到了错误的节点，该节点发现 对应的指令槽位不归自己管理，就会将目标节点的地址随同 `moved` 指令回复给客户端通知 客户端去目标节点去访问。**这个时候客户端就会刷新自己的槽位关系表，然后重试指令，后续所有打在该槽位的指令都会转到目标节点**。       

⬤  **`asking` 指令和 `moved` 不一样，它是用来临时纠正槽位的。如果当前槽位正处于迁移中，指令会先被发送到槽位所在的旧节点**，如果旧节点存在数据，那就直接返回结果 了，如果不存在，那么它可能真的不存在也可能在迁移目标节点上。所以旧节点会通知客户端去新节点尝试一下拿数据，看看新节点有没有。这时候就会给客户端返回一个 `asking error` 携带上目标节点的地址。客户端收到这个 `asking error` 后，就会去目标节点去尝试。**客户端不会刷新槽位映射关系表，因为它只是临时纠正该指令的槽位信息，不影响后续指令**。     



### 4.4.1、重试 2 次

> `moved` 和 `asking` 指令都是重试指令，客户端会因为这两个指令多重试一次。

**问题1：会不会存在一种情况，客户端有可能重试 2 次呢?**     

答案：这种情况是存在的，比如一条指令 被发送到错误的节点，这个节点会先给你一个 `moved` 错误告知你去另外一个节点重试。所 以客户端就去另外一个节点重试了，结果刚好这个时候运维人员要对这个槽位进行迁移操 作，于是给客户端回复了一个 `asking` 指令告知客户端去目标节点去重试指令。所以这里客 户端重试了 2 次。



### 4.4.2、重试多次

**问题1：：在某些特殊情况下，客户端甚至会重试多次，那怎么办，一直死循环吗？**     

答案：正是因为存在多次重试的情况，所以客户端的源码里在执行指令时都会有一个循环，然后会设置一个最大重试次数，`Java` 和 `Python` 都有这个参数，只是设置的值不一样。当重试 次数超过这个值时，客户端会直接向业务层抛出异常。





# 5、网络抖动

> 真实世界的机房网络往往并不是风平浪静的，它们经常会发生各种各样的小问题。比如网络抖动就是非常常见的一种现象，突然之间部分连接变得不可访问，然后很快又恢复正常。



**问题1：怎么解决这种网络抖动现象？**           

答案：为解决这种问题，`Redis Cluster` 提供了一种选项 `cluster-node-timeout`，表示当某个节点持续 `timeout` 的时间失联时，才可以认定该节点出现故障，需要进行主从切换。如果没有这个选项，网络抖动会导致主从频繁切换 (数据的重新复制)。            

此外，与之对应，还有另外一个选项  `cluster-slave-validity-factor` 作为倍乘系数来放大这个超时时间来宽松容错的紧急程度。如果这个系数为零，那么主从切换是不会抗拒网络抖动的。如果这个系数大 于 `1`，它就成了主从切换的松弛系数。



# 6、可能下线与确定下线

> 可能下线 (`PFAIL-Possibly Fail`) 与确定下线 (`Fai`l)
>
> 1、因为 `Redis Cluster` 是去中心化的，一个节点认为某个节点失联了并不代表所有的节点都 认为它失联了。所以集群还得经过一次协商的过程，只有当大多数节点都认定了某个节点失 联了，集群才认为该节点需要进行主从切换来容错。         
>
> 2、`Redis` 集群节点采用 `Gossip` 协议来广播自己的状态以及自己对整个集群认知的改变。比 如一个节点发现某个节点失联了 (`PFail`)，它会将这条信息向整个集群广播，其它节点也就可以收到这点失联信息。     
>
> 3、如果一个节点收到了某个节点失联的数量 (`PFai`l `Count`) 已经达到了集群的大多数，就可以标记该节点为确定下线状态 (`Fail`)，然后向整个集群广播，**强迫其它节点也接收该节点已经下线的事实，并立即对该失联节点进行主从切换**



# 7、`Cluster` 基本使用

> `Cluster` 是去中心化的，它有多个节点组成，构造 `StrictRedisCluster` 实例时，    
>
> 1、我们可以   只用一个节点地址，其它地址可以自动通过这个节点来发现。     
>
> 2、不过如果提供多个节点地址， 安全性会更好。如果只提供一个节点地址，那么当这个节点挂了，客户端就必须更换地址才 可以继续访问`Cluster`。 第二个参数 `decode_responses` 表示是否要将返回结果中的 `byte` 数 组转换成 `unicode`。





# 8、集群功能的代价(限制)

**1、事务不能支持**       

`key`的事物操作支持有限，只支持多个`key`在同一节点的事物操作，当多个`key`分布在不同的节点上的时候无法使用事物功能。同样 `rename` 操作也很危险，它的参数是两个 `key`，如果这两个 `key` 在不同的 `Redis` 实 例中，`rename` 操作是无法正确完成的        



**2、 `mget` 指令不支持**     

`mget` 目前只支持具有相同`slot`值的批量操作，因为`mset` 其实也就是多个`key`的存储，可能存储到不同的节点也说不定。所以不支持(`Codit` 是会拆解成`get`，然后汇总返回给客户端)。



**3、复制结构只支持一层**      

复制结构只支持一层，不支持嵌套树状结构。从节点只能复制主节点        



# 9、集群变更感知

**问题1：当服务器节点变更时，客户端应该即时得到通知以实时刷新自己的节点关系表。那客户 端是如何得到通知的呢?**      

**答案：这里要分 `2` 种情况:**

第一种情况：目标节点挂掉了，客户端会抛出一个 `ConnectionError`，紧接着会随机挑一个节点来重试（上面提到的多写几个地址），这时被重试的节点会通过 `moved` `error` 告知目标槽位被分配到的新的节点地址。

第二种情况：运维手动修改了集群信息，将 `master` 切换到其它节点，并将旧的 `master` 移除集群。这时打在旧节点上的指令会收到一个 `ClusterDown` 的错误，告知当前节点所在集群不可 用 (**当前节点已经被孤立了，它不再属于之前的集群)**。这时客户端就会关闭所有的连接，清空槽位映射关系表，然后向上层抛错。待下一条指令过来时，就会重新尝试初始化节点信息。



# 10、`Redis` 主从复制、哨兵和集群原理与区别

> **复制(`Replication`)**：则是负责让一个`Redis`服务器可以配备多个备份的服务器，**`Redis`为了解决单点数据库问题，会把数据复制多个副本部署到其他节点上，通过复制，实现`Redis`的高可用性，实现对数据的冗余备份，保证数据和服务的高度可靠性**。         
>
> **哨兵(`Sentinel`)**：可以管理多个`Redis`服务器，它提供了监控，提醒以及自动的故障转移的功能，哨兵是`Redis`集群架构中非常重要的一个组件，**哨兵的出现主要是解决了主从复制出现故障时需要人为干预的问题**。      
>
> > **1. 主从复制**：**读写分离，备份数据、负载均衡，一个`Master`可以有多个`Slaves`。**   
> >
> > **2. 哨兵`sentinel`**：为了高可用，监控，自动转移，哨兵发现主服务器挂了后，就会从`slave`中重新选举一个主服务器。    
> >
> > **3. 集群**：为了解决单机 `Redis` 容量有限的问题，将数据按一定的规则分配到多台机器，内存/`QPS`不受限于单机，可受益于分布式集群高扩展性。



![image-20201221173352445](https://raw.githubusercontent.com/HealerJean/HealerJean.github.io/master/blogImages/image-20201221173352445.png)



> 



![image-20201221173752786](https://raw.githubusercontent.com/HealerJean/HealerJean.github.io/master/blogImages/image-20201221173752786.png)

















![ContactAuthor](https://raw.githubusercontent.com/HealerJean/HealerJean.github.io/master/assets/img/artical_bottom.jpg)



<!-- Gitalk 评论 start  -->

<link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">

<script src="https://unpkg.com/gitalk@latest/dist/gitalk.min.js"></script> 
<div id="gitalk-container"></div>    
 <script type="text/javascript">
    var gitalk = new Gitalk({
		clientID: `1d164cd85549874d0e3a`,
		clientSecret: `527c3d223d1e6608953e835b547061037d140355`,
		repo: `HealerJean.github.io`,
		owner: 'HealerJean',
		admin: ['HealerJean'],
		id: 'OhFjXESBLG108QwJ',
    });
    gitalk.render('gitalk-container');
</script> 




<!-- Gitalk end -->



