---
title: Redis的一些核心问题
date: 2018-10-11 03:33:00
tags: 
- Cache
category: 
- Cache
description: Redis的一些核心问题
---

**前言**     

 Github：[https://github.com/HealerJean](https://github.com/HealerJean)         

 博客：[http://blog.healerjean.com](http://HealerJean.github.io)         

​       

# 1、单线程Redis为什么那么快     

1、纯内存操作        

2、单线程操作，避免了资源的竞争         

3、采用了非阻塞I/O多路复用机制



# 2、如何应对缓存穿透和缓存雪崩问题

## 2.1、缓存穿透，

> 即黑客故意去请求缓存中不存在的数据，导致所有的请求都怼到数据库上，从而数据库连接异常。

### 2.1.1、方案1、使用互斥锁排队   

> 业界比价普遍的一种做法，即根据key获取value值为空时，锁上，从数据库中load数据后再释放锁。若其它线程获取锁失败，则等待一段时间后重试。     
>
> 这里要注意，分布式环境中要使用分布式锁，单机的话用普通的锁（synchronized、Lock）就够了。(因为这样大量查询无效key访问不是很多，如果大量查询的肯定放到缓存里面去了)          




```java

public String getWithLock(String key, Jedis jedis, String lockKey, String uniqueId, long expireTime) {
    // 通过key获取value
    String value = redisService.get(key);
    if (StringUtil.isEmpty(value)) {
        // 分布式锁，详细可以参考https://blog.csdn.net/fanrenxiang/article/details/79803037
        //封装的tryDistributedLock包括setnx和expire两个功能，在低版本的redis中不支持
        try {
            boolean locked = redisService.tryDistributedLock(jedis, lockKey, uniqueId, expireTime);
            if (locked) {
                value = userService.getById(key);
                redisService.set(key, value);
                redisService.del(lockKey);
                return value;
            } else {
                // 其它线程进来了没获取到锁便等待50ms后重试
                Thread.sleep(50);
                getWithLock(key, jedis, lockKey, uniqueId, expireTime);
            }
        } catch (Exception e) {
            log.error("getWithLock exception=" + e);
            return value;
        } finally {
            redisService.releaseDistributedLock(jedis, lockKey, uniqueId);
        }
    }
    return value;


```



### 2.1.2、布隆过滤器

> `bloomfilte`r就类似于一个`hash set`，用于快速判某个元素是否存在于集合中，其典型的应用场景就是快速判断一个key是否存在于某容器，不存在就直接返回。布隆过滤器的关键就在于`hash`算法和容器大小，下面先来简单的实现下看看效果，我这里用guava实现的布隆过滤器：  



> 使用定时任务将数据库值放到布隆过滤器中，如果布隆过滤器有的话，则返回，没有的话就是没有


```xml
<dependencies>  
    <dependency>  
        <groupId>com.google.guava</groupId>  
        <artifactId>guava</artifactId>  
        <version>23.0</version>  
    </dependency>  
</dependencies> 

```


```java
public class BloomFilterTest {
 
    private static final int capacity = 1000000;
    private static final int key = 999998;
 
    private static BloomFilter<Integer> bloomFilter = BloomFilter.create(Funnels.integerFunnel(), capacity);
 
    static {
        for (int i = 0; i < capacity; i++) {
            bloomFilter.put(i);
        }
    }
 
    public static void main(String[] args) {
        /*返回计算机最精确的时间，单位微妙*/
        long start = System.nanoTime();
 
        if (bloomFilter.mightContain(key)) {
            System.out.println("成功过滤到" + key);
        }
        long end = System.nanoTime();
        System.out.println("布隆过滤器消耗时间:" + (end - start));
        int sum = 0;
        for (int i = capacity + 20000; i < capacity + 30000; i++) {
            if (bloomFilter.mightContain(i)) {
                sum = sum + 1;
            }
        }
        System.out.println("错判率为:" + sum);
    }
}



成功过滤到999998
布隆过滤器消耗时间:215518
错判率为:318

可以看到，100w个数据中只消耗了约0.2毫秒就匹配到了key，速度足够快。然后模拟了1w个不存在于布隆过滤器中的key，匹配错误率为318/10000，也就是说，出错率大概为3%，跟踪下BloomFilter的源码发现默认的容错率就是0.03：

public static <T> BloomFilter<T> create(Funnel<T> funnel, int expectedInsertions /* n */) {
  return create(funnel, expectedInsertions, 0.03); // FYI, for 3%, we always get 5 hash functions
}

```



## 3.2、缓存雪崩

>  即缓存同一时间大面积的失效，这个时候又来了一波请求，结果请求都怼到数据库上，从而导致数据库连接异常。

方案1、也是像解决缓存穿透一样加锁排队，实现同上;      

方案2、建立备份缓存，缓存A和缓存B，A设置超时时间，B不设值超时时间，先从A读缓存，A没有读B，并且异步启动一个更新线程，更新A缓存和B缓存;    

方案3、设置缓存超时时间的时候加上一个随机的时间长度，比如这个缓存key的超时时间是固定的5分钟加上随机的2分钟，酱紫可从一定程度上避免雪崩问题；









# 6、Redis 主从复制、哨兵和集群原理与区别

> **哨兵(Sentinel)**：可以管理多个Redis服务器，它提供了监控，提醒以及自动的故障转移的功能。    
>
> **复制(Replication)**：则是负责让一个Redis服务器可以配备多个备份的服务器。

## 6.1、哨兵

> 哨兵是Redis集群架构中非常重要的一个组件，哨兵的出现主要是解决了主从复制出现故障时需要人为干预的问题。

### 6.1.1、Redis哨兵主要功能

（1）集群监控：负责监控Redis master和slave进程是否正常工作    

（2）消息通知：如果某个Redis实例有故障，那么哨兵负责发送消息作为报警通知给管理员    

（3）故障转移：如果master node挂掉了，会自动转移到slave node上    

（4）配置中心：如果故障转移发生了，通知client客户端新的master地址

![image-20201221173352445](D:\study\HealerJean.github.io\blogImages\image-20201221173352445.png)



### 6.1.2、Redis哨兵的高可用

> 原理：当主节点出现故障时，由`Redis Sentinel`自动完成故障发现和转移，并通知应用方，实现高可用性

1、哨兵机制建立了多个哨兵节点(进程)，共同监控数据节点的运行状况。   

2、同时哨兵节点之间也互相通信，交换对主从节点的监控状况。   

3、每隔1秒每个哨兵会向整个集群：Master主服务器+Slave从服务器+其他Sentinel（哨兵）进程，发送一次ping命令做一次心跳检测。    

这个就是哨兵用来判断节点是否正常的重要依据，涉及两个新的概念：**主观下线和客观下线**。

**主观下线：一个哨兵节点判定主节点down掉是主观下线。**    

**客观下线：只有半数哨兵节点都主观判定主节点down掉，此时多个哨兵节点交换主观判定结果，才会判定主节点客观下线。**     

基本上哪个哨兵节点最先判断出这个主节点客观下线，就会在各个哨兵节点中发起投票机制Raft算法（选举算法），最终被投为领导者的哨兵节点完成主从自动化切换的过程。



## 6.2、Redis复制

> Redis为了解决单点数据库问题，会把数据复制多个副本部署到其他节点上，通过复制，实现Redis的高可用性，实现对数据的冗余备份，保证数据和服务的高度可靠性。   



①从数据库向主数据库发送sync(数据同步)命令。   

②主数据库接收同步命令后，会保存快照，创建一个RDB文件。   

③当主数据库执行完保持快照后，会向从数据库发送RDB文件，而从数据库会接收并载入该文件。   

④主数据库将缓冲区的所有写命令发给从服务器执行。    

⑤以上处理完之后，之后主数据库每执行一个写命令，都会将被执行的写命令发送给从数据库。   

注意：在Redis2.8之后，主从断开重连后会根据断开之前最新的命令偏移量进行增量复制



![image-20201221173752786](D:\study\HealerJean.github.io\blogImages\image-20201221173752786.png)





## 6.3、区别

**1. 主从复制模式**：**读写分离，备份数据、负载均衡，一个Master可以有多个Slaves。**   

**2. 哨兵sentinel**：为了高可用，监控，自动转移，哨兵发现主服务器挂了后，就会从slave中重新选举一个主服务器。    

**3. 集群**：为了解决单机Redis容量有限的问题，将数据按一定的规则分配到多台机器，内存/QPS不受限于单机，可受益于分布式集群高扩展性。











​    ![ContactAuthor](https://raw.githubusercontent.com/HealerJean/HealerJean.github.io/master/assets/img/artical_bottom.jpg)



<!-- Gitalk 评论 start  -->

<link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk@latest/dist/gitalk.min.js"></script> 
<div id="gitalk-container"></div>    
 <script type="text/javascript">
    var gitalk = new Gitalk({
		clientID: `1d164cd85549874d0e3a`,
		clientSecret: `527c3d223d1e6608953e835b547061037d140355`,
		repo: `HealerJean.github.io`,
		owner: 'HealerJean',
		admin: ['HealerJean'],
		id: 'skDRFNjJPyg5QiV4',
    });
    gitalk.render('gitalk-container');
</script> 

<!-- Gitalk end -->

